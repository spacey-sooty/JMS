{"version":3,"file":"index.js","sources":["webpack:///webpack/bootstrap","webpack:///./src/components/TextButton.scss?9052","webpack:///./src/components/IconButton.scss?8012","webpack:///./src/components/ImporterFrame.scss?9c61","webpack:///./src/components/file-step/FileSelector.scss?dd56","webpack:///./src/components/file-step/FormatErrorMessage.scss?898f","webpack:///./src/components/file-step/FormatRawPreview.scss?0237","webpack:///./src/components/file-step/FormatDataRowPreview.scss?bb3a","webpack:///./src/components/file-step/FileStep.scss?8c88","webpack:///./src/components/fields-step/ColumnDragCard.scss?0c54","webpack:///./src/components/fields-step/ColumnDragObject.scss?1da5","webpack:///./src/components/fields-step/ColumnDragSourceArea.scss?fdb8","webpack:///./src/components/fields-step/ColumnDragTargetArea.scss?aac4","webpack:///./src/components/ProgressDisplay.scss?6ad0","webpack:///./src/components/Importer.scss?f3ca","webpack:///./src/components/ImporterProps.ts","webpack:///./src/parser.ts","webpack:///./src/components/TextButton.tsx","webpack:///./src/components/IconButton.tsx","webpack:///./src/locale/index.ts","webpack:///./src/locale/LocaleContext.tsx","webpack:///./src/components/ImporterFrame.tsx","webpack:///./src/components/file-step/FileSelector.tsx","webpack:///./src/components/file-step/FormatErrorMessage.tsx","webpack:///./src/components/file-step/FormatRawPreview.tsx","webpack:///./src/components/file-step/FormatDataRowPreview.tsx","webpack:///./src/components/file-step/FileStep.tsx","webpack:///./src/components/fields-step/ColumnPreview.tsx","webpack:///./src/components/fields-step/ColumnDragState.tsx","webpack:///./src/components/fields-step/ColumnDragCard.tsx","webpack:///./src/components/fields-step/ColumnDragObject.tsx","webpack:///./src/components/fields-step/ColumnDragSourceArea.tsx","webpack:///./src/components/fields-step/ColumnDragTargetArea.tsx","webpack:///./src/components/fields-step/FieldsStep.tsx","webpack:///./src/components/ProgressDisplay.tsx","webpack:///./src/components/Importer.tsx","webpack:///./src/index.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 19);\n","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","export {};\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport Papa from 'papaparse';\r\nexport const PREVIEW_ROW_COUNT = 5;\r\n// polyfill as implemented in https://github.com/eligrey/Blob.js/blob/master/Blob.js#L653\r\n// (this is for Safari pre v14.1)\r\nfunction streamForBlob(blob) {\r\n    if (blob.stream) {\r\n        return blob.stream();\r\n    }\r\n    const res = new Response(blob);\r\n    if (res.body) {\r\n        return res.body;\r\n    }\r\n    throw new Error('This browser does not support client-side file reads');\r\n}\r\n// incredibly cheap wrapper exposing a subset of stream.Readable interface just for PapaParse usage\r\n// @todo chunk size\r\nfunction nodeStreamWrapper(stream, encoding) {\r\n    let dataHandler = null;\r\n    let endHandler = null;\r\n    let errorHandler = null;\r\n    let isStopped = false;\r\n    let pausePromise = null;\r\n    let pauseResolver = null;\r\n    function runReaderPump() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // ensure this is truly in the next tick after uncorking\r\n            yield Promise.resolve();\r\n            const streamReader = stream.getReader();\r\n            const decoder = new TextDecoder(encoding); // this also strips BOM by default\r\n            try {\r\n                // main reader pump loop\r\n                while (!isStopped) {\r\n                    // perform read from upstream\r\n                    const { done, value } = yield streamReader.read();\r\n                    // wait if we became paused since last data event\r\n                    if (pausePromise) {\r\n                        yield pausePromise;\r\n                    }\r\n                    // check again if stopped and unlistened\r\n                    if (isStopped || !dataHandler || !endHandler) {\r\n                        return;\r\n                    }\r\n                    // final data flush and end notification\r\n                    if (done) {\r\n                        const lastChunkString = decoder.decode(value); // value is empty but pass just in case\r\n                        if (lastChunkString) {\r\n                            dataHandler(lastChunkString);\r\n                        }\r\n                        endHandler(undefined);\r\n                        return;\r\n                    }\r\n                    // otherwise, normal data event after stream-safe decoding\r\n                    const chunkString = decoder.decode(value, { stream: true });\r\n                    dataHandler(chunkString);\r\n                }\r\n            }\r\n            finally {\r\n                // always release the lock\r\n                streamReader.releaseLock();\r\n            }\r\n        });\r\n    }\r\n    const self = {\r\n        // marker properties to make PapaParse think this is a Readable object\r\n        readable: true,\r\n        read() {\r\n            throw new Error('only flowing mode is emulated');\r\n        },\r\n        on(event, callback) {\r\n            switch (event) {\r\n                case 'data':\r\n                    if (dataHandler) {\r\n                        throw new Error('two data handlers not supported');\r\n                    }\r\n                    dataHandler = callback;\r\n                    // flowing state started, run the main pump loop\r\n                    runReaderPump().catch((error) => {\r\n                        if (errorHandler) {\r\n                            errorHandler(error);\r\n                        }\r\n                        else {\r\n                            // rethrow to show error in console\r\n                            throw error;\r\n                        }\r\n                    });\r\n                    return;\r\n                case 'end':\r\n                    if (endHandler) {\r\n                        throw new Error('two end handlers not supported');\r\n                    }\r\n                    endHandler = callback;\r\n                    return;\r\n                case 'error':\r\n                    if (errorHandler) {\r\n                        throw new Error('two error handlers not supported');\r\n                    }\r\n                    errorHandler = callback;\r\n                    return;\r\n            }\r\n            throw new Error('unknown stream shim event: ' + event);\r\n        },\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        removeListener(event, callback) {\r\n            // stop and clear everything for simplicity\r\n            isStopped = true;\r\n            dataHandler = null;\r\n            endHandler = null;\r\n            errorHandler = null;\r\n        },\r\n        pause() {\r\n            if (!pausePromise) {\r\n                pausePromise = new Promise((resolve) => {\r\n                    pauseResolver = resolve;\r\n                });\r\n            }\r\n            return self;\r\n        },\r\n        resume() {\r\n            if (pauseResolver) {\r\n                pauseResolver(); // waiting code will proceed in next tick\r\n                pausePromise = null;\r\n                pauseResolver = null;\r\n            }\r\n            return self;\r\n        }\r\n    };\r\n    // pass ourselves off as a real Node stream\r\n    return self;\r\n}\r\nexport function parsePreview(file, customConfig) {\r\n    // wrap synchronous errors in promise\r\n    return new Promise((resolve) => {\r\n        let firstChunk = null;\r\n        let firstWarning = undefined;\r\n        const rowAccumulator = [];\r\n        function reportSuccess() {\r\n            // PapaParse normally complains first anyway, but might as well flag it\r\n            if (rowAccumulator.length === 0) {\r\n                return {\r\n                    parseError: new Error('File is empty'),\r\n                    file\r\n                };\r\n            }\r\n            // remember whether this file has only one line\r\n            const isSingleLine = rowAccumulator.length === 1;\r\n            // fill preview with blanks if needed\r\n            while (rowAccumulator.length < PREVIEW_ROW_COUNT) {\r\n                rowAccumulator.push([]);\r\n            }\r\n            resolve({\r\n                file,\r\n                parseError: undefined,\r\n                parseWarning: firstWarning || undefined,\r\n                firstChunk: firstChunk || '',\r\n                firstRows: rowAccumulator,\r\n                isSingleLine\r\n            });\r\n        }\r\n        // use our own multibyte-safe streamer, bail after first chunk\r\n        // (this used to add skipEmptyLines but that was hiding possible parse errors)\r\n        // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\r\n        const nodeStream = nodeStreamWrapper(streamForBlob(file), customConfig.encoding || 'utf-8');\r\n        Papa.parse(nodeStream, Object.assign(Object.assign({}, customConfig), { chunkSize: 10000, preview: PREVIEW_ROW_COUNT, error: (error) => {\r\n                resolve({\r\n                    parseError: error,\r\n                    file\r\n                });\r\n            }, beforeFirstChunk: (chunk) => {\r\n                firstChunk = chunk;\r\n            }, chunk: ({ data, errors }, parser) => {\r\n                data.forEach((row) => {\r\n                    const stringRow = row.map((item) => typeof item === 'string' ? item : '');\r\n                    rowAccumulator.push(stringRow);\r\n                });\r\n                if (errors.length > 0 && !firstWarning) {\r\n                    firstWarning = errors[0];\r\n                }\r\n                // finish parsing once we got enough data, otherwise try for more\r\n                // (in some cases PapaParse flushes out last line as separate chunk)\r\n                if (rowAccumulator.length >= PREVIEW_ROW_COUNT) {\r\n                    nodeStream.pause(); // parser does not pause source stream, do it here explicitly\r\n                    parser.abort();\r\n                    reportSuccess();\r\n                }\r\n            }, complete: reportSuccess }));\r\n    }).catch((error) => {\r\n        return {\r\n            parseError: error,\r\n            file\r\n        };\r\n    });\r\n}\r\nexport function processFile(input, reportProgress, callback) {\r\n    const { file, hasHeaders, papaParseConfig, fieldAssignments } = input;\r\n    const fieldNames = Object.keys(fieldAssignments);\r\n    // wrap synchronous errors in promise\r\n    return new Promise((resolve, reject) => {\r\n        // skip first line if needed\r\n        let skipLine = hasHeaders;\r\n        let processedCount = 0;\r\n        // use our own multibyte-safe decoding streamer\r\n        // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\r\n        const nodeStream = nodeStreamWrapper(streamForBlob(file), papaParseConfig.encoding || 'utf-8');\r\n        Papa.parse(nodeStream, Object.assign(Object.assign({}, papaParseConfig), { chunkSize: papaParseConfig.chunkSize || 10000, error: (error) => {\r\n                reject(error);\r\n            }, chunk: ({ data }, parser) => {\r\n                // pause to wait until the rows are consumed\r\n                nodeStream.pause(); // parser does not pause source stream, do it here explicitly\r\n                parser.pause();\r\n                const skipped = skipLine && data.length > 0;\r\n                const rows = (skipped ? data.slice(1) : data).map((row) => {\r\n                    const stringRow = row.map((item) => typeof item === 'string' ? item : '');\r\n                    const record = {};\r\n                    fieldNames.forEach((fieldName) => {\r\n                        const columnIndex = fieldAssignments[fieldName];\r\n                        if (columnIndex !== undefined) {\r\n                            record[fieldName] = stringRow[columnIndex];\r\n                        }\r\n                    });\r\n                    return record; // @todo look into a more precise setup\r\n                });\r\n                // clear line skip flag if there was anything to skip\r\n                if (skipped) {\r\n                    skipLine = false;\r\n                }\r\n                // info snapshot for processing callback\r\n                const info = {\r\n                    startIndex: processedCount\r\n                };\r\n                processedCount += rows.length;\r\n                // @todo collect errors\r\n                reportProgress(rows.length);\r\n                // wrap sync errors in promise\r\n                // (avoid invoking callback if there are no rows to consume)\r\n                const whenConsumed = new Promise((resolve) => {\r\n                    const result = rows.length ? callback(rows, info) : undefined;\r\n                    // introduce delay to allow a frame render\r\n                    setTimeout(() => resolve(result), 0);\r\n                });\r\n                // unpause parsing when done\r\n                whenConsumed.then(() => {\r\n                    nodeStream.resume();\r\n                    parser.resume();\r\n                }, () => {\r\n                    // @todo collect errors\r\n                    nodeStream.resume();\r\n                    parser.resume();\r\n                });\r\n            }, complete: () => {\r\n                resolve();\r\n            } }));\r\n    });\r\n}\r\n","import React from 'react';\r\nimport './TextButton.scss';\r\nexport const TextButton = ({ disabled, onClick, children }) => {\r\n    return (React.createElement(\"button\", { className: \"CSVImporter_TextButton\", disabled: disabled, onClick: onClick }, children));\r\n};\r\n","import React from 'react';\r\nimport './IconButton.scss';\r\nexport const IconButton = ({ type, label, small, focusOnly, disabled, onClick }) => {\r\n    return (React.createElement(\"button\", { className: \"CSVImporter_IconButton\", \"aria-label\": label, disabled: disabled, onClick: onClick, \"data-small\": !!small, \"data-focus-only\": !!focusOnly },\r\n        React.createElement(\"span\", { \"data-type\": type })));\r\n};\r\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\r\nexport const enUS = {\r\n    general: {\r\n        goToPreviousStepTooltip: 'Go to previous step'\r\n    },\r\n    fileStep: {\r\n        initialDragDropPrompt: 'Drag-and-drop CSV file here, or click to select in folder',\r\n        activeDragDropPrompt: 'Drop CSV file here...',\r\n        getImportError: (message) => `Import error: ${message}`,\r\n        getDataFormatError: (message) => `Please check data formatting: ${message}`,\r\n        goBackButton: 'Go Back',\r\n        nextButton: 'Choose columns',\r\n        rawFileContentsHeading: 'Raw File Contents',\r\n        previewImportHeading: 'Preview Import',\r\n        dataHasHeadersCheckbox: 'Data has headers',\r\n        previewLoadingStatus: 'Loading preview...'\r\n    },\r\n    fieldsStep: {\r\n        stepSubtitle: 'Select Columns',\r\n        requiredFieldsError: 'Please assign all required fields',\r\n        nextButton: 'Import',\r\n        dragSourceAreaCaption: 'Columns to import',\r\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Page ${currentPage} of ${pageCount}`,\r\n        getDragSourceActiveStatus: (columnCode) => `Assigning column ${columnCode}`,\r\n        nextColumnsTooltip: 'Show next columns',\r\n        previousColumnsTooltip: 'Show previous columns',\r\n        clearAssignmentTooltip: 'Clear column assignment',\r\n        selectColumnTooltip: 'Select column for assignment',\r\n        unselectColumnTooltip: 'Unselect column',\r\n        dragTargetAreaCaption: 'Target fields',\r\n        getDragTargetOptionalCaption: (field) => `${field} (optional)`,\r\n        getDragTargetRequiredCaption: (field) => `${field} (required)`,\r\n        dragTargetPlaceholder: 'Drag column here',\r\n        getDragTargetAssignTooltip: (columnCode) => `Assign column ${columnCode}`,\r\n        dragTargetClearTooltip: 'Clear column assignment',\r\n        columnCardDummyHeader: 'Unassigned field',\r\n        getColumnCardHeader: (code) => `Column ${code}`\r\n    },\r\n    progressStep: {\r\n        stepSubtitle: 'Import',\r\n        uploadMoreButton: 'Upload More',\r\n        finishButton: 'Finish',\r\n        statusError: 'Could not import',\r\n        statusComplete: 'Complete',\r\n        statusPending: 'Importing...',\r\n        processedRowsLabel: 'Processed rows:'\r\n    }\r\n};\r\nexport const deDE = {\r\n    general: {\r\n        goToPreviousStepTooltip: 'Zum vorherigen Schritt'\r\n    },\r\n    fileStep: {\r\n        initialDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen, oder klicken um eine Datei auszuwählen',\r\n        activeDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen...',\r\n        nextButton: 'Spalten auswählen',\r\n        getImportError: (message) => `Fehler beim Import: ${message}`,\r\n        getDataFormatError: (message) => `Bitte Datenformat überprüfen: ${message}`,\r\n        goBackButton: 'Zurück',\r\n        rawFileContentsHeading: 'Originaler Datei-Inhalt',\r\n        previewImportHeading: 'Import-Vorschau',\r\n        dataHasHeadersCheckbox: 'Mit Kopfzeile',\r\n        previewLoadingStatus: 'Vorschau wird geladen...'\r\n    },\r\n    fieldsStep: {\r\n        stepSubtitle: 'Spalten auswählen',\r\n        requiredFieldsError: 'Bitte weise allen nicht optionalen Spalten einen Wert zu',\r\n        nextButton: 'Importieren',\r\n        dragSourceAreaCaption: 'Zu importierende Spalte',\r\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Seite ${currentPage} von ${pageCount}`,\r\n        getDragSourceActiveStatus: (columnCode) => `Spalte ${columnCode} zuweisen`,\r\n        nextColumnsTooltip: 'Nächste Spalten anzeigen',\r\n        previousColumnsTooltip: 'Vorherige Spalten anzeigen',\r\n        clearAssignmentTooltip: 'Zugewiesene Spalte entfernen',\r\n        selectColumnTooltip: 'Spalte zum Zuweisen auswählen',\r\n        unselectColumnTooltip: 'Spalte abwählen',\r\n        dragTargetAreaCaption: 'Zielfelder',\r\n        getDragTargetOptionalCaption: (field) => `${field} (optional)`,\r\n        getDragTargetRequiredCaption: (field) => `${field} (erforderlich)`,\r\n        dragTargetPlaceholder: 'Spalte hierher ziehen',\r\n        getDragTargetAssignTooltip: (columnCode) => `Spalte ${columnCode} zuweisen`,\r\n        dragTargetClearTooltip: 'Zugewiesene Spalte entfernen',\r\n        columnCardDummyHeader: 'Nicht zugewiesenes Feld',\r\n        getColumnCardHeader: (code) => `Spalte ${code}`\r\n    },\r\n    progressStep: {\r\n        stepSubtitle: 'Importieren',\r\n        uploadMoreButton: 'Weitere hochladen',\r\n        finishButton: 'Abschließen',\r\n        statusError: 'Konnte nicht importiert werden',\r\n        statusComplete: 'Fertig',\r\n        statusPending: 'Wird importiert...',\r\n        processedRowsLabel: 'Verarbeitete Zeilen:'\r\n    }\r\n};\r\n","import React from 'react';\r\nimport { enUS } from '.';\r\nimport { useContext } from 'react';\r\nexport const LocaleContext = React.createContext(enUS);\r\nexport function useLocale(namespace) {\r\n    const locale = useContext(LocaleContext);\r\n    return locale[namespace]; // not using memo for basic property getter\r\n}\r\n","import React, { useRef, useEffect } from 'react';\r\nimport { TextButton } from './TextButton';\r\nimport { IconButton } from './IconButton';\r\nimport './ImporterFrame.scss';\r\nimport { useLocale } from '../locale/LocaleContext';\r\nexport const ImporterFrame = ({ fileName, subtitle, secondaryDisabled, secondaryLabel, nextDisabled, nextLabel, error, onSecondary, onNext, onCancel, children }) => {\r\n    const titleRef = useRef(null);\r\n    const subtitleRef = useRef(null);\r\n    useEffect(() => {\r\n        if (subtitleRef.current) {\r\n            subtitleRef.current.focus();\r\n        }\r\n        else if (titleRef.current) {\r\n            titleRef.current.focus();\r\n        }\r\n    }, []);\r\n    const l10n = useLocale('general');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame\" },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__header\" },\r\n            React.createElement(IconButton, { label: l10n.goToPreviousStepTooltip, type: \"arrowBack\", disabled: !onCancel, onClick: onCancel }),\r\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerTitle\", tabIndex: -1, ref: titleRef }, fileName),\r\n            subtitle ? (React.createElement(React.Fragment, null,\r\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerCrumbSeparator\" },\r\n                    React.createElement(\"span\", null)),\r\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerSubtitle\", tabIndex: -1, ref: subtitleRef }, subtitle))) : null),\r\n        children,\r\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footer\" },\r\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerFill\" }),\r\n            error ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerError\", role: \"status\" }, error)) : null,\r\n            secondaryLabel ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerSecondary\" },\r\n                React.createElement(TextButton, { disabled: !!secondaryDisabled, onClick: onSecondary }, secondaryLabel))) : null,\r\n            nextLabel !== false ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerNext\" },\r\n                React.createElement(TextButton, { disabled: !!nextDisabled, onClick: onNext }, nextLabel))) : null)));\r\n};\r\n","import React, { useCallback, useRef } from 'react';\r\nimport { useDropzone } from 'react-dropzone';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nimport './FileSelector.scss';\r\nexport const FileSelector = ({ onSelected }) => {\r\n    const onSelectedRef = useRef(onSelected);\r\n    onSelectedRef.current = onSelected;\r\n    const dropHandler = useCallback((acceptedFiles) => {\r\n        // silently ignore if nothing to do\r\n        if (acceptedFiles.length < 1) {\r\n            return;\r\n        }\r\n        const file = acceptedFiles[0];\r\n        onSelectedRef.current(file);\r\n    }, []);\r\n    const { getRootProps, getInputProps, isDragActive } = useDropzone({\r\n        onDrop: dropHandler\r\n    });\r\n    const l10n = useLocale('fileStep');\r\n    return (React.createElement(\"div\", Object.assign({ className: \"CSVImporter_FileSelector\", \"data-active\": !!isDragActive }, getRootProps()),\r\n        React.createElement(\"input\", Object.assign({}, getInputProps())),\r\n        isDragActive ? (React.createElement(\"span\", null, l10n.activeDragDropPrompt)) : (React.createElement(\"span\", null, l10n.initialDragDropPrompt))));\r\n};\r\n","import React from 'react';\r\nimport { TextButton } from '../TextButton';\r\nimport './FormatErrorMessage.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nexport const FormatErrorMessage = React.memo(({ onCancelClick, children }) => {\r\n    const l10n = useLocale('fileStep');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatErrorMessage\" },\r\n        React.createElement(\"span\", null, children),\r\n        React.createElement(TextButton, { onClick: onCancelClick }, l10n.goBackButton)));\r\n});\r\n","import React from 'react';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nimport { FormatErrorMessage } from './FormatErrorMessage';\r\nimport './FormatRawPreview.scss';\r\nconst RAW_PREVIEW_SIZE = 500;\r\nexport const FormatRawPreview = React.memo(({ chunk, warning, onCancelClick }) => {\r\n    const chunkSlice = chunk.slice(0, RAW_PREVIEW_SIZE);\r\n    const chunkHasMore = chunk.length > RAW_PREVIEW_SIZE;\r\n    const l10n = useLocale('fileStep');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview\" },\r\n        React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview__scroll\" },\r\n            React.createElement(\"pre\", { className: \"CSVImporter_FormatRawPreview__pre\" },\r\n                chunkSlice,\r\n                chunkHasMore && React.createElement(\"aside\", null, \"...\"))),\r\n        warning ? (React.createElement(FormatErrorMessage, { onCancelClick: onCancelClick }, l10n.getDataFormatError(warning.message || String(warning)))) : null));\r\n});\r\n","import React from 'react';\r\nimport './FormatDataRowPreview.scss';\r\nexport const FormatDataRowPreview = React.memo(({ hasHeaders, rows }) => {\r\n    const headerRow = hasHeaders ? rows[0] : null;\r\n    const bodyRows = hasHeaders ? rows.slice(1) : rows;\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatDataRowPreview\" },\r\n        React.createElement(\"table\", { className: \"CSVImporter_FormatDataRowPreview__table\" },\r\n            headerRow && (React.createElement(\"thead\", null,\r\n                React.createElement(\"tr\", null, headerRow.map((item, itemIndex) => (React.createElement(\"th\", { key: itemIndex }, item)))))),\r\n            React.createElement(\"tbody\", null, bodyRows.map((row, rowIndex) => (React.createElement(\"tr\", { key: rowIndex }, row.map((item, itemIndex) => (React.createElement(\"td\", { key: itemIndex }, item))))))))));\r\n});\r\n","import React, { useMemo, useRef, useEffect, useState } from 'react';\r\nimport { parsePreview } from '../../parser';\r\nimport { ImporterFrame } from '../ImporterFrame';\r\nimport { FileSelector } from './FileSelector';\r\nimport { FormatRawPreview } from './FormatRawPreview';\r\nimport { FormatDataRowPreview } from './FormatDataRowPreview';\r\nimport { FormatErrorMessage } from './FormatErrorMessage';\r\nimport './FileStep.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nexport const FileStep = ({ customConfig, assumeNoHeaders, prevState, onChange, onAccept }) => {\r\n    // seed from previous state as needed\r\n    const [selectedFile, setSelectedFile] = useState(prevState ? prevState.file : null);\r\n    const [preview, setPreview] = useState(() => prevState && Object.assign({ parseError: undefined }, prevState));\r\n    const [papaParseConfig, setPapaParseConfig] = useState(prevState ? prevState.papaParseConfig : customConfig);\r\n    const [hasHeaders, setHasHeaders] = useState(prevState ? prevState.hasHeaders : false);\r\n    // wrap in ref to avoid triggering effect\r\n    const customConfigRef = useRef(customConfig);\r\n    customConfigRef.current = customConfig;\r\n    const assumeNoHeadersRef = useRef(assumeNoHeaders);\r\n    assumeNoHeadersRef.current = assumeNoHeaders;\r\n    const onChangeRef = useRef(onChange);\r\n    onChangeRef.current = onChange;\r\n    // notify of current state\r\n    useEffect(() => {\r\n        onChangeRef.current(preview && !preview.parseError\r\n            ? Object.assign(Object.assign({}, preview), { papaParseConfig, hasHeaders }) : null);\r\n    }, [preview, papaParseConfig, hasHeaders]);\r\n    // perform async preview parse once for the given file\r\n    const asyncLockRef = useRef(0);\r\n    useEffect(() => {\r\n        // clear other state when file selector is reset\r\n        if (!selectedFile) {\r\n            setPreview(null);\r\n            return;\r\n        }\r\n        // preserve existing state when parsing for this file is already complete\r\n        if (preview && preview.file === selectedFile) {\r\n            return;\r\n        }\r\n        const oplock = asyncLockRef.current;\r\n        // lock in the current PapaParse config instance for use in multiple spots\r\n        const config = customConfigRef.current;\r\n        // kick off the preview parse\r\n        parsePreview(selectedFile, config).then((results) => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return;\r\n            }\r\n            // save the results and the original config\r\n            setPreview(results);\r\n            setPapaParseConfig(config);\r\n            // pre-fill headers flag (only possible with >1 lines)\r\n            setHasHeaders(results.parseError\r\n                ? false\r\n                : !assumeNoHeadersRef.current && !results.isSingleLine);\r\n        });\r\n        return () => {\r\n            // invalidate current oplock on change or unmount\r\n            asyncLockRef.current += 1;\r\n        };\r\n    }, [selectedFile, preview]);\r\n    const l10n = useLocale('fileStep');\r\n    // clear selected file\r\n    // preview result content to display\r\n    const reportBlock = useMemo(() => {\r\n        if (!preview) {\r\n            return null;\r\n        }\r\n        if (preview.parseError) {\r\n            return (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainResultBlock\" },\r\n                React.createElement(FormatErrorMessage, { onCancelClick: () => setSelectedFile(null) }, l10n.getImportError(preview.parseError.message || String(preview.parseError)))));\r\n        }\r\n        return (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainResultBlock\" },\r\n            React.createElement(\"div\", { className: \"CSVImporter_FileStep__header\" }, l10n.rawFileContentsHeading),\r\n            React.createElement(FormatRawPreview, { chunk: preview.firstChunk, warning: preview.parseWarning, onCancelClick: () => setSelectedFile(null) }),\r\n            preview.parseWarning ? null : (React.createElement(React.Fragment, null,\r\n                React.createElement(\"div\", { className: \"CSVImporter_FileStep__header\" },\r\n                    l10n.previewImportHeading,\r\n                    !preview.isSingleLine && ( // hide setting if only one line anyway\r\n                    React.createElement(\"label\", { className: \"CSVImporter_FileStep__headerToggle\" },\r\n                        React.createElement(\"input\", { type: \"checkbox\", checked: hasHeaders, onChange: () => {\r\n                                setHasHeaders((prev) => !prev);\r\n                            } }),\r\n                        React.createElement(\"span\", null, l10n.dataHasHeadersCheckbox)))),\r\n                React.createElement(FormatDataRowPreview, { hasHeaders: hasHeaders, rows: preview.firstRows })))));\r\n    }, [preview, hasHeaders, l10n]);\r\n    if (!selectedFile) {\r\n        return React.createElement(FileSelector, { onSelected: (file) => setSelectedFile(file) });\r\n    }\r\n    return (React.createElement(ImporterFrame, { fileName: selectedFile.name, nextDisabled: !preview || !!preview.parseError || !!preview.parseWarning, onNext: () => {\r\n            if (!preview || preview.parseError) {\r\n                throw new Error('unexpected missing preview info');\r\n            }\r\n            onAccept();\r\n        }, onCancel: () => setSelectedFile(null), nextLabel: l10n.nextButton }, reportBlock || (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainPendingBlock\" }, l10n.previewLoadingStatus))));\r\n};\r\n","// spreadsheet-style column code computation (A, B, ..., Z, AA, AB, ..., etc)\r\nexport function generateColumnCode(value) {\r\n    // ignore dummy index\r\n    if (value < 0) {\r\n        return '';\r\n    }\r\n    // first, determine how many base-26 letters there should be\r\n    // (because the notation is not purely positional)\r\n    let digitCount = 1;\r\n    let base = 0;\r\n    let next = 26;\r\n    while (next <= value) {\r\n        digitCount += 1;\r\n        base = next;\r\n        next = next * 26 + 26;\r\n    }\r\n    // then, apply normal positional digit computation on remainder above base\r\n    let remainder = value - base;\r\n    const digits = [];\r\n    while (digits.length < digitCount) {\r\n        const lastDigit = remainder % 26;\r\n        remainder = Math.floor((remainder - lastDigit) / 26); // applying floor just in case\r\n        // store ASCII code, with A as 0\r\n        digits.unshift(65 + lastDigit);\r\n    }\r\n    return String.fromCharCode.apply(null, digits);\r\n}\r\n// prepare spreadsheet-like column display information for given raw data preview\r\nexport function generatePreviewColumns(firstRows, hasHeaders) {\r\n    const columnStubs = [...new Array(firstRows[0].length)];\r\n    return columnStubs.map((empty, index) => {\r\n        const values = firstRows.map((row) => row[index] || '');\r\n        const headerValue = hasHeaders ? values.shift() : undefined;\r\n        return {\r\n            index,\r\n            header: headerValue,\r\n            values\r\n        };\r\n    });\r\n}\r\n","import { useState, useCallback, useEffect, useRef } from 'react';\r\nimport { useDrag } from 'react-use-gesture';\r\nexport function useColumnDragState(fields, initialAssignments, onTouched) {\r\n    // wrap in ref to avoid re-triggering\r\n    const onTouchedRef = useRef(onTouched);\r\n    onTouchedRef.current = onTouched;\r\n    const [dragState, setDragState] = useState(null);\r\n    const [fieldAssignments, setFieldAssignments] = useState(initialAssignments);\r\n    // make sure there are no extra fields\r\n    useEffect(() => {\r\n        const removedFieldNames = Object.keys(fieldAssignments).filter((existingFieldName) => !fields.some((field) => field.name === existingFieldName));\r\n        if (removedFieldNames.length > 0) {\r\n            // @todo put everything inside this setter\r\n            setFieldAssignments((prev) => {\r\n                const copy = Object.assign({}, prev);\r\n                removedFieldNames.forEach((fieldName) => {\r\n                    delete copy[fieldName];\r\n                });\r\n                return copy;\r\n            });\r\n        }\r\n    }, [fields, fieldAssignments]);\r\n    const internalAssignHandler = useCallback((column, fieldName) => {\r\n        setFieldAssignments((prevAssignments) => {\r\n            const copy = Object.assign({}, prevAssignments);\r\n            // ensure dropped column does not show up elsewhere\r\n            Object.keys(prevAssignments).forEach((name) => {\r\n                if (copy[name] === column.index) {\r\n                    delete copy[name];\r\n                }\r\n            });\r\n            // set new field column\r\n            if (fieldName !== null) {\r\n                copy[fieldName] = column.index;\r\n            }\r\n            return copy;\r\n        });\r\n        // mark for validation display\r\n        if (fieldName) {\r\n            onTouchedRef.current(fieldName);\r\n        }\r\n    }, []);\r\n    const bindDrag = useDrag(({ first, last, event, xy, args }) => {\r\n        if (first && event) {\r\n            // only prevent default inside first event\r\n            // (touchmove uses passive event handler and would trigger warning)\r\n            event.preventDefault();\r\n            const [column, startFieldName] = args;\r\n            setDragState({\r\n                pointerStartInfo: {\r\n                    initialXY: xy,\r\n                    initialWidth: event.currentTarget instanceof HTMLElement\r\n                        ? event.currentTarget.offsetWidth\r\n                        : 0\r\n                },\r\n                column,\r\n                dropFieldName: startFieldName !== undefined ? startFieldName : null,\r\n                updateListeners: {}\r\n            });\r\n        }\r\n        else if (last) {\r\n            setDragState(null);\r\n            if (dragState) {\r\n                internalAssignHandler(dragState.column, dragState.dropFieldName);\r\n            }\r\n        }\r\n        // @todo figure out a cleaner event stream solution\r\n        if (dragState) {\r\n            const listeners = dragState.updateListeners;\r\n            for (const key of Object.keys(listeners)) {\r\n                listeners[key](xy);\r\n            }\r\n        }\r\n    }, {});\r\n    // when dragging, set root-level user-select:none to prevent text selection, see Importer.scss\r\n    // (done via class toggle to avoid interfering with any other dynamic style changes)\r\n    useEffect(() => {\r\n        if (dragState) {\r\n            document.body.classList.add('CSVImporter_dragging');\r\n        }\r\n        else {\r\n            // remove text selection prevention after a delay (otherwise on iOS it still selects something)\r\n            const timeoutId = setTimeout(() => {\r\n                document.body.classList.remove('CSVImporter_dragging');\r\n            }, 200);\r\n            return () => {\r\n                // if another drag state comes along then cancel our delay and just clean up class right away\r\n                clearTimeout(timeoutId);\r\n                document.body.classList.remove('CSVImporter_dragging');\r\n            };\r\n        }\r\n    }, [dragState]);\r\n    const columnSelectHandler = useCallback((column) => {\r\n        setDragState((prev) => {\r\n            // toggle off if needed\r\n            if (prev && prev.column === column) {\r\n                return null;\r\n            }\r\n            return {\r\n                pointerStartInfo: null,\r\n                column,\r\n                dropFieldName: null,\r\n                updateListeners: {}\r\n            };\r\n        });\r\n    }, []);\r\n    const dragHoverHandler = useCallback((fieldName, isOn) => {\r\n        setDragState((prev) => {\r\n            if (!prev) {\r\n                return prev;\r\n            }\r\n            if (isOn) {\r\n                // set the new drop target\r\n                return Object.assign(Object.assign({}, prev), { dropFieldName: fieldName });\r\n            }\r\n            else if (prev.dropFieldName === fieldName) {\r\n                // clear drop target if we are still the current one\r\n                return Object.assign(Object.assign({}, prev), { dropFieldName: null });\r\n            }\r\n            // no changes by default\r\n            return prev;\r\n        });\r\n    }, []);\r\n    const assignHandler = useCallback((fieldName) => {\r\n        // clear active drag state\r\n        setDragState(null);\r\n        if (dragState) {\r\n            internalAssignHandler(dragState.column, fieldName);\r\n        }\r\n    }, [internalAssignHandler, dragState]);\r\n    const unassignHandler = useCallback((column) => {\r\n        setFieldAssignments((prev) => {\r\n            const assignedFieldName = Object.keys(prev).find((fieldName) => prev[fieldName] === column.index);\r\n            if (assignedFieldName === undefined) {\r\n                return prev;\r\n            }\r\n            const copy = Object.assign({}, prev);\r\n            delete copy[assignedFieldName];\r\n            return copy;\r\n        });\r\n    }, []);\r\n    return {\r\n        fieldAssignments,\r\n        dragState,\r\n        dragEventBinder: bindDrag,\r\n        dragHoverHandler,\r\n        columnSelectHandler,\r\n        assignHandler,\r\n        unassignHandler\r\n    };\r\n}\r\n","import React, { useMemo } from 'react';\r\nimport { PREVIEW_ROW_COUNT } from '../../parser';\r\nimport './ColumnDragCard.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\n// @todo sort out \"grabbing\" cursor state (does not work with pointer-events:none)\r\nexport const ColumnDragCard = ({ hasHeaders, column: optionalColumn, rowCount = PREVIEW_ROW_COUNT, hasError, isAssigned, isShadow, isDraggable, isDragged, isDropIndicator }) => {\r\n    const isDummy = !optionalColumn;\r\n    const column = useMemo(() => optionalColumn || {\r\n        index: -1,\r\n        code: '',\r\n        header: hasHeaders ? '' : undefined,\r\n        values: [...new Array(PREVIEW_ROW_COUNT)].map(() => '')\r\n    }, [optionalColumn, hasHeaders]);\r\n    const headerValue = column.header;\r\n    const dataValues = column.values.slice(0, headerValue === undefined ? rowCount : rowCount - 1);\r\n    const l10n = useLocale('fieldsStep');\r\n    return (\r\n    // not changing variant dynamically because it causes a height jump\r\n    React.createElement(\"div\", { key: isDummy || isShadow ? 1 : isDropIndicator ? 2 : 0, className: \"CSVImporter_ColumnDragCard\", \"data-dummy\": !!isDummy, \"data-error\": !!hasError, \"data-shadow\": !!isShadow, \"data-draggable\": !!isDraggable, \"data-dragged\": !!isDragged, \"data-drop-indicator\": !!isDropIndicator },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardHeader\" },\r\n            isDummy ? (React.createElement(\"var\", { role: \"text\" }, l10n.columnCardDummyHeader)) : (React.createElement(\"var\", { role: \"text\" }, l10n.getColumnCardHeader(column.code))),\r\n            isDummy || isAssigned ? '\\u00a0' : React.createElement(\"b\", { \"aria-hidden\": true }, column.code)),\r\n        headerValue !== undefined ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardValue\", \"data-header\": true }, headerValue || '\\u00a0')) : null,\r\n        React.createElement(\"div\", { role: \"text\" }, dataValues.map((value, valueIndex) => (React.createElement(\"div\", { key: valueIndex, className: \"CSVImporter_ColumnDragCard__cardValue\" }, value || '\\u00a0'))))));\r\n};\r\n","import React, { useRef, useLayoutEffect } from 'react';\r\nimport { createPortal } from 'react-dom';\r\nimport { ColumnDragCard } from './ColumnDragCard';\r\nimport './ColumnDragObject.scss';\r\nexport const ColumnDragObject = ({ dragState }) => {\r\n    const referenceBoxRef = useRef(null);\r\n    // @todo wrap in a no-events overlay to clip against screen edges\r\n    const dragBoxRef = useRef(null);\r\n    const dragObjectPortal = dragState && dragState.pointerStartInfo\r\n        ? createPortal(React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject\" },\r\n            React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__positioner\", ref: dragBoxRef },\r\n                React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__holder\" },\r\n                    React.createElement(ColumnDragCard, { column: dragState.column, isDragged: true })))), document.body)\r\n        : null;\r\n    // set up initial position\r\n    const pointerStartInfo = dragState && dragState.pointerStartInfo;\r\n    useLayoutEffect(() => {\r\n        if (!pointerStartInfo || !dragBoxRef.current) {\r\n            return;\r\n        }\r\n        const { initialXY, initialWidth } = pointerStartInfo;\r\n        dragBoxRef.current.style.left = `${initialXY[0]}px`;\r\n        dragBoxRef.current.style.top = `${initialXY[1]}px`;\r\n        dragBoxRef.current.style.width = `${initialWidth}px`;\r\n        // copy known font style from main content\r\n        // @todo consider other text style properties?\r\n        if (referenceBoxRef.current) {\r\n            const computedStyle = window.getComputedStyle(referenceBoxRef.current);\r\n            dragBoxRef.current.style.fontFamily = computedStyle.fontFamily;\r\n            dragBoxRef.current.style.fontSize = computedStyle.fontSize;\r\n            dragBoxRef.current.style.fontWeight = computedStyle.fontWeight;\r\n            dragBoxRef.current.style.fontStyle = computedStyle.fontStyle;\r\n            dragBoxRef.current.style.letterSpacing = computedStyle.letterSpacing;\r\n        }\r\n    }, [pointerStartInfo]);\r\n    // subscribe to live position updates without state changes\r\n    useLayoutEffect(() => {\r\n        if (dragState) {\r\n            dragState.updateListeners['dragObj'] = (xy) => {\r\n                if (!dragBoxRef.current) {\r\n                    return;\r\n                }\r\n                dragBoxRef.current.style.left = `${xy[0]}px`;\r\n                dragBoxRef.current.style.top = `${xy[1]}px`;\r\n            };\r\n        }\r\n    }, [dragState]);\r\n    return React.createElement(\"div\", { ref: referenceBoxRef }, dragObjectPortal);\r\n};\r\n","import React, { useState, useMemo } from 'react';\r\nimport { ColumnDragCard } from './ColumnDragCard';\r\nimport { IconButton } from '../IconButton';\r\nimport './ColumnDragSourceArea.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nconst SOURCES_PAGE_SIZE = 5; // fraction of 10 for easier counting\r\n// @todo readable status text if not mouse-drag\r\nconst SourceBox = ({ column, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\r\n    const isDragged = dragState ? column === dragState.column : false;\r\n    const isAssigned = useMemo(() => Object.keys(fieldAssignments).some((fieldName) => fieldAssignments[fieldName] === column.index), [fieldAssignments, column]);\r\n    const eventHandlers = useMemo(() => eventBinder(column), [\r\n        eventBinder,\r\n        column\r\n    ]);\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__box\" },\r\n        React.createElement(\"div\", Object.assign({}, (isAssigned ? {} : eventHandlers)),\r\n            React.createElement(ColumnDragCard, { column: column, isAssigned: isAssigned, isShadow: isDragged || isAssigned, isDraggable: !dragState && !isDragged && !isAssigned })),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__boxAction\" }, isAssigned ? (React.createElement(IconButton, { key: \"clear\" // key-prop helps clear focus on click\r\n            , label: l10n.clearAssignmentTooltip, small: true, type: \"replay\", onClick: () => {\r\n                onUnassign(column);\r\n            } })) : (React.createElement(IconButton, { key: \"dragSelect\" // key-prop helps clear focus on click\r\n            , focusOnly: true, label: dragState && dragState.column === column\r\n                ? l10n.unselectColumnTooltip\r\n                : l10n.selectColumnTooltip, small: true, type: \"back\", onClick: () => {\r\n                onSelect(column);\r\n            } })))));\r\n};\r\n// @todo current page indicator (dots)\r\nexport const ColumnDragSourceArea = ({ columns, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\r\n    const [page, setPage] = useState(0);\r\n    const [pageChanged, setPageChanged] = useState(false);\r\n    const pageCount = Math.ceil(columns.length / SOURCES_PAGE_SIZE);\r\n    const start = page * SOURCES_PAGE_SIZE;\r\n    const pageContents = columns\r\n        .slice(start, start + SOURCES_PAGE_SIZE)\r\n        .map((column, columnIndex) => (React.createElement(SourceBox, { key: columnIndex, column: column, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: eventBinder, onSelect: onSelect, onUnassign: onUnassign })));\r\n    while (pageContents.length < SOURCES_PAGE_SIZE) {\r\n        pageContents.push(React.createElement(\"div\", { key: pageContents.length, className: \"CSVImporter_ColumnDragSourceArea__pageFiller\" }));\r\n    }\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragSourceArea\", \"aria-label\": l10n.dragSourceAreaCaption },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\r\n            React.createElement(IconButton, { label: l10n.previousColumnsTooltip, type: \"back\", disabled: page === 0, onClick: () => {\r\n                    setPage((prev) => Math.max(0, prev - 1));\r\n                    setPageChanged(true);\r\n                } })),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__page\" },\r\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: \"status\" }, l10n.getDragSourceActiveStatus(dragState.column.code))) : (\r\n            // show page number if needed (and treat as status role if it has changed)\r\n            // @todo changing role to status does not seem to work\r\n            pageCount > 1 && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: pageChanged ? 'status' : 'text' }, l10n.getDragSourcePageIndicator(page + 1, pageCount)))),\r\n            pageContents),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\r\n            React.createElement(IconButton, { label: l10n.nextColumnsTooltip, type: \"forward\", disabled: page === pageCount - 1, onClick: () => {\r\n                    setPage((prev) => Math.min(pageCount - 1, prev + 1));\r\n                } }))));\r\n};\r\n","import React, { useMemo, useEffect, useRef } from 'react';\r\nimport { ColumnDragCard } from './ColumnDragCard';\r\nimport { IconButton } from '../IconButton';\r\nimport './ColumnDragTargetArea.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nconst TargetBox = ({ hasHeaders, field, touched, assignedColumn, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\r\n    // wrap in ref to avoid re-triggering effect\r\n    const onHoverRef = useRef(onHover);\r\n    onHoverRef.current = onHover;\r\n    // respond to hover events when there is active mouse drag happening\r\n    // (not keyboard-emulated one)\r\n    const containerRef = useRef(null);\r\n    const isHoveredRef = useRef(false); // simple tracking of current hover state to avoid spamming onHover (not for display)\r\n    useEffect(() => {\r\n        const container = containerRef.current;\r\n        if (!dragState || !dragState.pointerStartInfo || !container) {\r\n            return;\r\n        }\r\n        // measure the current scroll-independent position\r\n        const rect = container.getBoundingClientRect();\r\n        const minX = rect.x;\r\n        const maxX = rect.x + rect.width;\r\n        const minY = rect.y;\r\n        const maxY = rect.y + rect.height;\r\n        // listen for pointer movement (mouse or touch) and detect hover\r\n        const listeners = dragState.updateListeners;\r\n        const listenerName = `field:${field.name}`;\r\n        listeners[listenerName] = (xy) => {\r\n            const isInBounds = xy[0] >= minX && xy[0] < maxX && xy[1] >= minY && xy[1] < maxY;\r\n            if (isInBounds !== isHoveredRef.current) {\r\n                // cannot use local var for isHovered state because the effect re-triggers after this\r\n                isHoveredRef.current = isInBounds;\r\n                onHoverRef.current(field.name, isInBounds);\r\n            }\r\n        };\r\n        // cleanup\r\n        return () => {\r\n            delete listeners[listenerName];\r\n        };\r\n    }, [dragState, field.name]);\r\n    // if this field is the current highlighted drop target,\r\n    // get the originating column data for display\r\n    const sourceColumn = dragState && dragState.dropFieldName === field.name\r\n        ? dragState.column\r\n        : null;\r\n    // see if currently assigned column is being dragged again\r\n    const isReDragged = dragState ? dragState.column === assignedColumn : false;\r\n    // drag start handlers for columns that can be re-dragged (i.e. are assigned)\r\n    const dragStartHandlers = useMemo(() => assignedColumn && !isReDragged\r\n        ? eventBinder(assignedColumn, field.name)\r\n        : {}, [eventBinder, assignedColumn, isReDragged, field.name]);\r\n    const valueContents = useMemo(() => {\r\n        if (sourceColumn) {\r\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: sourceColumn, isDropIndicator: true }));\r\n        }\r\n        if (assignedColumn) {\r\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: assignedColumn, isShadow: isReDragged, isDraggable: !isReDragged }));\r\n        }\r\n        const hasError = touched && !field.isOptional;\r\n        return (React.createElement(ColumnDragCard, { rowCount: 3, hasHeaders: hasHeaders, hasError: hasError }));\r\n    }, [hasHeaders, field, touched, assignedColumn, sourceColumn, isReDragged]);\r\n    const l10n = useLocale('fieldsStep');\r\n    // @todo mouse cursor changes to reflect draggable state\r\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragTargetArea__box\", \"aria-label\": field.isOptional\r\n            ? l10n.getDragTargetOptionalCaption(field.label)\r\n            : l10n.getDragTargetRequiredCaption(field.label), ref: containerRef },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxLabel\", \"aria-hidden\": true },\r\n            field.label,\r\n            field.isOptional ? null : React.createElement(\"b\", null, \"*\")),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValue\" },\r\n            !sourceColumn && !assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxPlaceholderHelp\", \"aria-hidden\": true }, l10n.dragTargetPlaceholder)),\r\n            React.createElement(\"div\", Object.assign({}, dragStartHandlers), valueContents),\r\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\r\n                React.createElement(IconButton, { label: l10n.getDragTargetAssignTooltip(dragState.column.code), small: true, type: \"forward\", onClick: () => onAssign(field.name) }))) : (!sourceColumn &&\r\n                assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\r\n                React.createElement(IconButton, { label: l10n.dragTargetClearTooltip, small: true, type: \"close\", onClick: () => onUnassign(assignedColumn) })))))));\r\n};\r\nexport const ColumnDragTargetArea = ({ hasHeaders, fields, columns, fieldTouched, fieldAssignments, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragTargetArea\", \"aria-label\": l10n.dragTargetAreaCaption }, fields.map((field) => {\r\n        const assignedColumnIndex = fieldAssignments[field.name];\r\n        return (React.createElement(TargetBox, { key: field.name, field: field, touched: fieldTouched[field.name], hasHeaders: hasHeaders, assignedColumn: assignedColumnIndex !== undefined\r\n                ? columns[assignedColumnIndex]\r\n                : null, dragState: dragState, eventBinder: eventBinder, onHover: onHover, onAssign: onAssign, onUnassign: onUnassign }));\r\n    })));\r\n};\r\n","import React, { useState, useMemo, useEffect, useRef } from 'react';\r\nimport { ImporterFrame } from '../ImporterFrame';\r\nimport { generatePreviewColumns, generateColumnCode } from './ColumnPreview';\r\nimport { useColumnDragState } from './ColumnDragState';\r\nimport { ColumnDragObject } from './ColumnDragObject';\r\nimport { ColumnDragSourceArea } from './ColumnDragSourceArea';\r\nimport { ColumnDragTargetArea } from './ColumnDragTargetArea';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nexport const FieldsStep = ({ fileState, fields, prevState, onChange, onAccept, onCancel }) => {\r\n    const onChangeRef = useRef(onChange);\r\n    onChangeRef.current = onChange;\r\n    const columns = useMemo(() => generatePreviewColumns(fileState.firstRows, fileState.hasHeaders).map((item) => (Object.assign(Object.assign({}, item), { code: generateColumnCode(item.index) }))), [fileState]);\r\n    const initialAssignments = useMemo(() => {\r\n        // prep insensitive/fuzzy match stems for known columns\r\n        // (this is ignored if there is already previous state to seed from)\r\n        const columnStems = columns.map((column) => {\r\n            const trimmed = column.header && column.header.trim();\r\n            if (!trimmed) {\r\n                return undefined;\r\n            }\r\n            return trimmed.toLowerCase();\r\n        });\r\n        // pre-assign corresponding fields\r\n        const result = {};\r\n        const assignedColumnIndexes = [];\r\n        fields.forEach((field) => {\r\n            // find by field stem\r\n            const fieldLabelStem = field.label.trim().toLowerCase(); // @todo consider normalizing other whitespace/non-letters\r\n            const matchingColumnIndex = columnStems.findIndex((columnStem, columnIndex) => {\r\n                // no headers or no meaningful stem value\r\n                if (columnStem === undefined) {\r\n                    return false;\r\n                }\r\n                // always check against assigning twice\r\n                if (assignedColumnIndexes[columnIndex]) {\r\n                    return false;\r\n                }\r\n                return columnStem === fieldLabelStem;\r\n            });\r\n            // assign if found\r\n            if (matchingColumnIndex !== -1) {\r\n                assignedColumnIndexes[matchingColumnIndex] = true;\r\n                result[field.name] = matchingColumnIndex;\r\n            }\r\n        });\r\n        return result;\r\n    }, [fields, columns]);\r\n    // track which fields need to show validation warning\r\n    const [fieldTouched, setFieldTouched] = useState({});\r\n    const [validationError, setValidationError] = useState(null);\r\n    const { fieldAssignments, dragState, dragEventBinder, dragHoverHandler, columnSelectHandler, assignHandler, unassignHandler } = useColumnDragState(fields, prevState ? prevState.fieldAssignments : initialAssignments, (fieldName) => {\r\n        setFieldTouched((prev) => {\r\n            if (prev[fieldName]) {\r\n                return prev;\r\n            }\r\n            const copy = Object.assign({}, prev);\r\n            copy[fieldName] = true;\r\n            return copy;\r\n        });\r\n    });\r\n    // notify of current state\r\n    useEffect(() => {\r\n        onChangeRef.current({ fieldAssignments: Object.assign({}, fieldAssignments) });\r\n    }, [fieldAssignments]);\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(ImporterFrame, { fileName: fileState.file.name, subtitle: l10n.stepSubtitle, error: validationError, onCancel: onCancel, onNext: () => {\r\n            // mark all fields as touched\r\n            const fullTouchedMap = {};\r\n            fields.some((field) => {\r\n                fullTouchedMap[field.name] = true;\r\n            });\r\n            setFieldTouched(fullTouchedMap);\r\n            // submit if validation succeeds\r\n            const hasUnassignedRequired = fields.some((field) => !field.isOptional && fieldAssignments[field.name] === undefined);\r\n            if (!hasUnassignedRequired) {\r\n                onAccept();\r\n            }\r\n            else {\r\n                setValidationError(l10n.requiredFieldsError);\r\n            }\r\n        }, nextLabel: l10n.nextButton },\r\n        React.createElement(ColumnDragSourceArea, { columns: columns, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: dragEventBinder, onSelect: columnSelectHandler, onUnassign: unassignHandler }),\r\n        React.createElement(ColumnDragTargetArea, { hasHeaders: fileState.hasHeaders, fields: fields, columns: columns, fieldTouched: fieldTouched, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: dragEventBinder, onHover: dragHoverHandler, onAssign: assignHandler, onUnassign: unassignHandler }),\r\n        React.createElement(ColumnDragObject, { dragState: dragState })));\r\n};\r\n","import React, { useState, useEffect, useMemo, useRef } from 'react';\r\nimport { processFile } from '../parser';\r\nimport { ImporterFrame } from './ImporterFrame';\r\nimport './ProgressDisplay.scss';\r\nimport { useLocale } from '../locale/LocaleContext';\r\n// compute actual UTF-8 bytes used by a string\r\n// (inspired by https://stackoverflow.com/questions/10576905/how-to-convert-javascript-unicode-notation-code-to-utf-8)\r\nfunction countUTF8Bytes(item) {\r\n    // re-encode into UTF-8\r\n    const escaped = encodeURIComponent(item);\r\n    // convert byte escape sequences into single characters\r\n    const normalized = escaped.replace(/%\\d\\d/g, '_');\r\n    return normalized.length;\r\n}\r\nexport function ProgressDisplay({ fileState, fieldsState, externalPreview, processChunk, onStart, onComplete, onRestart, onClose }) {\r\n    const [progressCount, setProgressCount] = useState(0);\r\n    const [isComplete, setIsComplete] = useState(false);\r\n    const [error, setError] = useState(null);\r\n    const [isDismissed, setIsDismissed] = useState(false); // prevents double-clicking finish\r\n    // info object exposed to the progress callbacks\r\n    const importInfo = useMemo(() => {\r\n        const fieldList = Object.keys(fieldsState.fieldAssignments);\r\n        const columnSparseList = [];\r\n        fieldList.forEach((field) => {\r\n            const col = fieldsState.fieldAssignments[field];\r\n            if (col !== undefined) {\r\n                columnSparseList[col] = field;\r\n            }\r\n        });\r\n        return {\r\n            file: fileState.file,\r\n            preview: externalPreview,\r\n            fields: fieldList,\r\n            columnFields: [...columnSparseList]\r\n        };\r\n    }, [fileState, fieldsState, externalPreview]);\r\n    // estimate number of rows\r\n    const estimatedRowCount = useMemo(() => {\r\n        // sum up sizes of all the parsed preview rows and get estimated average\r\n        const totalPreviewRowBytes = fileState.firstRows.reduce((prevCount, row) => {\r\n            const rowBytes = row.reduce((prev, item) => {\r\n                return prev + countUTF8Bytes(item) + 1; // add a byte for separator or newline\r\n            }, 0);\r\n            return prevCount + rowBytes;\r\n        }, 0);\r\n        const averagePreviewRowSize = totalPreviewRowBytes / fileState.firstRows.length;\r\n        // divide file size by estimated row size (or fall back to a sensible amount)\r\n        return averagePreviewRowSize > 1\r\n            ? fileState.file.size / averagePreviewRowSize\r\n            : 100;\r\n    }, [fileState]);\r\n    // notify on start of processing\r\n    // (separate effect in case of errors)\r\n    const onStartRef = useRef(onStart); // wrap in ref to avoid re-triggering (only first instance is needed)\r\n    useEffect(() => {\r\n        if (onStartRef.current) {\r\n            onStartRef.current(importInfo);\r\n        }\r\n    }, [importInfo]);\r\n    // notify on end of processing\r\n    // (separate effect in case of errors)\r\n    const onCompleteRef = useRef(onComplete); // wrap in ref to avoid re-triggering\r\n    onCompleteRef.current = onComplete;\r\n    useEffect(() => {\r\n        if (isComplete && onCompleteRef.current) {\r\n            onCompleteRef.current(importInfo);\r\n        }\r\n    }, [importInfo, isComplete]);\r\n    // ensure status gets focus when complete, in case status role is not read out\r\n    const statusRef = useRef(null);\r\n    useEffect(() => {\r\n        if ((isComplete || error) && statusRef.current) {\r\n            statusRef.current.focus();\r\n        }\r\n    }, [isComplete, error]);\r\n    // perform main async parse\r\n    const processChunkRef = useRef(processChunk); // wrap in ref to avoid re-triggering\r\n    const asyncLockRef = useRef(0);\r\n    useEffect(() => {\r\n        const oplock = asyncLockRef.current;\r\n        processFile(Object.assign(Object.assign({}, fileState), { fieldAssignments: fieldsState.fieldAssignments }), (deltaCount) => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return; // @todo signal abort\r\n            }\r\n            setProgressCount((prev) => prev + deltaCount);\r\n        }, processChunkRef.current).then(() => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return;\r\n            }\r\n            setIsComplete(true);\r\n        }, (error) => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return;\r\n            }\r\n            setError(error);\r\n        });\r\n        return () => {\r\n            // invalidate current oplock on change or unmount\r\n            asyncLockRef.current += 1;\r\n        };\r\n    }, [fileState, fieldsState]);\r\n    // simulate asymptotic progress percentage\r\n    const progressPercentage = useMemo(() => {\r\n        if (isComplete) {\r\n            return 100;\r\n        }\r\n        // inputs hand-picked so that correctly estimated total is about 75% of the bar\r\n        const progressPower = 2.5 * (progressCount / estimatedRowCount);\r\n        const progressLeft = Math.pow(0.5, progressPower);\r\n        // convert to .1 percent precision for smoother bar display\r\n        return Math.floor(1000 - 1000 * progressLeft) / 10;\r\n    }, [estimatedRowCount, progressCount, isComplete]);\r\n    const l10n = useLocale('progressStep');\r\n    return (React.createElement(ImporterFrame, { fileName: fileState.file.name, subtitle: l10n.stepSubtitle, error: error && (error.message || String(error)), secondaryDisabled: !isComplete || isDismissed, secondaryLabel: onRestart && onClose ? l10n.uploadMoreButton : undefined, onSecondary: onRestart && onClose ? onRestart : undefined, nextDisabled: !isComplete || isDismissed, nextLabel: !!(onClose || onRestart) &&\r\n            (onRestart ? l10n.uploadMoreButton : l10n.finishButton), onNext: () => {\r\n            if (onClose) {\r\n                setIsDismissed(true);\r\n                onClose(importInfo);\r\n            }\r\n            else if (onRestart) {\r\n                onRestart();\r\n            }\r\n        } },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay\" },\r\n            isComplete || error ? (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status\", role: \"status\", tabIndex: -1, ref: statusRef }, error ? l10n.statusError : l10n.statusComplete)) : (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status -pending\", role: \"status\" }, l10n.statusPending)),\r\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__count\", role: \"text\" },\r\n                React.createElement(\"var\", null, l10n.processedRowsLabel),\r\n                \" \",\r\n                progressCount),\r\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBar\" },\r\n                React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBarIndicator\", style: { width: `${progressPercentage}%` } })))));\r\n}\r\n","var __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport React, { useMemo, useState, useEffect, useContext } from 'react';\r\nimport { FileStep } from './file-step/FileStep';\r\nimport { generatePreviewColumns } from './fields-step/ColumnPreview';\r\nimport { FieldsStep } from './fields-step/FieldsStep';\r\nimport { ProgressDisplay } from './ProgressDisplay';\r\nimport './Importer.scss';\r\nimport { LocaleContext } from '../locale/LocaleContext';\r\nimport { enUS } from '../locale';\r\nconst FieldDefinitionContext = React.createContext(null);\r\nlet fieldIdCount = 0;\r\n// defines a field to be filled from file column during import\r\nexport const ImporterField = ({ name, label, optional }) => {\r\n    // @todo this is not SSR-compatible\r\n    const fieldId = useMemo(() => (fieldIdCount += 1), []);\r\n    const fieldSetter = useContext(FieldDefinitionContext);\r\n    // update central list as needed\r\n    useEffect(() => {\r\n        if (!fieldSetter) {\r\n            console.error('importer field must be a child of importer'); // @todo\r\n            return;\r\n        }\r\n        fieldSetter((prev) => {\r\n            const newField = { id: fieldId, name, label, isOptional: !!optional };\r\n            const copy = [...prev];\r\n            const existingIndex = copy.findIndex((item) => item.name === name);\r\n            // preserve existing array position if possible\r\n            // @todo keep both copies in a map to deal with dynamic fields better\r\n            if (existingIndex === -1) {\r\n                copy.push(newField);\r\n            }\r\n            else {\r\n                copy[existingIndex] = newField;\r\n            }\r\n            return copy;\r\n        });\r\n    }, [fieldId, fieldSetter, name, label, optional]);\r\n    // on component unmount, remove this field from list by ID\r\n    useEffect(() => {\r\n        if (!fieldSetter) {\r\n            console.error('importer field must be a child of importer'); // @todo\r\n            return;\r\n        }\r\n        return () => {\r\n            fieldSetter((prev) => {\r\n                return prev.filter((field) => field.id !== fieldId);\r\n            });\r\n        };\r\n    }, [fieldId, fieldSetter]);\r\n    return null;\r\n};\r\nexport function Importer(_a) {\r\n    var { assumeNoHeaders, restartable, processChunk, onStart, onComplete, onClose, children: content, locale } = _a, customPapaParseConfig = __rest(_a, [\"assumeNoHeaders\", \"restartable\", \"processChunk\", \"onStart\", \"onComplete\", \"onClose\", \"children\", \"locale\"]);\r\n    // helper to combine our displayed content and the user code that provides field definitions\r\n    const [fields, setFields] = useState([]);\r\n    const [fileState, setFileState] = useState(null);\r\n    const [fileAccepted, setFileAccepted] = useState(false);\r\n    const [fieldsState, setFieldsState] = useState(null);\r\n    const [fieldsAccepted, setFieldsAccepted] = useState(false);\r\n    // reset field assignments when file changes\r\n    const activeFile = fileState && fileState.file;\r\n    useEffect(() => {\r\n        if (activeFile) {\r\n            setFieldsState(null);\r\n        }\r\n    }, [activeFile]);\r\n    const externalPreview = useMemo(() => {\r\n        // generate stable externally-visible data objects\r\n        const externalColumns = fileState &&\r\n            generatePreviewColumns(fileState.firstRows, fileState.hasHeaders);\r\n        return (fileState &&\r\n            externalColumns && {\r\n            rawData: fileState.firstChunk,\r\n            columns: externalColumns,\r\n            skipHeaders: !fileState.hasHeaders,\r\n            parseWarning: fileState.parseWarning\r\n        });\r\n    }, [fileState]);\r\n    // render provided child content that defines the fields\r\n    const contentNodes = useMemo(() => {\r\n        return typeof content === 'function'\r\n            ? content({\r\n                file: fileState && fileState.file,\r\n                preview: externalPreview\r\n            })\r\n            : content;\r\n    }, [fileState, externalPreview, content]);\r\n    const contentWrap = (React.createElement(FieldDefinitionContext.Provider, { value: setFields }, contentNodes));\r\n    // fall back to enUS if no default locale provided\r\n    locale = locale !== null && locale !== void 0 ? locale : enUS;\r\n    if (!fileAccepted || fileState === null || externalPreview === null) {\r\n        return (React.createElement(LocaleContext.Provider, { value: locale },\r\n            React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\r\n                React.createElement(FileStep, { customConfig: customPapaParseConfig, assumeNoHeaders: assumeNoHeaders, prevState: fileState, onChange: (parsedPreview) => {\r\n                        setFileState(parsedPreview);\r\n                    }, onAccept: () => {\r\n                        setFileAccepted(true);\r\n                    } }),\r\n                contentWrap)));\r\n    }\r\n    if (!fieldsAccepted || fieldsState === null) {\r\n        return (React.createElement(LocaleContext.Provider, { value: locale },\r\n            React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\r\n                React.createElement(FieldsStep, { fileState: fileState, fields: fields, prevState: fieldsState, onChange: (state) => {\r\n                        setFieldsState(state);\r\n                    }, onAccept: () => {\r\n                        setFieldsAccepted(true);\r\n                    }, onCancel: () => {\r\n                        // keep existing preview data and assignments\r\n                        setFileAccepted(false);\r\n                    } }),\r\n                contentWrap)));\r\n    }\r\n    return (React.createElement(LocaleContext.Provider, { value: locale },\r\n        React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\r\n            React.createElement(ProgressDisplay, { fileState: fileState, fieldsState: fieldsState, externalPreview: externalPreview, processChunk: processChunk, onStart: onStart, onRestart: restartable\r\n                    ? () => {\r\n                        // reset all state\r\n                        setFileState(null);\r\n                        setFileAccepted(false);\r\n                        setFieldsState(null);\r\n                        setFieldsAccepted(false);\r\n                    }\r\n                    : undefined, onComplete: onComplete, onClose: onClose }),\r\n            contentWrap)));\r\n}\r\n","export * from './components/ImporterProps';\r\nexport * from './components/Importer';\r\nexport * from './locale';\r\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClFA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACrQA;AACA;AACA;AACA;AACA;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvIA;AACA;AACA;;;;A","sourceRoot":""}