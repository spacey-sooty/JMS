{"ast":null,"code":"import React from 'react'; // vector add\n\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates velocity\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @param len the length of the delta vector\r\n * @returns velocity\r\n */\n\n\nfunction calculateVelocity(delta, delta_t, len) {\n  len = len || Math.hypot.apply(Math, delta);\n  return delta_t ? len / delta_t : 0;\n}\n/**\r\n * Calculates velocities vector\r\n * @template T the expected vector type\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @returns velocities vector\r\n */\n\n\nfunction calculateVelocities(delta, delta_t) {\n  return delta_t ? delta.map(function (v) {\n    return v / delta_t;\n  }) : Array(delta.length).fill(0);\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\n/**\r\n * Calculates direction\r\n * @template T the expected vector type\r\n * @param delta\r\n * @param len\r\n * @returns direction\r\n */\n\n\nfunction calculateDirection(delta, len) {\n  len = len || Math.hypot.apply(Math, delta) || 1;\n  return delta.map(function (v) {\n    return v / len;\n  });\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\n\nfunction calculateAllKinematics(movement, delta, delta_t) {\n  var len = Math.hypot.apply(Math, delta);\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len)\n  };\n}\n/**\r\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\r\n * This polyfill function is suggested by Mozilla\r\n * :https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\r\n * @param x target number\r\n */\n\n\nfunction sign(x) {\n  if (Math.sign) return Math.sign(x);\n  return Number(x > 0) - Number(x < 0) || +x;\n}\n\nfunction getIntentionalDisplacement(movement, threshold) {\n  var abs = Math.abs(movement);\n  return abs >= threshold ? sign(movement) * threshold : false;\n}\n\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n\n  if (constant === 0) return minMax(position, min, max);\n\n  if (position < min) {\n    return -rubberband(min - position, max - min, constant) + min;\n  }\n\n  if (position > max) {\n    return rubberband(position - max, max - min, constant) + max;\n  }\n\n  return position;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o) {\n  var i = 0;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  i = o[Symbol.iterator]();\n  return i.next.bind(i);\n} // blank function\n\n\nfunction noop() {} // returns a function that chains all functions given as parameters\n\n\nvar chainFns = function chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return fns.forEach(function (fn) {\n      return fn.apply(void 0, args);\n    });\n  };\n};\n\nvar def = {\n  array: function array(value) {\n    return Array.isArray(value) ? value : [value, value];\n  },\n  withDefault: function withDefault(value, defaultIfUndefined) {\n    return value !== void 0 ? value : defaultIfUndefined;\n  }\n};\n\nfunction matchKeysFromObject(obj, matchingObject) {\n  var o = {};\n  Object.entries(obj).forEach(function (_ref) {\n    var key = _ref[0],\n        value = _ref[1];\n    return (value !== void 0 || key in matchingObject) && (o[key] = value);\n  });\n  return o;\n}\n\nfunction valueFn(v) {\n  return typeof v === 'function' ? v() : v;\n}\n\nfunction getInitialState() {\n  // common initial state for all gestures\n  var initialCommon = {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }; // initial state for coordinates-based gestures\n\n  var initialCoordinates = {\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  }; // initial state for distance and angle-based gestures (pinch)\n\n  var initialDistanceAngle = {\n    da: [0, 0],\n    vdva: [0, 0],\n    origin: undefined,\n    turns: 0\n  }; // initial state object (used by the gesture controller)\n\n  return {\n    shared: {\n      hovering: false,\n      scrolling: false,\n      wheeling: false,\n      dragging: false,\n      moving: false,\n      pinching: false,\n      touches: 0,\n      buttons: 0,\n      down: false,\n      shiftKey: false,\n      altKey: false,\n      metaKey: false,\n      ctrlKey: false\n    },\n    drag: _extends(_extends(_extends({}, initialCommon), initialCoordinates), {}, {\n      _isTap: true,\n      _delayedEvent: false,\n      tap: false,\n      swipe: [0, 0]\n    }),\n    pinch: _extends(_extends({}, initialCommon), initialDistanceAngle),\n    wheel: _extends(_extends({}, initialCommon), initialCoordinates),\n    move: _extends(_extends({}, initialCommon), initialCoordinates),\n    scroll: _extends(_extends({}, initialCommon), initialCoordinates)\n  };\n}\n\nvar setListeners = function setListeners(add) {\n  return function (el, listeners, options) {\n    var action = add ? 'addEventListener' : 'removeEventListener';\n    listeners.forEach(function (_ref) {\n      var eventName = _ref[0],\n          fn = _ref[1];\n      return el[action](eventName, fn, options);\n    });\n  };\n};\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\n\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar addListeners = /*#__PURE__*/setListeners(true);\nvar removeListeners = /*#__PURE__*/setListeners(false);\n/**\r\n * Gets modifier keys from event\r\n * @param event\r\n * @returns modifier keys\r\n */\n\nfunction getModifierKeys(event) {\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey;\n  return {\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n\nfunction getTouchEvents(event) {\n  if ('touches' in event) {\n    var touches = event.touches,\n        changedTouches = event.changedTouches;\n    return touches.length > 0 ? touches : changedTouches;\n  }\n\n  return null;\n}\n\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var touchEvents = getTouchEvents(event);\n  var touches = touchEvents && touchEvents.length || 0;\n  var down = touches > 0 || buttons > 0;\n  return _extends({\n    touches: touches,\n    down: down,\n    buttons: buttons\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\n\nfunction getScrollEventValues(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return {\n    values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n  };\n}\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\n\nfunction getWheelEventValues(event) {\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return {\n    values: [deltaX, deltaY]\n  };\n}\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\n\nfunction getPointerEventValues(event) {\n  var touchEvents = getTouchEvents(event);\n\n  var _ref2 = touchEvents ? touchEvents[0] : event,\n      clientX = _ref2.clientX,\n      clientY = _ref2.clientY;\n\n  return {\n    values: [clientX, clientY]\n  };\n}\n\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\nfunction getWebkitGestureEventValues(event) {\n  return {\n    values: [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation]\n  };\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\n\nfunction getTwoTouchesEventData(event) {\n  var touches = event.touches;\n  var dx = touches[1].clientX - touches[0].clientX;\n  var dy = touches[1].clientY - touches[0].clientY;\n  var values = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];\n  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];\n  return {\n    values: values,\n    origin: origin\n  };\n}\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n *\r\n * @template BinderType the type the bind function should return\r\n */\n\n\nvar Controller = function Controller() {\n  var _this = this;\n\n  this.state = getInitialState(); // state for all gestures\n\n  this.timeouts = {}; // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n\n  this.domListeners = []; // when config.domTarget is set, we attach events directly to the dom\n\n  this.windowListeners = {}; // keeps track of window listeners added by gestures (drag only at the moment)\n\n  this.bindings = {}; // an object holding the handlers associated to the gestures\n\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n  this.clean = function () {\n    _this.resetBindings();\n\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    Object.keys(_this.windowListeners).forEach(function (stateKey) {\n      return _this.removeWindowListeners(stateKey);\n    });\n  };\n  /**\r\n   * Function run every time the bind function is run (ie on every render).\r\n   * Resets the binding object and remove dom listeners attached to config.domTarget\r\n   */\n\n\n  this.resetBindings = function () {\n    _this.bindings = {};\n\n    var domTarget = _this.getDomTarget();\n\n    if (domTarget) {\n      removeListeners(domTarget, _this.domListeners, _this.config.eventOptions);\n      _this.domListeners = [];\n    }\n  };\n  /**\r\n   * Returns the domTarget element and parses a ref if needed.\r\n   */\n\n\n  this.getDomTarget = function () {\n    var domTarget = _this.config.domTarget;\n    return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n  };\n  /**\r\n   * Commodity function to let recognizers simply add listeners to config.window.\r\n   */\n\n\n  this.addWindowListeners = function (stateKey, listeners) {\n    if (!_this.config.window) return; // we use this.windowListeners to keep track of the listeners we add\n\n    _this.windowListeners[stateKey] = listeners;\n    addListeners(_this.config.window, listeners, _this.config.eventOptions);\n  };\n  /**\r\n   * Commodity function to let recognizers simply remove listeners to config.window.\r\n   */\n\n\n  this.removeWindowListeners = function (stateKey) {\n    if (!_this.config.window) return;\n    var listeners = _this.windowListeners[stateKey];\n\n    if (listeners) {\n      removeListeners(_this.config.window, listeners, _this.config.eventOptions);\n      delete _this.windowListeners[stateKey];\n    }\n  };\n  /**\r\n   * When config.domTarget is set, this function will add dom listeners to it\r\n   */\n\n\n  this.addDomTargetListeners = function (target) {\n    /** We iterate on the entries of this.binding for each event, then we chain\r\n     * the array of functions mapped to it and push them to this.domListeners\r\n     */\n    Object.entries(_this.bindings).forEach(function (_ref) {\n      var event = _ref[0],\n          fns = _ref[1];\n\n      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);\n    });\n    addListeners(target, _this.domListeners, _this.config.eventOptions);\n  };\n  /**\r\n   * this.bindings is an object which keys match ReactEventHandlerKeys.\r\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n   * that key.\r\n   */\n\n\n  this.addBindings = function (eventNames, fn) {\n    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;\n    eventNamesArray.forEach(function (eventName) {\n      if (_this.bindings[eventName]) _this.bindings[eventName].push(fn);else _this.bindings[eventName] = [fn];\n    });\n  };\n  /**\r\n   * getBindings will return an object that will be bound by users\r\n   * to the react component they want to interact with.\r\n   */\n\n\n  this.getBindings = function () {\n    var bindings = {};\n    var captureString = _this.config.captureString;\n    Object.entries(_this.bindings).forEach(function (_ref2) {\n      var event = _ref2[0],\n          fns = _ref2[1];\n      var fnsArray = Array.isArray(fns) ? fns : [fns];\n      var key = event + captureString;\n      bindings[key] = chainFns.apply(void 0, fnsArray);\n    });\n    return bindings;\n  };\n\n  this.getBind = function () {\n    // If config.domTarget is set we add event listeners to it and return the clean function.\n    if (_this.config.domTarget) {\n      var domTarget = _this.getDomTarget();\n\n      domTarget && _this.addDomTargetListeners(domTarget);\n      return _this.clean;\n    } // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n\n\n    return _this.getBindings();\n  };\n};\n/**\r\n * @private\r\n *\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param {Partial<InternalHandlers>} handlers\r\n * @param {RecognizerClasses} classes\r\n * @param {InternalConfig} config\r\n * @param {NativeHandlersPartial} nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useRecognizers(handlers, classes, config, nativeHandlers) {\n  // The gesture controller keeping track of all gesture states\n  var controller = React.useMemo(function () {\n    var current = new Controller();\n    /**\r\n     * The bind function will create gesture recognizers and return the right\r\n     * bind object depending on whether `domTarget` was specified in the config object.\r\n     */\n\n    var bind = function bind() {\n      current.resetBindings();\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      for (var _iterator = _createForOfIteratorHelperLoose(classes), _step; !(_step = _iterator()).done;) {\n        var RecognizerClass = _step.value;\n        new RecognizerClass(current, args).addBindings();\n      } // we also add event bindings for native handlers\n\n\n      if (controller.nativeRefs) {\n        for (var eventName in controller.nativeRefs) {\n          current.addBindings(eventName, // @ts-ignore we're cheating when it comes to event type :(\n          controller.nativeRefs[eventName]);\n        }\n      }\n\n      return current.getBind();\n    };\n\n    return {\n      nativeRefs: nativeHandlers,\n      current: current,\n      bind: bind\n    };\n  }, []); // We reassign the config and handlers to the controller on every render.\n\n  controller.current.config = config;\n  controller.current.handlers = handlers; // We assign nativeHandlers, otherwise they won't be refreshed on the next render.\n\n  controller.nativeRefs = nativeHandlers; // Run controller clean functions on unmount.\n\n  React.useEffect(function () {\n    return controller.current.clean;\n  }, []);\n  return controller.bind;\n}\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n *\r\n * @protected\r\n * @abstract\r\n * @type {StateKey<T>} whether the Recognizer should deal with coordinates or distance / angle\r\n */\n\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(stateKey, controller, args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    this.stateKey = stateKey;\n    this.controller = controller;\n    this.args = args;\n    this.debounced = true; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n\n      if (ms === void 0) {\n        ms = 140;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    }; // Convenience method to add window listeners for a given gesture\n\n\n    this.addWindowListeners = function (listeners) {\n      _this.controller.addWindowListeners(_this.stateKey, listeners);\n    }; // Convenience method to remove window listeners for a given gesture\n\n\n    this.removeWindowListeners = function () {\n      _this.controller.removeWindowListeners(_this.stateKey);\n    };\n    /**\r\n     * Returns the reinitialized start state for the gesture.\r\n     * Should be common to all gestures.\r\n     *\r\n     * @param {Vector2} values\r\n     * @param {UseGestureEvent} event\r\n     * @returns - the start state for the gesture\r\n     */\n\n\n    this.getStartGestureState = function (values, event) {\n      return _extends(_extends({}, getInitialState()[_this.stateKey]), {}, {\n        _active: true,\n        values: values,\n        initial: values,\n        offset: _this.state.offset,\n        lastOffset: _this.state.offset,\n        startTime: event.timeStamp\n      });\n    }; // Runs rubberband on a vector\n\n\n    this.rubberband = function (vector, rubberband) {\n      var bounds = _this.config.bounds;\n      /**\r\n       * [x, y]: [rubberband(x, min, max), rubberband(y, min, max)]\r\n       */\n\n      return vector.map(function (v, i) {\n        return rubberbandIfOutOfBounds(v, bounds[i][0], bounds[i][1], rubberband[i]);\n      });\n    };\n    /**\r\n     * Fires the gesture handler\r\n     *\r\n     * @param {boolean} [forceFlag] - if true, then the handler will fire even if the gesture is not intentional\r\n     */\n\n\n    this.fireGestureHandler = function (forceFlag) {\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n      if (_this.state._blocked) {\n        // we need debounced gestures to end by themselves\n        if (!_this.debounced) {\n          _this.state._active = false;\n\n          _this.clean();\n        }\n\n        return null;\n      } // If the gesture has no intentional dimension, don't do fire the handler.\n\n\n      var _this$state$_intentio = _this.state._intentional,\n          intentionalX = _this$state$_intentio[0],\n          intentionalY = _this$state$_intentio[1];\n      if (!forceFlag && intentionalX === false && intentionalY === false) return null;\n      var _this$state = _this.state,\n          _active = _this$state._active,\n          active = _this$state.active;\n      _this.state.active = _active;\n      _this.state.first = _active && !active; // `first` is true when the gesture becomes active\n\n      _this.state.last = active && !_active; // `last` is true when the gesture becomes inactive\n\n      _this.controller.state.shared[_this.ingKey] = _active; // Sets dragging, pinching, etc. to the gesture active state\n\n      var state = _extends(_extends(_extends({}, _this.controller.state.shared), _this.state), _this.mapStateValues(_this.state)); // @ts-ignore\n\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo; // Cleans the gesture when the gesture is no longer active.\n\n      if (!_active) _this.clean();\n      return state;\n    };\n  } // Returns the gesture config\n\n\n  var _proto = Recognizer.prototype; // Conveninence method to update the shared state\n\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Conveninence method to update the gesture state\n  ;\n\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns a generic, common payload for all gestures from an event.\r\n   *\r\n   * @param {UseGestureEvent} event\r\n   * @param {boolean} [isStartEvent]\r\n   * @returns - the generic gesture payload\r\n   */\n  ;\n\n  _proto.getGenericPayload = function getGenericPayload(event, isStartEvent) {\n    var timeStamp = event.timeStamp,\n        type = event.type;\n    var _this$state2 = this.state,\n        values = _this$state2.values,\n        startTime = _this$state2.startTime;\n    return {\n      _lastEventType: type,\n      event: event,\n      timeStamp: timeStamp,\n      elapsedTime: isStartEvent ? 0 : timeStamp - startTime,\n      args: this.args,\n      previous: values\n    };\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement, _state) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */\n  ;\n\n  _proto.getMovement = function getMovement(values, state) {\n    if (state === void 0) {\n      state = this.state;\n    }\n\n    var _this$config = this.config,\n        initial = _this$config.initial,\n        threshold = _this$config.threshold,\n        rubberband = _this$config.rubberband;\n    var t0 = threshold[0],\n        t1 = threshold[1];\n    var _state2 = state,\n        _initial = _state2._initial,\n        _active = _state2._active,\n        intentional = _state2._intentional,\n        lastOffset = _state2.lastOffset,\n        prevMovement = _state2.movement;\n    var i0 = intentional[0],\n        i1 = intentional[1];\n\n    var _this$getInternalMove = this.getInternalMovement(values, state),\n        _m0 = _this$getInternalMove[0],\n        _m1 = _this$getInternalMove[1];\n    /**\r\n     * For both dimensions of the gesture, check its intentionality on each frame.\r\n     */\n\n\n    if (i0 === false) {\n      i0 = getIntentionalDisplacement(_m0, t0);\n    }\n\n    if (i1 === false) {\n      i1 = getIntentionalDisplacement(_m1, t1);\n    } // Get gesture specific state properties based on intentionality and movement.\n\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], [_m0, _m1], state);\n    var _intentional = intentionalityCheck._intentional,\n        _blocked = intentionalityCheck._blocked;\n    var _i0 = _intentional[0],\n        _i1 = _intentional[1];\n    var _movement = [_m0, _m1];\n    if (_i0 !== false && intentional[0] === false) _initial[0] = valueFn(initial)[0];\n    if (_i1 !== false && intentional[1] === false) _initial[1] = valueFn(initial)[1];\n    /**\r\n     * If the gesture has been blocked (from gesture specific checkIntentionality),\r\n     * stop right there.\r\n     */\n\n    if (_blocked) return _extends(_extends({}, intentionalityCheck), {}, {\n      _movement: _movement,\n      delta: [0, 0]\n    });\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n    var movement = [_i0 !== false ? _m0 - _i0 : valueFn(initial)[0], _i1 !== false ? _m1 - _i1 : valueFn(initial)[1]];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n\n    movement = this.rubberband(addV(movement, _initial), _rubberband); // rubberbanded movement\n\n    return _extends(_extends({}, intentionalityCheck), {}, {\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      offset: this.rubberband(offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n\n  _proto.clean = function clean() {\n    this.clearTimeout();\n    this.removeWindowListeners();\n  };\n\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }]);\n\n  return Recognizer;\n}();\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n * @abstract\r\n * @class CoordinatesRecognizer\r\n * @extends {Recognizer<T>}\r\n * @template T\r\n */\n\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = CoordinatesRecognizer.prototype;\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   *\r\n   * @param {[FalseOrNumber, FalseOrNumber]} _intentional\r\n   * @param {Vector2} _movement\r\n   * @param {PartialGestureState<T>} state\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement, state) {\n    var _intentional2 = _intentional,\n        _ix = _intentional2[0],\n        _iy = _intentional2[1];\n    var intentionalMovement = _ix !== false || _iy !== false;\n    var axis = state.axis;\n    var _blocked = false; // If the movement is intentional, we can compute axis.\n\n    if (intentionalMovement) {\n      var _movement$map = _movement.map(Math.abs),\n          absX = _movement$map[0],\n          absY = _movement$map[1];\n\n      var _this$config = this.config,\n          configAxis = _this$config.axis,\n          lockDirection = _this$config.lockDirection; // We make sure we only set axis value if it hadn't been detected before.\n\n      axis = axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n\n      if (!!configAxis || lockDirection) {\n        if (!!axis) {\n          // If the detected axis doesn't match the config axis we block the gesture\n          if (!!configAxis && axis !== configAxis) _blocked = true;else {\n            // Otherwise we prevent the gesture from updating the unwanted axis.\n            var lockedIndex = axis === 'x' ? 1 : 0;\n            _intentional[lockedIndex] = false;\n          }\n        } else {\n          // Until we've detected the axis, we prevent the hnadler from updating.\n          _intentional = [false, false];\n        }\n      }\n    }\n\n    return {\n      _intentional: _intentional,\n      _blocked: _blocked,\n      axis: axis\n    };\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var timeStamp = this.state.timeStamp;\n    var movementDetection = this.getMovement(values, this.state);\n    var _blocked = movementDetection._blocked,\n        delta = movementDetection.delta,\n        movement = movementDetection.movement;\n    if (_blocked) return movementDetection;\n    var delta_t = event.timeStamp - timeStamp;\n    var kinematics = calculateAllKinematics(movement, delta, delta_t);\n    return _extends(_extends({\n      values: values,\n      delta: delta\n    }, movementDetection), kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar TAP_DISTANCE_THRESHOLD = 3;\nvar SWIPE_MAX_ELAPSED_TIME = 220;\nvar FILTER_REPEATED_EVENTS_DELAY = 200;\n\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;\n    _this.ingKey = 'dragging';\n    _this.wasTouch = false;\n\n    _this.isEventTypeTouch = function (type) {\n      return !!type && type.indexOf('touch') === 0;\n    };\n\n    _this.dragShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n          touches = _getGenericEventData.touches;\n\n      var _lastEventType = _this.state._lastEventType;\n      /**\r\n       * This tries to filter out mouse events triggered by touch screens\r\n       * */\n      // If the previous gesture was touch-based, and the current one is mouse based,\n      // this means that we might be dealing with mouse simulated events if they're close to\n      // each other. We're only doing this check when we're not using pointer events.\n\n      if (!_this.controller.config.pointer && _this.isEventTypeTouch(_lastEventType) && !_this.isEventTypeTouch(event.type)) {\n        var delay = Math.abs(event.timeStamp - _this.state.startTime);\n        if (delay < FILTER_REPEATED_EVENTS_DELAY) return false;\n      }\n\n      return _this.enabled && touches < 2;\n    };\n\n    _this.setPointers = function (event) {\n      var currentTarget = event.currentTarget,\n          pointerId = event.pointerId;\n      if (currentTarget) currentTarget.setPointerCapture(pointerId);\n\n      _this.updateGestureState({\n        currentTarget: currentTarget,\n        pointerId: pointerId\n      });\n    };\n\n    _this.removePointers = function () {\n      var _this$state = _this.state,\n          currentTarget = _this$state.currentTarget,\n          pointerId = _this$state.pointerId;\n      if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId);\n    };\n\n    _this.setListeners = function (isTouch) {\n      _this.removeWindowListeners();\n\n      var dragListeners = isTouch ? [['touchmove', _this.onDragChange], ['touchend', _this.onDragEnd], ['touchcancel', _this.onDragEnd]] : [['mousemove', _this.onDragChange], ['mouseup', _this.onDragEnd]];\n\n      _this.addWindowListeners(dragListeners);\n    };\n\n    _this.onDragStart = function (event) {\n      if (!_this.dragShouldStart(event)) return; // if pointers events\n\n      if (_this.controller.config.pointer) _this.setPointers(event);else _this.setListeners(_this.isEventTypeTouch(event.type));\n\n      if (_this.config.delay > 0) {\n        _this.state._delayedEvent = true;\n        if (typeof event.persist === 'function') event.persist();\n\n        _this.setTimeout(function () {\n          return _this.startDrag(event);\n        }, _this.config.delay);\n      } else {\n        _this.startDrag(event);\n      }\n    };\n\n    _this.onDragChange = function (event) {\n      var canceled = _this.state.canceled;\n      if (canceled) return;\n\n      if (!_this.state._active) {\n        if (_this.state._delayedEvent) {\n          _this.clearTimeout();\n\n          _this.startDrag(event);\n        }\n\n        return;\n      }\n\n      var genericEventData = getGenericEventData(event);\n\n      if (!genericEventData.down) {\n        _this.onDragEnd(event);\n\n        return;\n      }\n\n      _this.updateSharedState(genericEventData);\n\n      var _getPointerEventValue = getPointerEventValues(event),\n          values = _getPointerEventValue.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      var _isTap = _this.state._isTap;\n      if (_isTap && calculateDistance(kinematics._movement) >= TAP_DISTANCE_THRESHOLD) _isTap = false;\n\n      _this.updateGestureState(_extends(_extends(_extends({}, _this.getGenericPayload(event)), kinematics), {}, {\n        _isTap: _isTap,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onDragEnd = function (event) {\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      var _this$state2 = _this.state,\n          _isTap = _this$state2._isTap,\n          values = _this$state2.values,\n          _this$state2$velociti = _this$state2.velocities,\n          vx = _this$state2$velociti[0],\n          vy = _this$state2$velociti[1],\n          _this$state2$movement = _this$state2.movement,\n          mx = _this$state2$movement[0],\n          my = _this$state2$movement[1],\n          _this$state2$_intenti = _this$state2._intentional,\n          ix = _this$state2$_intenti[0],\n          iy = _this$state2$_intenti[1];\n\n      var endState = _extends(_extends({}, _this.getGenericPayload(event)), _this.getMovement(values));\n\n      var elapsedTime = endState.elapsedTime;\n      var _this$config = _this.config,\n          _this$config$swipeVel = _this$config.swipeVelocity,\n          svx = _this$config$swipeVel[0],\n          svy = _this$config$swipeVel[1],\n          _this$config$swipeDis = _this$config.swipeDistance,\n          sx = _this$config$swipeDis[0],\n          sy = _this$config$swipeDis[1];\n      var swipe = [0, 0];\n\n      if (elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy);\n      }\n\n      _this.updateGestureState(_extends(_extends({\n        event: event\n      }, endState), {}, {\n        tap: _isTap,\n        swipe: swipe\n      }));\n\n      _this.fireGestureHandler(_this.config.filterTaps && _this.state._isTap);\n    };\n\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n\n      _this.state._delayedEvent = false;\n      if (_this.controller.config.pointer) _this.removePointers();\n    };\n\n    _this.onCancel = function () {\n      _this.updateGestureState({\n        canceled: true,\n        cancel: noop\n      });\n\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.startDrag = function startDrag(event) {\n    var _this2 = this;\n\n    var _getPointerEventValue2 = getPointerEventValues(event),\n        values = _getPointerEventValue2.values;\n\n    this.updateSharedState(getGenericEventData(event));\n\n    var startState = _extends(_extends({}, this.getStartGestureState(values, event)), this.getGenericPayload(event, true));\n\n    this.updateGestureState(_extends(_extends(_extends({}, startState), this.getMovement(values, startState)), {}, {\n      cancel: function cancel() {\n        return _this2.onCancel();\n      }\n    }));\n    this.fireGestureHandler();\n  };\n\n  _proto.addBindings = function addBindings() {\n    if (this.controller.config.pointer) {\n      this.controller.addBindings('onPointerDown', this.onDragStart);\n      this.controller.addBindings('onPointerMove', this.onDragChange);\n      this.controller.addBindings(['onPointerUp', 'onPointerCancel'], this.onDragEnd);\n    } else {\n      this.controller.addBindings(['onTouchStart', 'onMouseDown'], this.onDragStart);\n    }\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 60;\nvar defaultWindow = typeof window !== 'undefined' ? window : undefined;\nvar defaultCoordinatesOptions = {\n  lockDirection: false,\n  axis: undefined,\n  bounds: undefined\n};\n/**\r\n * @private\r\n *\r\n * Returns the internal generic option object.\r\n *\r\n * @param {Partial<GenericOptions>} [config={}]\r\n * @returns {InternalGenericOptions}\r\n */\n\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      _config$eventOptions = _config.eventOptions;\n  _config$eventOptions = _config$eventOptions === void 0 ? {} : _config$eventOptions;\n\n  var _config$eventOptions$ = _config$eventOptions.passive,\n      passive = _config$eventOptions$ === void 0 ? true : _config$eventOptions$,\n      _config$eventOptions$2 = _config$eventOptions.capture,\n      capture = _config$eventOptions$2 === void 0 ? false : _config$eventOptions$2,\n      _config$eventOptions$3 = _config$eventOptions.pointer,\n      pointer = _config$eventOptions$3 === void 0 ? false : _config$eventOptions$3,\n      _config$window = _config.window,\n      window = _config$window === void 0 ? defaultWindow : _config$window,\n      _config$domTarget = _config.domTarget,\n      domTarget = _config$domTarget === void 0 ? undefined : _config$domTarget,\n      _config$enabled = _config.enabled,\n      enabled = _config$enabled === void 0 ? true : _config$enabled,\n      restConfig = _objectWithoutPropertiesLoose(_config, [\"eventOptions\", \"window\", \"domTarget\", \"enabled\"]);\n\n  return _extends(_extends({}, restConfig), {}, {\n    enabled: enabled,\n    domTarget: domTarget,\n    window: window,\n    // passive is always true if there's no domTarget\n    eventOptions: {\n      passive: !domTarget || !!passive,\n      capture: !!capture\n    },\n    captureString: capture ? 'Capture' : '',\n    pointer: !!pointer\n  });\n}\n\nfunction getInternalGestureOptions(gestureConfig) {\n  var _gestureConfig$thresh = gestureConfig.threshold,\n      threshold = _gestureConfig$thresh === void 0 ? undefined : _gestureConfig$thresh,\n      _gestureConfig$rubber = gestureConfig.rubberband,\n      rubberband = _gestureConfig$rubber === void 0 ? 0 : _gestureConfig$rubber,\n      _gestureConfig$enable = gestureConfig.enabled,\n      enabled = _gestureConfig$enable === void 0 ? true : _gestureConfig$enable,\n      _gestureConfig$initia = gestureConfig.initial,\n      initial = _gestureConfig$initia === void 0 ? [0, 0] : _gestureConfig$initia;\n  if (typeof rubberband === 'boolean') rubberband = rubberband ? DEFAULT_RUBBERBAND : 0;\n  if (threshold === void 0) threshold = 0;\n  return {\n    enabled: enabled,\n    initial: initial,\n    threshold: def.array(threshold),\n    rubberband: def.array(rubberband)\n  };\n}\n\nfunction getInternalCoordinatesOptions(coordinatesConfig) {\n  if (coordinatesConfig === void 0) {\n    coordinatesConfig = {};\n  }\n\n  var _coordinatesConfig = coordinatesConfig,\n      axis = _coordinatesConfig.axis,\n      lockDirection = _coordinatesConfig.lockDirection,\n      _coordinatesConfig$bo = _coordinatesConfig.bounds,\n      bounds = _coordinatesConfig$bo === void 0 ? {} : _coordinatesConfig$bo,\n      internalOptions = _objectWithoutPropertiesLoose(_coordinatesConfig, [\"axis\", \"lockDirection\", \"bounds\"]);\n\n  var boundsArray = [[def.withDefault(bounds.left, -Infinity), def.withDefault(bounds.right, Infinity)], [def.withDefault(bounds.top, -Infinity), def.withDefault(bounds.bottom, Infinity)]];\n  return _extends(_extends(_extends(_extends({}, getInternalGestureOptions(internalOptions)), defaultCoordinatesOptions), matchKeysFromObject({\n    axis: axis,\n    lockDirection: lockDirection\n  }, coordinatesConfig)), {}, {\n    bounds: boundsArray\n  });\n}\n\nfunction getInternalDistanceAngleOptions(distanceAngleConfig) {\n  if (distanceAngleConfig === void 0) {\n    distanceAngleConfig = {};\n  }\n\n  var _distanceAngleConfig = distanceAngleConfig,\n      _distanceAngleConfig$ = _distanceAngleConfig.distanceBounds,\n      distanceBounds = _distanceAngleConfig$ === void 0 ? {} : _distanceAngleConfig$,\n      _distanceAngleConfig$2 = _distanceAngleConfig.angleBounds,\n      angleBounds = _distanceAngleConfig$2 === void 0 ? {} : _distanceAngleConfig$2,\n      internalOptions = _objectWithoutPropertiesLoose(_distanceAngleConfig, [\"distanceBounds\", \"angleBounds\"]);\n\n  var boundsArray = [[def.withDefault(distanceBounds.min, -Infinity), def.withDefault(distanceBounds.max, Infinity)], [def.withDefault(angleBounds.min, -Infinity), def.withDefault(angleBounds.max, Infinity)]];\n  return _extends(_extends({}, getInternalGestureOptions(internalOptions)), {}, {\n    bounds: boundsArray\n  });\n}\n\nfunction getInternalDragOptions(dragConfig) {\n  if (dragConfig === void 0) {\n    dragConfig = {};\n  }\n\n  var _dragConfig = dragConfig,\n      enabled = _dragConfig.enabled,\n      threshold = _dragConfig.threshold,\n      bounds = _dragConfig.bounds,\n      rubberband = _dragConfig.rubberband,\n      initial = _dragConfig.initial,\n      dragOptions = _objectWithoutPropertiesLoose(_dragConfig, [\"enabled\", \"threshold\", \"bounds\", \"rubberband\", \"initial\"]);\n\n  var _dragOptions$swipeVel = dragOptions.swipeVelocity,\n      swipeVelocity = _dragOptions$swipeVel === void 0 ? DEFAULT_SWIPE_VELOCITY : _dragOptions$swipeVel,\n      _dragOptions$swipeDis = dragOptions.swipeDistance,\n      swipeDistance = _dragOptions$swipeDis === void 0 ? DEFAULT_SWIPE_DISTANCE : _dragOptions$swipeDis,\n      _dragOptions$delay = dragOptions.delay,\n      delay = _dragOptions$delay === void 0 ? false : _dragOptions$delay,\n      _dragOptions$filterTa = dragOptions.filterTaps,\n      filterTaps = _dragOptions$filterTa === void 0 ? false : _dragOptions$filterTa,\n      axis = dragOptions.axis,\n      lockDirection = dragOptions.lockDirection;\n\n  if (threshold === void 0) {\n    threshold = Math.max(0, filterTaps ? 3 : 0, lockDirection || axis ? 1 : 0);\n  } else {\n    filterTaps = true;\n  }\n\n  var internalCoordinatesOptions = getInternalCoordinatesOptions(matchKeysFromObject({\n    enabled: enabled,\n    threshold: threshold,\n    bounds: bounds,\n    rubberband: rubberband,\n    axis: axis,\n    lockDirection: lockDirection,\n    initial: initial\n  }, dragConfig));\n  return _extends(_extends({}, internalCoordinatesOptions), {}, {\n    filterTaps: filterTaps || internalCoordinatesOptions.threshold[0] + internalCoordinatesOptions.threshold[1] > 0,\n    swipeVelocity: def.array(swipeVelocity),\n    swipeDistance: def.array(swipeDistance),\n    delay: typeof delay === 'number' ? delay : delay ? DEFAULT_DRAG_DELAY : 0\n  });\n}\n/**\r\n * @public\r\n *\r\n * Drag hook.\r\n *\r\n * @param {Handler<'drag'>} handler - the function fired every time the drag gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and drag options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      drag = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    drag: getInternalDragOptions(drag)\n  });\n\n  return useRecognizers({\n    drag: handler\n  }, [DragRecognizer], mergedConfig);\n}\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n * @abstract\r\n * @class DistanceAngleRecognizer\r\n * @extends {Recognizer<T>}\r\n * @template T\r\n */\n\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = DistanceAngleRecognizer.prototype;\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n\n  _proto.getInternalMovement = function getInternalMovement(_ref, state) {\n    var d = _ref[0],\n        a = _ref[1];\n    var da = state.values,\n        turns = state.turns,\n        initial = state.initial; // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n\n    a = a !== void 0 ? a : da[1];\n    var delta_a = a - da[1];\n    /**\r\n     * The angle value might jump from 179deg to -179deg when we actually want to\r\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\r\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\r\n     */\n\n    var newTurns = Math.abs(delta_a) > 270 ? turns + sign(delta_a) : turns; // we update the angle difference to its corrected value\n\n    var movement_d = d - initial[0];\n    var movement_a = a - 360 * newTurns - initial[1];\n    return [movement_d, movement_a];\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var _this$state = this.state,\n        timeStamp = _this$state.timeStamp,\n        initial = _this$state.initial;\n    var movementDetection = this.getMovement(values, this.state);\n    var delta = movementDetection.delta,\n        movement = movementDetection.movement;\n    var turns = (values[1] - movement[1] - initial[1]) / 360;\n    var delta_t = event.timeStamp - timeStamp;\n    var kinematics = calculateAllKinematics(movement, delta, delta_t);\n    return _extends(_extends({\n      values: values,\n      delta: delta,\n      turns: turns\n    }, movementDetection), kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.ingKey = 'pinching';\n\n    _this.pinchShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n          touches = _getGenericEventData.touches;\n\n      return _this.enabled && touches === 2;\n    };\n\n    _this.onPinchStart = function (event) {\n      if (!_this.pinchShouldStart(event)) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa.values,\n          origin = _getTwoTouchesEventDa.origin;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true));\n\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), _this.getMovement(values, startState)), {}, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          timeStamp = _this$state.timeStamp,\n          _active = _this$state._active;\n      if (canceled || !_active) return;\n      var genericEventData = getGenericEventData(event);\n      if (genericEventData.touches !== 2 || event.timeStamp === timeStamp) return;\n\n      _this.updateSharedState(genericEventData);\n\n      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa2.values,\n          origin = _getTwoTouchesEventDa2.origin;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends(_extends(_extends({}, _this.getGenericPayload(event)), kinematics), {}, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchEnd = function (event) {\n      if (!_this.state.active) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends(_extends({\n        event: event\n      }, _this.getGenericPayload(event)), _this.getMovement(_this.state.values)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onCancel = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState({\n        canceled: true,\n        cancel: noop\n      });\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault();\n\n      var _getWebkitGestureEven = getWebkitGestureEventValues(event),\n          values = _getWebkitGestureEven.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true));\n\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), _this.getMovement(values, startState)), {}, {\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n          canceled = _this$state2.canceled,\n          _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getWebkitGestureEven2 = getWebkitGestureEventValues(event),\n          values = _getWebkitGestureEven2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends(_extends(_extends({}, _this.getGenericPayload(event)), kinematics), {}, {\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureEnd = function (event) {\n      event.preventDefault();\n      if (!_this.state.active) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends(_extends({\n        event: event\n      }, _this.getGenericPayload(event)), _this.getMovement(_this.state.values)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.updateTouchData = function (event) {\n      if (!_this.enabled || event.touches.length !== 2 || !_this.state._active) return;\n\n      var _getTwoTouchesEventDa3 = getTwoTouchesEventData(event),\n          origin = _getTwoTouchesEventDa3.origin;\n\n      _this.state.origin = origin;\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event),\n          _getWheelEventValues$ = _getWheelEventValues.values,\n          delta_d = _getWheelEventValues$[1];\n\n      var _this$state$values = _this.state.values,\n          prev_d = _this$state$values[0],\n          prev_a = _this$state$values[1];\n      var d = prev_d - delta_d;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [0, delta_d]\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF.values,\n          delta = _this$getWheelValuesF.delta,\n          origin = _this$getWheelValuesF.origin;\n\n      if (!_this.controller.config.eventOptions.passive) {\n        event.preventDefault();\n      } else if (process.env.NODE_ENV === 'development') {\n        console.warn('To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.');\n      }\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends(_extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true)), {}, {\n        initial: _this.state.values\n      });\n\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), _this.getMovement(values, startState)), {}, {\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF2.values,\n          origin = _this$getWheelValuesF2.origin,\n          delta = _this$getWheelValuesF2.delta;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends(_extends(_extends({}, _this.getGenericPayload(event)), kinematics), {}, {\n        origin: origin,\n        delta: delta\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && supportsGestureEvents()) {\n      this.controller.addBindings('onGestureStart', this.onGestureStart);\n      this.controller.addBindings('onGestureChange', this.onGestureChange);\n      this.controller.addBindings(['onGestureEnd', 'onTouchCancel'], this.onGestureEnd);\n      this.controller.addBindings(['onTouchStart', 'onTouchMove'], this.updateTouchData);\n    } else {\n      this.controller.addBindings('onTouchStart', this.onPinchStart);\n      this.controller.addBindings('onTouchMove', this.onPinchChange);\n      this.controller.addBindings(['onTouchEnd', 'onTouchCancel'], this.onPinchEnd);\n      this.controller.addBindings('onWheel', this.onWheel);\n    }\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * @public\r\n *\r\n * Pinch hook.\r\n *\r\n * @param {Handler<'pinch'>} handler - the function fired every time the pinch gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and pinch options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      pinch = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    pinch: getInternalDistanceAngleOptions(pinch)\n  });\n\n  return useRecognizers({\n    pinch: handler\n  }, [PinchRecognizer], mergedConfig);\n}\n\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;\n    _this.ingKey = 'wheeling';\n    _this.debounced = true;\n\n    _this.wheelShouldRun = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return false;\n      return _this.enabled;\n    };\n\n    _this.getValuesFromEvent = function (event) {\n      var prevValues = _this.state.values;\n\n      var _getWheelEventValues = getWheelEventValues(event),\n          values = _getWheelEventValues.values;\n\n      return {\n        values: addV(values, prevValues)\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getValuesFromEv = _this.getValuesFromEvent(event),\n          values = _this$getValuesFromEv.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends(_extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true)), {}, {\n        initial: _this.state.values\n      });\n\n      var movementDetection = _this.getMovement(values, startState);\n\n      var delta = movementDetection.delta;\n\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), movementDetection), {}, {\n        distance: calculateDistance(delta),\n        direction: calculateDirection(delta)\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _this$getValuesFromEv2 = _this.getValuesFromEvent(event),\n          values = _this$getValuesFromEv2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends(_extends({}, _this.getGenericPayload(event)), kinematics));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends(_extends({}, _this.getMovement(_this.state.values)), {}, {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    this.controller.addBindings('onWheel', this.onWheel);\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * @public\r\n *\r\n * Wheel hook.\r\n *\r\n * @param {Handler<'wheel'>} handler - the function fired every time the wheel gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and wheel options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      wheel = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    wheel: getInternalCoordinatesOptions(wheel)\n  });\n\n  return useRecognizers({\n    wheel: handler\n  }, [WheelRecognizer], mergedConfig);\n}\n\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;\n    _this.ingKey = 'moving';\n    _this.debounced = true;\n\n    _this.moveShouldRun = function () {\n      return _this.enabled;\n    };\n\n    _this.onMove = function (event) {\n      if (!_this.moveShouldRun()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onMoveEnd);\n\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n\n    _this.onMoveStart = function (event) {\n      var _getPointerEventValue = getPointerEventValues(event),\n          values = _getPointerEventValue.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true));\n\n      _this.updateGestureState(_extends(_extends({}, startState), _this.getMovement(values, startState)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getPointerEventValue2 = getPointerEventValues(event),\n          values = _getPointerEventValue2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends(_extends({}, _this.getGenericPayload(event)), kinematics));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends(_extends({}, _this.getMovement(_this.state.values)), {}, {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n\n      if (_this.controller.config.hover.enabled) {\n        var _getPointerEventValue3 = getPointerEventValues(event),\n            values = _getPointerEventValue3.values;\n\n        var state = _extends(_extends(_extends(_extends({}, _this.controller.state.shared), _this.state), _this.getGenericPayload(event, true)), {}, {\n          values: values,\n          active: true,\n          hovering: true\n        });\n\n        _this.controller.handlers.hover(_extends(_extends({}, state), _this.mapStateValues(state)));\n      }\n\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n\n      if (_this.controller.config.hover.enabled) {\n        var _getPointerEventValue4 = getPointerEventValues(event),\n            values = _getPointerEventValue4.values;\n\n        var state = _extends(_extends(_extends(_extends({}, _this.controller.state.shared), _this.state), _this.getGenericPayload(event)), {}, {\n          values: values,\n          active: false\n        });\n\n        _this.controller.handlers.hover(_extends(_extends({}, state), _this.mapStateValues(state)));\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    if (this.controller.config.pointer) {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onPointerMove', this.onMove);\n      }\n\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onPointerEnter', this.onPointerEnter);\n        this.controller.addBindings('onPointerLeave', this.onPointerLeave);\n      }\n    } else {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onMouseMove', this.onMove);\n      }\n\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onMouseEnter', this.onPointerEnter);\n        this.controller.addBindings('onMouseLeave', this.onPointerLeave);\n      }\n    }\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * @public\r\n *\r\n * Move hook.\r\n *\r\n * @param {Handler<'move'>} handler - the function fired every time the move gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and move options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      move = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    move: getInternalCoordinatesOptions(move)\n  });\n\n  return useRecognizers({\n    move: handler\n  }, [MoveRecognizer], mergedConfig);\n}\n/**\r\n * @public\r\n *\r\n * Hover hook.\r\n *\r\n * @param {Handler<'hover'>} handler - the function fired every time the hover gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and hover options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      hover = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    hover: _extends({\n      enabled: true\n    }, hover)\n  });\n\n  return useRecognizers({\n    hover: handler\n  }, [MoveRecognizer], mergedConfig);\n}\n\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;\n    _this.ingKey = 'scrolling';\n    _this.debounced = true;\n\n    _this.scrollShouldRun = function () {\n      return _this.enabled;\n    };\n\n    _this.onScroll = function (event) {\n      if (!_this.scrollShouldRun()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onScrollEnd);\n\n      if (!_this.state._active) _this.onScrollStart(event);else _this.onScrollChange(event);\n    };\n\n    _this.onScrollStart = function (event) {\n      var _getScrollEventValues = getScrollEventValues(event),\n          values = _getScrollEventValues.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends(_extends(_extends({}, _this.getStartGestureState(values, event)), _this.getGenericPayload(event, true)), {}, {\n        initial: _this.state.values\n      });\n\n      var movementDetection = _this.getMovement(values, startState);\n\n      var delta = movementDetection.delta;\n\n      _this.updateGestureState(_extends(_extends(_extends({}, startState), movementDetection), {}, {\n        distance: calculateDistance(delta),\n        direction: calculateDirection(delta)\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onScrollChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getScrollEventValues2 = getScrollEventValues(event),\n          values = _getScrollEventValues2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends(_extends({}, _this.getGenericPayload(event)), kinematics));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onScrollEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends(_extends({}, _this.getMovement(_this.state.values)), {}, {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    this.controller.addBindings('onScroll', this.onScroll);\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * @public\r\n *\r\n * Scroll hook.\r\n *\r\n * @param {Handler<'scroll'>} handler - the function fired every time the scroll gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and scroll options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      scroll = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends(_extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  })), {}, {\n    scroll: getInternalCoordinatesOptions(scroll)\n  });\n\n  return useRecognizers({\n    scroll: handler\n  }, [ScrollRecognizer], mergedConfig);\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {UserHandlersPartial} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useGesture(handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  /**\r\n   * If handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\r\n   * actions will include 'onDrag' and 'onMove.\r\n   */\n\n\n  var _React$useState = React.useState(function () {\n    return new Set(Object.keys(handlers).map(function (k) {\n      return k.replace(/End|Start/, '');\n    }));\n  }),\n      actions = _React$useState[0];\n  /**\r\n   * Here we compute the derived internal config based on the provided config object.\r\n   * We decompose the config into its generic and gesture options and compute each.\r\n   * TODO: this is currently done on every render!\r\n   */\n\n\n  var _config = config,\n      drag = _config.drag,\n      wheel = _config.wheel,\n      move = _config.move,\n      scroll = _config.scroll,\n      pinch = _config.pinch,\n      hover = _config.hover,\n      restConfig = _objectWithoutPropertiesLoose(_config, [\"drag\", \"wheel\", \"move\", \"scroll\", \"pinch\", \"hover\"]);\n\n  var mergedConfig = getInternalGenericOptions(restConfig);\n  var classes = [];\n  var internalHandlers = {}; // will hold reference to native handlers such as onClick, onMouseDown, etc.\n\n  var _nativeHandlers = _extends({}, handlers);\n\n  if (actions.has('onDrag')) {\n    classes.push(DragRecognizer);\n    internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag', _nativeHandlers);\n    mergedConfig.drag = getInternalDragOptions(drag);\n  }\n\n  if (actions.has('onWheel')) {\n    classes.push(WheelRecognizer);\n    internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel', _nativeHandlers);\n    mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  }\n\n  if (actions.has('onScroll')) {\n    classes.push(ScrollRecognizer);\n    internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll', _nativeHandlers);\n    mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  }\n\n  if (actions.has('onMove')) {\n    classes.push(MoveRecognizer);\n    internalHandlers.move = includeStartEndHandlers(handlers, 'onMove', _nativeHandlers);\n    mergedConfig.move = getInternalCoordinatesOptions(move);\n  }\n\n  if (actions.has('onPinch')) {\n    classes.push(PinchRecognizer);\n    internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch', _nativeHandlers);\n    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  }\n\n  if (actions.has('onHover')) {\n    if (!actions.has('onMove')) classes.push(MoveRecognizer);\n    internalHandlers.hover = handlers.onHover;\n    mergedConfig.hover = _extends({\n      enabled: true\n    }, hover);\n    delete _nativeHandlers.onHover;\n  }\n\n  return useRecognizers(internalHandlers, classes, mergedConfig, _nativeHandlers);\n}\n/**\r\n * @private\r\n *\r\n * This utility function will integrate start and end handlers into the regular\r\n * handler function by using first and last conditions.\r\n *\r\n * @param {UserHandlersPartial} handlers - the handlers function object\r\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\r\n * @returns\r\n */\n\n\nfunction includeStartEndHandlers(handlers, handlerKey, _nativeHandlers) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n  delete _nativeHandlers[handlerKey];\n  delete _nativeHandlers[startKey];\n  delete _nativeHandlers[endKey];\n\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  return fn;\n}\n\nexport { addV, rubberbandIfOutOfBounds, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":{"version":3,"mappings":"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","names":["addV","v1","v2","map","v","i","subV","calculateVelocity","delta","delta_t","len","Math","hypot","calculateVelocities","Array","length","fill","calculateDistance","movement","calculateDirection","calculateAllKinematics","velocities","velocity","distance","direction","sign","x","Number","getIntentionalDisplacement","threshold","abs","minMax","value","min","max","rubberband2","constant","pow","rubberband","dimension","Infinity","rubberbandIfOutOfBounds","position","noop","chainFns","fns","arguments","args","forEach","fn","def","array","isArray","withDefault","defaultIfUndefined","matchKeysFromObject","obj","matchingObject","o","Object","entries","key","valueFn","getInitialState","initialCommon","_active","_blocked","_intentional","_movement","_initial","_lastEventType","undefined","event","values","offset","lastOffset","initial","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","initialCoordinates","axis","xy","vxvy","initialDistanceAngle","da","vdva","origin","turns","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","buttons","down","shiftKey","altKey","metaKey","ctrlKey","drag","_isTap","_delayedEvent","tap","swipe","pinch","wheel","move","scroll","setListeners","add","el","listeners","options","action","eventName","supportsGestureEvents","GestureEvent","e","addListeners","removeListeners","getModifierKeys","getTouchEvents","changedTouches","getGenericEventData","touchEvents","getScrollEventValues","currentTarget","scrollX","scrollY","scrollLeft","scrollTop","getWheelEventValues","deltaX","deltaY","getPointerEventValues","clientX","clientY","WEBKIT_DISTANCE_SCALE_FACTOR","getWebkitGestureEventValues","scale","rotation","getTwoTouchesEventData","dx","dy","atan2","PI","Controller","_this","resetBindings","timeouts","clearTimeout","keys","windowListeners","removeWindowListeners","stateKey","bindings","domTarget","getDomTarget","domListeners","config","eventOptions","current","window","target","push","substr","toLowerCase","eventNames","eventNamesArray","captureString","fnsArray","addDomTargetListeners","clean","getBindings","useRecognizers","handlers","classes","nativeHandlers","controller","React","useMemo","bind","RecognizerClass","addBindings","nativeRefs","getBind","useEffect","Recognizer","callback","ms","setTimeout","addWindowListeners","state","vector","bounds","forceFlag","debounced","intentionalX","intentionalY","ingKey","mapStateValues","newMemo","handler","updateSharedState","sharedState","assign","updateGestureState","gestureState","getGenericPayload","isStartEvent","type","checkIntentionality","_state","getMovement","t0","t1","intentional","prevMovement","i0","i1","getInternalMovement","_m0","_m1","intentionalityCheck","_i0","_i1","_rubberband","enabled","CoordinatesRecognizer","_ix","_iy","intentionalMovement","absX","absY","configAxis","lockDirection","lockedIndex","getKinematics","movementDetection","kinematics","TAP_DISTANCE_THRESHOLD","SWIPE_MAX_ELAPSED_TIME","FILTER_REPEATED_EVENTS_DELAY","DragRecognizer","indexOf","pointer","isEventTypeTouch","delay","pointerId","setPointerCapture","releasePointerCapture","isTouch","dragListeners","onDragChange","onDragEnd","dragShouldStart","setPointers","persist","startDrag","genericEventData","onCancel","fireGestureHandler","vx","vy","mx","my","ix","iy","endState","swipeVelocity","svx","svy","swipeDistance","sx","sy","filterTaps","_CoordinatesRecognize","removePointers","requestAnimationFrame","startState","getStartGestureState","_this2","onDragStart","DEFAULT_DRAG_DELAY","DEFAULT_RUBBERBAND","DEFAULT_SWIPE_VELOCITY","DEFAULT_SWIPE_DISTANCE","defaultWindow","defaultCoordinatesOptions","getInternalGenericOptions","passive","_config$eventOptions$","capture","_config$eventOptions$2","_config$eventOptions$3","_config$enabled","restConfig","getInternalGestureOptions","gestureConfig","_gestureConfig$rubber","_gestureConfig$enable","_gestureConfig$initia","getInternalCoordinatesOptions","coordinatesConfig","_coordinatesConfig$bo","internalOptions","boundsArray","left","right","top","bottom","getInternalDistanceAngleOptions","distanceAngleConfig","distanceBounds","_distanceAngleConfig$","angleBounds","_distanceAngleConfig$2","getInternalDragOptions","dragConfig","dragOptions","_dragOptions$delay","_dragOptions$filterTa","internalCoordinatesOptions","useDrag","mergedConfig","DistanceAngleRecognizer","d","a","delta_a","newTurns","movement_d","movement_a","PinchRecognizer","pinchShouldStart","preventDefault","delta_d","prev_d","prev_a","wheelShouldRun","onWheelEnd","onWheelStart","onWheelChange","getWheelValuesFromEvent","process","env","NODE_ENV","console","warn","onGestureStart","onGestureChange","onGestureEnd","updateTouchData","onPinchStart","onPinchChange","onPinchEnd","onWheel","usePinch","WheelRecognizer","prevValues","getValuesFromEvent","useWheel","MoveRecognizer","moveShouldRun","onMoveEnd","onMoveStart","onMoveChange","hover","onMove","onPointerEnter","onPointerLeave","useMove","useHover","ScrollRecognizer","scrollShouldRun","onScrollEnd","onScrollStart","onScrollChange","onScroll","useScroll","useGesture","useState","Set","k","replace","actions","internalHandlers","_nativeHandlers","has","includeStartEndHandlers","onHover","handlerKey","startKey","endKey"],"sources":["/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/utils/math.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/utils/utils.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/utils/state.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/utils/event.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/Controller.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/hooks/useRecognizers.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/recognizers/Recognizer.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/recognizers/CoordinatesRecognizer.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/recognizers/DragRecognizer.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/utils/config.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/hooks/useDrag.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/recognizers/DistanceAngleRecognizer.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/recognizers/PinchRecognizer.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/hooks/usePinch.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/recognizers/WheelRecognizer.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/hooks/useWheel.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/recognizers/MoveRecognizer.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/hooks/useMove.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/hooks/useHover.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/recognizers/ScrollRecognizer.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/hooks/useScroll.ts","/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/react-use-gesture/src/hooks/useGesture.ts"],"sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n/**\n * Calculates velocity\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @param len the length of the delta vector\n * @returns velocity\n */\nexport function calculateVelocity(delta: number[], delta_t: number, len: number): number {\n  len = len || Math.hypot(...delta)\n  return delta_t ? len / delta_t : 0\n}\n\n/**\n * Calculates velocities vector\n * @template T the expected vector type\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @returns velocities vector\n */\nexport function calculateVelocities<T extends number[]>(delta: T, delta_t: number): T {\n  return (delta_t ? delta.map(v => v / delta_t) : Array(delta.length).fill(0)) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\n/**\n * Calculates direction\n * @template T the expected vector type\n * @param delta\n * @param len\n * @returns direction\n */\nexport function calculateDirection<T extends number[]>(delta: T, len?: number): T {\n  len = len || Math.hypot(...delta) || 1\n  return delta.map(v => v / len!) as T\n}\n\ninterface Kinematics<T extends number[]> {\n  velocities: T\n  velocity: number\n  distance: number\n  direction: T\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, delta_t: number): Kinematics<T> {\n  const len = Math.hypot(...delta)\n\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len),\n  }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla\n * :https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n\nexport function getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  const abs = Math.abs(movement)\n  return abs >= threshold ? sign(movement) * threshold : false\n}\n\nfunction minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n\n  if (position < min) {\n    return -rubberband(min - position, max - min, constant) + min\n  }\n  if (position > max) {\n    return rubberband(position - max, max - min, constant) + max\n  }\n  return position\n}\n","import { Fn, Vector2 } from '../types'\n\n// blank function\nexport function noop() {}\n// returns a function that chains all functions given as parameters\nexport const chainFns = (...fns: Fn[]): Fn => (...args: any[]) => fns.forEach(fn => fn(...args))\n\nexport const def = {\n  array: <T>(value: T | T[]): T[] => (Array.isArray(value) ? value : [value, value]),\n  withDefault: <T>(value: T | undefined, defaultIfUndefined: T): T => (value !== void 0 ? value : defaultIfUndefined),\n}\n\nexport function matchKeysFromObject<T extends object, K extends object>(obj: T, matchingObject: K): Partial<T> {\n  const o: Partial<T> = {}\n  Object.entries(obj).forEach(\n    ([key, value]) => (value !== void 0 || key in matchingObject) && (o[key as keyof T] = value)\n  )\n  return o\n}\n\nexport function valueFn(v: Vector2 | (() => Vector2)) {\n  return typeof v === 'function' ? v() : v\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2 } from '../types'\n\nexport function getInitialState(): State {\n  // common initial state for all gestures\n  const initialCommon: CommonGestureState = {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n  }\n\n  // initial state for coordinates-based gestures\n  const initialCoordinates: Coordinates = {\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  }\n\n  // initial state for distance and angle-based gestures (pinch)\n  const initialDistanceAngle: DistanceAngle = {\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    origin: undefined,\n    turns: 0,\n  }\n\n  // initial state object (used by the gesture controller)\n  return {\n    shared: {\n      hovering: false,\n      scrolling: false,\n      wheeling: false,\n      dragging: false,\n      moving: false,\n      pinching: false,\n      touches: 0,\n      buttons: 0,\n      down: false,\n      shiftKey: false,\n      altKey: false,\n      metaKey: false,\n      ctrlKey: false,\n    },\n    drag: {\n      ...initialCommon,\n      ...initialCoordinates,\n      _isTap: true,\n      _delayedEvent: false,\n      tap: false,\n      swipe: [0, 0],\n    },\n    pinch: { ...initialCommon, ...initialDistanceAngle },\n    wheel: { ...initialCommon, ...initialCoordinates },\n    move: { ...initialCommon, ...initialCoordinates },\n    scroll: { ...initialCommon, ...initialCoordinates },\n  }\n}\n","import { Fn, EventOptions, UseGestureEvent, Vector2, WebKitGestureEvent } from '../types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nexport const supportsTouchEvents = () => isBrowser && window.ontouchstart === null\n\nconst setListeners = (add: boolean) => (el: EventTarget, listeners: [string, Fn][], options: EventOptions): void => {\n  const action = add ? 'addEventListener' : 'removeEventListener'\n  listeners.forEach(([eventName, fn]) => el[action](eventName, fn, options))\n}\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport const addListeners = setListeners(true)\nexport const removeListeners = setListeners(false)\n\ninterface ModifierKeys {\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\n/**\n * Gets modifier keys from event\n * @param event\n * @returns modifier keys\n */\nexport function getModifierKeys(event: UseGestureEvent): ModifierKeys {\n  const { shiftKey, altKey, metaKey, ctrlKey } = event\n  return { shiftKey, altKey, metaKey, ctrlKey }\n}\n\nfunction getTouchEvents(event: UseGestureEvent) {\n  if ('touches' in event) {\n    const { touches, changedTouches } = event\n    return touches.length > 0 ? touches : changedTouches\n  }\n  return null\n}\n\nexport function getGenericEventData(event: React.MouseEvent | React.TouchEvent | React.PointerEvent) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const touchEvents = getTouchEvents(event)\n  const touches = (touchEvents && touchEvents.length) || 0\n  const down = touches > 0 || buttons > 0\n  return { touches, down, buttons, ...getModifierKeys(event) }\n}\n\ntype Values = { values: Vector2 }\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: UseGestureEvent): Values {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return { values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0] }\n}\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: UseGestureEvent<React.WheelEvent>): Values {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return { values: [deltaX, deltaY] }\n}\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(event: React.MouseEvent | React.TouchEvent | React.PointerEvent): Values {\n  const touchEvents = getTouchEvents(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return { values: [clientX, clientY] }\n}\n\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent): Values {\n  return { values: [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation] as Vector2 }\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent) {\n  const { touches } = event\n  const dx = touches[1].clientX - touches[0].clientX\n  const dy = touches[1].clientY - touches[0].clientY\n\n  const values: Vector2 = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI]\n  const origin: Vector2 = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2]\n\n  return { values, origin }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n} from './types'\nimport { getInitialState } from './utils/state'\nimport { addListeners, removeListeners } from './utils/event'\nimport { chainFns } from './utils/utils'\n\ntype GestureTimeouts = Partial<{ [stateKey in StateKey]: number }>\ntype WindowListeners = Partial<{ [stateKey in StateKey]: [string, Fn][] }>\ntype Bindings = Partial<{ [eventName in ReactEventHandlerKey]: Fn[] }>\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n *\n * @template BinderType the type the bind function should return\n */\nexport default class Controller {\n  public config!: InternalConfig\n  public handlers!: Partial<InternalHandlers>\n  public state: State = getInitialState() // state for all gestures\n  public timeouts: GestureTimeouts = {} // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n  private domListeners: [string, Fn][] = [] // when config.domTarget is set, we attach events directly to the dom\n  private windowListeners: WindowListeners = {} // keeps track of window listeners added by gestures (drag only at the moment)\n  private bindings: Bindings = {} // an object holding the handlers associated to the gestures\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    this.resetBindings()\n    Object.values(this.timeouts).forEach(clearTimeout)\n    Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(stateKey as StateKey))\n  }\n\n  /**\n   * Function run every time the bind function is run (ie on every render).\n   * Resets the binding object and remove dom listeners attached to config.domTarget\n   */\n  public resetBindings = (): void => {\n    this.bindings = {}\n    const domTarget = this.getDomTarget()\n    if (domTarget) {\n      removeListeners(domTarget, this.domListeners, this.config.eventOptions)\n      this.domListeners = []\n    }\n  }\n\n  /**\n   * Returns the domTarget element and parses a ref if needed.\n   */\n  private getDomTarget = (): EventTarget | null | undefined => {\n    const { domTarget } = this.config\n    return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n  }\n\n  /**\n   * Commodity function to let recognizers simply add listeners to config.window.\n   */\n  public addWindowListeners = (stateKey: StateKey, listeners: [string, Fn][]): void => {\n    if (!this.config.window) return\n    // we use this.windowListeners to keep track of the listeners we add\n    this.windowListeners[stateKey] = listeners\n    addListeners(this.config.window, listeners, this.config.eventOptions)\n  }\n\n  /**\n   * Commodity function to let recognizers simply remove listeners to config.window.\n   */\n  public removeWindowListeners = (stateKey: StateKey): void => {\n    if (!this.config.window) return\n    const listeners = this.windowListeners[stateKey]\n    if (listeners) {\n      removeListeners(this.config.window, listeners, this.config.eventOptions)\n      delete this.windowListeners[stateKey]\n    }\n  }\n\n  /**\n   * When config.domTarget is set, this function will add dom listeners to it\n   */\n  public addDomTargetListeners = (target: EventTarget): void => {\n    /** We iterate on the entries of this.binding for each event, then we chain\n     * the array of functions mapped to it and push them to this.domListeners\n     */\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...(fns as Fn[]))])\n    })\n\n    addListeners(target, this.domListeners, this.config.eventOptions)\n  }\n\n  /**\n   * this.bindings is an object which keys match ReactEventHandlerKeys.\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n   * that key.\n   */\n  public addBindings = (eventNames: ReactEventHandlerKey | ReactEventHandlerKey[], fn: Fn): void => {\n    const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames\n    eventNamesArray.forEach(eventName => {\n      if (this.bindings[eventName]) this.bindings[eventName]!.push(fn)\n      else this.bindings[eventName] = [fn]\n    })\n  }\n\n  /**\n   * getBindings will return an object that will be bound by users\n   * to the react component they want to interact with.\n   */\n  public getBindings = (): ReactEventHandlers => {\n    const bindings: ReactEventHandlers = {}\n    const { captureString } = this.config\n\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      const fnsArray = Array.isArray(fns) ? fns : [fns]\n      const key = (event + captureString) as ReactEventHandlerKey\n      bindings[key] = chainFns(...(fnsArray as Fn[]))\n    })\n\n    return bindings\n  }\n\n  public getBind = () => {\n    // If config.domTarget is set we add event listeners to it and return the clean function.\n    if (this.config.domTarget) {\n      const domTarget = this.getDomTarget()\n      domTarget && this.addDomTargetListeners(domTarget)\n      return this.clean\n    }\n\n    // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n    return this.getBindings()\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  RecognizerClasses,\n  GenericOptions,\n  NativeHandlersPartial,\n  ReactEventHandlerKey,\n  Fn,\n} from '../types'\n/**\n * @private\n *\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param {Partial<InternalHandlers>} handlers\n * @param {RecognizerClasses} classes\n * @param {InternalConfig} config\n * @param {NativeHandlersPartial} nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  classes: RecognizerClasses,\n  config: InternalConfig,\n  nativeHandlers?: NativeHandlersPartial\n): (...args: any[]) => HookReturnType<Config> {\n  // The gesture controller keeping track of all gesture states\n  const controller = React.useMemo(() => {\n    const current = new Controller()\n\n    /**\n     * The bind function will create gesture recognizers and return the right\n     * bind object depending on whether `domTarget` was specified in the config object.\n     */\n    const bind = (...args: any[]) => {\n      current.resetBindings()\n      for (let RecognizerClass of classes) {\n        new RecognizerClass(current, args).addBindings()\n      }\n\n      // we also add event bindings for native handlers\n      if (controller.nativeRefs) {\n        for (let eventName in controller.nativeRefs)\n          current.addBindings(\n            eventName as ReactEventHandlerKey,\n            // @ts-ignore we're cheating when it comes to event type :(\n            controller.nativeRefs[eventName] as Fn\n          )\n      }\n\n      return current.getBind() as HookReturnType<Config>\n    }\n\n    return { nativeRefs: nativeHandlers, current, bind }\n  }, [])\n\n  // We reassign the config and handlers to the controller on every render.\n  controller.current!.config = config\n  controller.current!.handlers = handlers\n  // We assign nativeHandlers, otherwise they won't be refreshed on the next render.\n  controller.nativeRefs = nativeHandlers\n\n  // Run controller clean functions on unmount.\n  React.useEffect(() => controller.current!.clean, [])\n\n  return controller.bind\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  Fn,\n  UseGestureEvent,\n  IngKey,\n  InternalConfig,\n  GestureState,\n  PartialGestureState,\n  Vector2,\n  FalseOrNumber,\n  FullGestureState,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { subV, addV, getIntentionalDisplacement, rubberbandIfOutOfBounds } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\n/**\n * @private\n * Recognizer abstract class.\n *\n * @protected\n * @abstract\n * @type {StateKey<T>} whether the Recognizer should deal with coordinates or distance / angle\n */\nexport default abstract class Recognizer<T extends StateKey> {\n  protected abstract ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(\n    protected readonly stateKey: T,\n    protected readonly controller: Controller,\n    protected readonly args: any[] = []\n  ) {}\n\n  // Returns the gesture config\n  protected get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  protected get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  protected get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  protected get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  // Conveninence method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Conveninence method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  // Convenience method to add window listeners for a given gesture\n  protected addWindowListeners = (listeners: [string, Fn][]) => {\n    this.controller.addWindowListeners(this.stateKey, listeners)\n  }\n\n  // Convenience method to remove window listeners for a given gesture\n  protected removeWindowListeners = () => {\n    this.controller.removeWindowListeners(this.stateKey)\n  }\n\n  /**\n   * Utility function to get kinematics of the gesture.\n   *\n   * @abstract\n   * @values - values we want to calculate the kinematics from\n   * @event - the pointer event\n   * @returns - set of values including movement, velocity, velocities, distance and direction\n   */\n  protected abstract getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T>\n\n  protected abstract mapStateValues(state: GestureState<T>): PartialGestureState<T>\n\n  // Should return the bindings to be added for a given gesture\n  public abstract addBindings(): void\n\n  /**\n   * Returns a generic, common payload for all gestures from an event.\n   *\n   * @param {UseGestureEvent} event\n   * @param {boolean} [isStartEvent]\n   * @returns - the generic gesture payload\n   */\n  protected getGenericPayload(event: UseGestureEvent, isStartEvent?: boolean) {\n    const { timeStamp, type } = event\n    const { values, startTime } = this.state\n\n    return {\n      _lastEventType: type,\n      event,\n      timeStamp,\n      elapsedTime: isStartEvent ? 0 : timeStamp - startTime!,\n      args: this.args,\n      previous: values,\n    }\n  }\n  /**\n   * Returns the reinitialized start state for the gesture.\n   * Should be common to all gestures.\n   *\n   * @param {Vector2} values\n   * @param {UseGestureEvent} event\n   * @returns - the start state for the gesture\n   */\n  protected getStartGestureState = (values: Vector2, event: UseGestureEvent) => {\n    return {\n      ...getInitialState()[this.stateKey],\n      _active: true,\n      values,\n      initial: values,\n      offset: this.state.offset,\n      lastOffset: this.state.offset,\n      startTime: event.timeStamp,\n    }\n  }\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    _state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2, state: GestureState<T> = this.state): PartialGestureState<T> {\n    const { initial, threshold, rubberband } = this.config\n\n    const [t0, t1] = threshold\n\n    const { _initial, _active, _intentional: intentional, lastOffset, movement: prevMovement } = state\n    let [i0, i1] = intentional\n\n    const [_m0, _m1] = this.getInternalMovement(values, state)\n\n    /**\n     * For both dimensions of the gesture, check its intentionality on each frame.\n     */\n    if (i0 === false) {\n      i0 = getIntentionalDisplacement(_m0, t0)\n    }\n    if (i1 === false) {\n      i1 = getIntentionalDisplacement(_m1, t1)\n    }\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], [_m0, _m1], state)\n\n    const { _intentional, _blocked } = intentionalityCheck\n    const [_i0, _i1] = _intentional!\n    const _movement = [_m0, _m1]\n\n    if (_i0 !== false && intentional[0] === false) _initial[0] = valueFn(initial)[0]\n    if (_i1 !== false && intentional[1] === false) _initial[1] = valueFn(initial)[1]\n\n    /**\n     * If the gesture has been blocked (from gesture specific checkIntentionality),\n     * stop right there.\n     */\n    if (_blocked) return { ...intentionalityCheck, _movement, delta: [0, 0] }\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement = [\n      _i0 !== false ? _m0 - _i0 : valueFn(initial)[0],\n      _i1 !== false ? _m1 - _i1 : valueFn(initial)[1],\n    ] as Vector2\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = this.rubberband(addV(movement, _initial), _rubberband) // rubberbanded movement\n\n    return {\n      ...intentionalityCheck,\n      _initial,\n      _movement,\n      movement,\n      offset: this.rubberband(offset, _rubberband), // rubberbanded offset\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Runs rubberband on a vector\n  protected rubberband = (vector: Vector2, rubberband: Vector2): Vector2 => {\n    const { bounds } = this.config\n\n    /**\n     * [x, y]: [rubberband(x, min, max), rubberband(y, min, max)]\n     */\n    return vector.map((v, i) => rubberbandIfOutOfBounds(v, bounds[i][0], bounds[i][1], rubberband[i])) as Vector2\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n    this.removeWindowListeners()\n  }\n\n  /**\n   * Fires the gesture handler\n   *\n   * @param {boolean} [forceFlag] - if true, then the handler will fire even if the gesture is not intentional\n   */\n  protected fireGestureHandler = (forceFlag?: boolean): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't do fire the handler.\n    const [intentionalX, intentionalY] = this.state._intentional\n    if (!forceFlag && intentionalX === false && intentionalY === false) return null\n\n    const { _active, active } = this.state\n\n    this.state.active = _active\n    this.state.first = _active && !active // `first` is true when the gesture becomes active\n    this.state.last = active && !_active // `last` is true when the gesture becomes inactive\n\n    this.controller.state.shared[this.ingKey] = _active // Sets dragging, pinching, etc. to the gesture active state\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n    } as FullGestureState<T>\n\n    // @ts-ignore\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    // Cleans the gesture when the gesture is no longer active.\n    if (!_active) this.clean()\n\n    return state\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, FalseOrNumber, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n * @abstract\n * @class CoordinatesRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   *\n   * @param {[FalseOrNumber, FalseOrNumber]} _intentional\n   * @param {Vector2} _movement\n   * @param {PartialGestureState<T>} state\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    let [_ix, _iy] = _intentional\n    const intentionalMovement = _ix !== false || _iy !== false\n    let { axis } = state\n    let _blocked = false\n\n    // If the movement is intentional, we can compute axis.\n    if (intentionalMovement) {\n      const [absX, absY] = _movement.map(Math.abs)\n\n      const { axis: configAxis, lockDirection } = this.config\n\n      // We make sure we only set axis value if it hadn't been detected before.\n      axis = axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n      if (!!configAxis || lockDirection) {\n        if (!!axis) {\n          // If the detected axis doesn't match the config axis we block the gesture\n          if (!!configAxis && axis !== configAxis) _blocked = true\n          else {\n            // Otherwise we prevent the gesture from updating the unwanted axis.\n            const lockedIndex = axis === 'x' ? 1 : 0\n            _intentional![lockedIndex] = false\n          }\n        } else {\n          // Until we've detected the axis, we prevent the hnadler from updating.\n          _intentional = [false, false]\n        }\n      }\n    }\n\n    return { _intentional, _blocked, axis } as PartialGestureState<T>\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { _blocked, delta, movement } = movementDetection\n\n    if (_blocked) return movementDetection\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { xy: state.values, vxvy: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { PointerEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, Fn, IngKey } from '../types'\nimport { noop } from '../utils/utils'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { calculateDistance, sign } from '../utils/math'\n\nconst TAP_DISTANCE_THRESHOLD = 3\nconst SWIPE_MAX_ELAPSED_TIME = 220\nconst FILTER_REPEATED_EVENTS_DELAY = 200\n\nexport default class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  ingKey = 'dragging' as IngKey\n  wasTouch = false\n\n  constructor(controller: Controller, args: any[]) {\n    super('drag', controller, args)\n  }\n\n  private isEventTypeTouch = (type?: string) => !!type && type.indexOf('touch') === 0\n\n  private dragShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    const { _lastEventType } = this.state\n    /**\n     * This tries to filter out mouse events triggered by touch screens\n     * */\n    // If the previous gesture was touch-based, and the current one is mouse based,\n    // this means that we might be dealing with mouse simulated events if they're close to\n    // each other. We're only doing this check when we're not using pointer events.\n    if (\n      !this.controller.config.pointer &&\n      this.isEventTypeTouch(_lastEventType) &&\n      !this.isEventTypeTouch(event.type)\n    ) {\n      const delay = Math.abs(event.timeStamp - this.state.startTime)\n      if (delay < FILTER_REPEATED_EVENTS_DELAY) return false\n    }\n\n    return this.enabled && touches < 2\n  }\n\n  private setPointers = (event: UseGestureEvent<PointerEvent>) => {\n    const { currentTarget, pointerId } = event\n    if (currentTarget) currentTarget.setPointerCapture(pointerId)\n    this.updateGestureState({ currentTarget, pointerId })\n  }\n\n  private removePointers = () => {\n    const { currentTarget, pointerId } = this.state\n    if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\n  }\n\n  private setListeners = (isTouch: boolean) => {\n    this.removeWindowListeners()\n    const dragListeners: [string, Fn][] = isTouch\n      ? [\n          ['touchmove', this.onDragChange],\n          ['touchend', this.onDragEnd],\n          ['touchcancel', this.onDragEnd],\n        ]\n      : [\n          ['mousemove', this.onDragChange],\n          ['mouseup', this.onDragEnd],\n        ]\n    this.addWindowListeners(dragListeners)\n  }\n\n  onDragStart = (event: UseGestureEvent): void => {\n    if (!this.dragShouldStart(event)) return\n    // if pointers events\n    if (this.controller.config.pointer) this.setPointers(event as PointerEvent)\n    else this.setListeners(this.isEventTypeTouch(event.type))\n\n    if (this.config.delay > 0) {\n      this.state._delayedEvent = true\n      if (typeof event.persist === 'function') event.persist()\n      this.setTimeout(() => this.startDrag(event), this.config.delay)\n    } else {\n      this.startDrag(event)\n    }\n  }\n\n  startDrag(event: UseGestureEvent) {\n    const { values } = getPointerEventValues(event)\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: UseGestureEvent): void => {\n    const { canceled } = this.state\n    if (canceled) return\n\n    if (!this.state._active) {\n      if (this.state._delayedEvent) {\n        this.clearTimeout()\n        this.startDrag(event)\n      }\n      return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    if (!genericEventData.down) {\n      this.onDragEnd(event)\n      return\n    }\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    let { _isTap } = this.state\n    if (_isTap && calculateDistance(kinematics._movement!) >= TAP_DISTANCE_THRESHOLD) _isTap = false\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      _isTap,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: UseGestureEvent): void => {\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n\n    const {\n      _isTap,\n      values,\n      velocities: [vx, vy],\n      movement: [mx, my],\n      _intentional: [ix, iy],\n    } = this.state\n\n    const endState = {\n      ...this.getGenericPayload(event),\n      ...this.getMovement(values),\n    }\n\n    const { elapsedTime } = endState\n\n    const {\n      swipeVelocity: [svx, svy],\n      swipeDistance: [sx, sy],\n    } = this.config\n\n    const swipe: [number, number] = [0, 0]\n\n    if (elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateGestureState({\n      event,\n      ...endState,\n      tap: _isTap,\n      swipe,\n    })\n    this.fireGestureHandler(this.config.filterTaps && this.state._isTap)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._delayedEvent = false\n\n    if (this.controller.config.pointer) this.removePointers()\n  }\n\n  onCancel = (): void => {\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      this.controller.addBindings('onPointerDown', this.onDragStart)\n      this.controller.addBindings('onPointerMove', this.onDragChange)\n      this.controller.addBindings(['onPointerUp', 'onPointerCancel'], this.onDragEnd)\n    } else {\n      this.controller.addBindings(['onTouchStart', 'onMouseDown'], this.onDragStart)\n    }\n  }\n}\n","import { def, matchKeysFromObject } from './utils'\nimport {\n  Vector2,\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  Tuple,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  CoordinatesOptions,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n} from '../types'\n\nconst DEFAULT_DRAG_DELAY = 180\nconst DEFAULT_RUBBERBAND = 0.15\nconst DEFAULT_SWIPE_VELOCITY = 0.5\nconst DEFAULT_SWIPE_DISTANCE = 60\n\nconst defaultWindow = typeof window !== 'undefined' ? window : undefined\n\nconst defaultCoordinatesOptions: CoordinatesOptions = {\n  lockDirection: false,\n  axis: undefined,\n  bounds: undefined,\n}\n\n/**\n * @private\n *\n * Returns the internal generic option object.\n *\n * @param {Partial<GenericOptions>} [config={}]\n * @returns {InternalGenericOptions}\n */\nexport function getInternalGenericOptions(config: Partial<GenericOptions> = {}): InternalGenericOptions {\n  let {\n    eventOptions: { passive = true, capture = false, pointer = false } = {},\n    window = defaultWindow,\n    domTarget = undefined,\n    enabled = true,\n    ...restConfig\n  } = config\n\n  return {\n    ...restConfig,\n    enabled,\n    domTarget,\n    window,\n    // passive is always true if there's no domTarget\n    eventOptions: { passive: !domTarget || !!passive, capture: !!capture },\n    captureString: capture ? 'Capture' : '',\n    pointer: !!pointer,\n  }\n}\n\nexport function getInternalGestureOptions(gestureConfig: Partial<GestureOptions>): InternalGestureOptions {\n  let { threshold = undefined, rubberband = 0, enabled = true, initial = [0, 0] } = gestureConfig\n\n  if (typeof rubberband === 'boolean') rubberband = rubberband ? DEFAULT_RUBBERBAND : 0\n  if (threshold === void 0) threshold = 0\n\n  return {\n    enabled,\n    initial,\n    threshold: def.array(threshold) as Vector2,\n    rubberband: def.array(rubberband) as Vector2,\n  }\n}\n\nexport function getInternalCoordinatesOptions(coordinatesConfig: CoordinatesConfig = {}): InternalCoordinatesOptions {\n  const { axis, lockDirection, bounds = {}, ...internalOptions } = coordinatesConfig\n\n  const boundsArray = [\n    [def.withDefault(bounds.left, -Infinity), def.withDefault(bounds.right, Infinity)],\n    [def.withDefault(bounds.top, -Infinity), def.withDefault(bounds.bottom, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    ...defaultCoordinatesOptions,\n    ...matchKeysFromObject({ axis, lockDirection }, coordinatesConfig),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDistanceAngleOptions(\n  distanceAngleConfig: DistanceAngleConfig = {}\n): InternalDistanceAngleOptions {\n  const { distanceBounds = {}, angleBounds = {}, ...internalOptions } = distanceAngleConfig\n\n  const boundsArray = [\n    [def.withDefault(distanceBounds.min, -Infinity), def.withDefault(distanceBounds.max, Infinity)],\n    [def.withDefault(angleBounds.min, -Infinity), def.withDefault(angleBounds.max, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDragOptions(dragConfig: DragConfig = {}): InternalDragOptions {\n  let { enabled, threshold, bounds, rubberband, initial, ...dragOptions } = dragConfig\n  let {\n    swipeVelocity = DEFAULT_SWIPE_VELOCITY,\n    swipeDistance = DEFAULT_SWIPE_DISTANCE,\n    delay = false,\n    filterTaps = false,\n    axis,\n    lockDirection,\n  } = dragOptions\n\n  if (threshold === void 0) {\n    threshold = Math.max(0, filterTaps ? 3 : 0, lockDirection || axis ? 1 : 0)\n  } else {\n    filterTaps = true\n  }\n\n  const internalCoordinatesOptions = getInternalCoordinatesOptions(\n    matchKeysFromObject({ enabled, threshold, bounds, rubberband, axis, lockDirection, initial }, dragConfig)\n  )\n\n  return {\n    ...internalCoordinatesOptions,\n    filterTaps: filterTaps || internalCoordinatesOptions.threshold[0] + internalCoordinatesOptions.threshold[1] > 0,\n    swipeVelocity: def.array(swipeVelocity) as Vector2,\n    swipeDistance: def.array(swipeDistance) as Vector2,\n    delay: typeof delay === 'number' ? delay : delay ? DEFAULT_DRAG_DELAY : 0,\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseDragConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDragOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Drag hook.\n *\n * @param {Handler<'drag'>} handler - the function fired every time the drag gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and drag options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useDrag<Config extends UseDragConfig>(\n  handler: Handler<'drag'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...drag } = config as UseDragConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    drag: getInternalDragOptions(drag),\n  }\n\n  return useRecognizers<Config>({ drag: handler }, [DragRecognizer], mergedConfig)\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n * @abstract\n * @class DistanceAngleRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement([d, a]: [number, number?], state: GestureState<T>): Vector2 {\n    const { values: da, turns, initial } = state\n\n    // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n    a = a !== void 0 ? a : da[1]\n\n    let delta_a = a - da[1]\n\n    /**\n     * The angle value might jump from 179deg to -179deg when we actually want to\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\n     */\n    const newTurns = Math.abs(delta_a) > 270 ? turns + sign(delta_a) : turns\n\n    // we update the angle difference to its corrected value\n\n    const movement_d = d - initial[0]\n    const movement_a = a - 360 * newTurns - initial[1]\n    return [movement_d, movement_a]\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp, initial } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { delta, movement } = movementDetection\n\n    const turns = (values[1] - movement![1] - initial[1]) / 360\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      turns,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { da: state.values, vdva: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { TouchEvent, WheelEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey, Vector2, WebKitGestureEvent } from '../types'\nimport { noop } from '../utils/utils'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventData,\n  getWheelEventValues,\n  supportsGestureEvents,\n  getWebkitGestureEventValues,\n} from '../utils/event'\n\nexport default class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  ingKey = 'pinching' as IngKey\n\n  constructor(controller: Controller, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  private pinchShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    return this.enabled && touches === 2\n  }\n\n  onPinchStart = (event: UseGestureEvent<TouchEvent>) => {\n    if (!this.pinchShouldStart(event)) return\n\n    const { values, origin } = getTwoTouchesEventData(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: UseGestureEvent<TouchEvent>): void => {\n    const { canceled, timeStamp, _active } = this.state\n    if (canceled || !_active) return\n    const genericEventData = getGenericEventData(event)\n    if (genericEventData.touches !== 2 || event.timeStamp === timeStamp) return\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin } = getTwoTouchesEventData(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchEnd = (event: UseGestureEvent): void => {\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    this.state._active = false\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.updateSharedState({ down: false, touches: 0 })\n\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const { values } = getWebkitGestureEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getWebkitGestureEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    event.preventDefault()\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  updateTouchData = (event: UseGestureEvent<TouchEvent>): void => {\n    if (!this.enabled || event.touches.length !== 2 || !this.state._active) return\n    const { origin } = getTwoTouchesEventData(event)\n    this.state.origin = origin\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const {\n      values: [, delta_d],\n    } = getWheelEventValues(event)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [0, delta_d] as Vector2,\n    }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (!this.controller.config.eventOptions.passive) {\n      event.preventDefault()\n    } else if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && supportsGestureEvents()) {\n      this.controller.addBindings('onGestureStart', this.onGestureStart)\n      this.controller.addBindings('onGestureChange', this.onGestureChange)\n      this.controller.addBindings(['onGestureEnd', 'onTouchCancel'], this.onGestureEnd)\n      this.controller.addBindings(['onTouchStart', 'onTouchMove'], this.updateTouchData)\n    } else {\n      this.controller.addBindings('onTouchStart', this.onPinchStart)\n      this.controller.addBindings('onTouchMove', this.onPinchChange)\n      this.controller.addBindings(['onTouchEnd', 'onTouchCancel'], this.onPinchEnd)\n\n      this.controller.addBindings('onWheel', this.onWheel)\n    }\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UsePinchConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDistanceAngleOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Pinch hook.\n *\n * @param {Handler<'pinch'>} handler - the function fired every time the pinch gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and pinch options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function usePinch<Config extends UsePinchConfig>(\n  handler: Handler<'pinch'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...pinch } = config as UsePinchConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    pinch: getInternalDistanceAngleOptions(pinch),\n  }\n\n  return useRecognizers<Config>({ pinch: handler }, [PinchRecognizer], mergedConfig)\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  ingKey = 'wheeling' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('wheel', controller, args)\n  }\n\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return false\n    return this.enabled\n  }\n\n  private getValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const { values: prevValues } = this.state\n    const { values } = getWheelEventValues(event)\n    return { values: addV(values, prevValues) }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values } = this.getValuesFromEvent(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = this.getValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onWheel', this.onWheel)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseWheelConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Wheel hook.\n *\n * @param {Handler<'wheel'>} handler - the function fired every time the wheel gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and wheel options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useWheel<Config extends UseWheelConfig>(\n  handler: Handler<'wheel'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...wheel } = config as UseWheelConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    wheel: getInternalCoordinatesOptions(wheel),\n  }\n\n  return useRecognizers<Config>({ wheel: handler }, [WheelRecognizer], mergedConfig)\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\n\nexport default class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  ingKey = 'moving' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('move', controller, args)\n  }\n\n  private moveShouldRun = () => {\n    return this.enabled\n  }\n\n  onMove = (event: UseGestureEvent): void => {\n    if (!this.moveShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: UseGestureEvent): void => {\n    const { values } = getPointerEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.state._active = false\n\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  onPointerEnter = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event, true),\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event),\n        values,\n        active: false,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onPointerMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onPointerEnter', this.onPointerEnter)\n        this.controller.addBindings('onPointerLeave', this.onPointerLeave)\n      }\n    } else {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onMouseMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onMouseEnter', this.onPointerEnter)\n        this.controller.addBindings('onMouseLeave', this.onPointerLeave)\n      }\n    }\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseMoveConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Move hook.\n *\n * @param {Handler<'move'>} handler - the function fired every time the move gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and move options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useMove<Config extends UseMoveConfig>(\n  handler: Handler<'move'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...move } = config as UseMoveConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    move: getInternalCoordinatesOptions(move),\n  }\n\n  return useRecognizers<Config>({ move: handler }, [MoveRecognizer], mergedConfig)\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseHoverConfig } from '../types'\nimport { getInternalGenericOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Hover hook.\n *\n * @param {Handler<'hover'>} handler - the function fired every time the hover gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and hover options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useHover<Config extends UseHoverConfig>(\n  handler: Handler<'hover'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...hover } = config as UseHoverConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    hover: { enabled: true, ...hover },\n  }\n\n  return useRecognizers<Config>({ hover: handler }, [MoveRecognizer], mergedConfig)\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  ingKey = 'scrolling' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('scroll', controller, args)\n  }\n\n  private scrollShouldRun = () => {\n    return this.enabled\n  }\n\n  onScroll = (event: UseGestureEvent): void => {\n    if (!this.scrollShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onScrollEnd)\n\n    if (!this.state._active) this.onScrollStart(event)\n    else this.onScrollChange(event)\n  }\n\n  onScrollStart = (event: UseGestureEvent): void => {\n    const { values } = getScrollEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getScrollEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onScroll', this.onScroll)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseScrollConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Scroll hook.\n *\n * @param {Handler<'scroll'>} handler - the function fired every time the scroll gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and scroll options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useScroll<Config extends UseScrollConfig>(\n  handler: Handler<'scroll'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...scroll } = config as UseScrollConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    scroll: getInternalCoordinatesOptions(scroll),\n  }\n\n  return useRecognizers<Config>({ scroll: handler }, [ScrollRecognizer], mergedConfig)\n}\n","import React from 'react'\nimport useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport {\n  getInternalGenericOptions,\n  getInternalDragOptions,\n  getInternalCoordinatesOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\nimport {\n  InternalConfig,\n  HandlerKey,\n  UserHandlersPartial,\n  InternalHandlers,\n  UserHandlers,\n  RecognizerClasses,\n  UseGestureConfig,\n  HookReturnType,\n} from '../types'\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {UserHandlersPartial} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<Config extends UseGestureConfig>(\n  handlers: UserHandlersPartial,\n  config: UseGestureConfig = {}\n): (...args: any[]) => HookReturnType<Config> {\n  /**\n   * If handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n   * actions will include 'onDrag' and 'onMove.\n   */\n  const [actions] = React.useState(() => new Set(Object.keys(handlers).map(k => k.replace(/End|Start/, ''))))\n\n  /**\n   * Here we compute the derived internal config based on the provided config object.\n   * We decompose the config into its generic and gesture options and compute each.\n   * TODO: this is currently done on every render!\n   */\n  const { drag, wheel, move, scroll, pinch, hover, ...restConfig } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions(restConfig)\n\n  const classes: RecognizerClasses = []\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  // will hold reference to native handlers such as onClick, onMouseDown, etc.\n  const _nativeHandlers = { ...handlers }\n\n  if (actions.has('onDrag')) {\n    classes.push(DragRecognizer)\n    internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag', _nativeHandlers)\n    mergedConfig.drag = getInternalDragOptions(drag)\n  }\n  if (actions.has('onWheel')) {\n    classes.push(WheelRecognizer)\n    internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel', _nativeHandlers)\n    mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  }\n  if (actions.has('onScroll')) {\n    classes.push(ScrollRecognizer)\n    internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll', _nativeHandlers)\n    mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  }\n  if (actions.has('onMove')) {\n    classes.push(MoveRecognizer)\n    internalHandlers.move = includeStartEndHandlers(handlers, 'onMove', _nativeHandlers)\n    mergedConfig.move = getInternalCoordinatesOptions(move)\n  }\n  if (actions.has('onPinch')) {\n    classes.push(PinchRecognizer)\n    internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch', _nativeHandlers)\n    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  }\n  if (actions.has('onHover')) {\n    if (!actions.has('onMove')) classes.push(MoveRecognizer)\n    internalHandlers.hover = handlers.onHover\n    mergedConfig.hover = { enabled: true, ...hover }\n    delete _nativeHandlers.onHover\n  }\n\n  return useRecognizers<Config>(internalHandlers, classes, mergedConfig, _nativeHandlers)\n}\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\nfunction includeStartEndHandlers(\n  handlers: UserHandlersPartial,\n  handlerKey: HandlerKey,\n  _nativeHandlers: UserHandlersPartial\n) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  delete _nativeHandlers[handlerKey]\n  delete _nativeHandlers[startKey]\n  delete _nativeHandlers[endKey]\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n"]},"metadata":{},"sourceType":"module"}