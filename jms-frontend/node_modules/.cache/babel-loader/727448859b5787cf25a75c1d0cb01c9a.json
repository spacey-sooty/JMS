{"ast":null,"code":"var _toConsumableArray = require(\"/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _slicedToArray = require(\"/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"/home/spacey_sooty/Documents/projects/JMS/jms-frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nmodule.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // define __esModule on exports\n\n  /******/\n\n\n  __webpack_require__.r = function (exports) {\n    /******/\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/\n      Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n\n  /******/\n  // create a fake namespace object\n\n  /******/\n  // mode & 1: value is a module id, require it\n\n  /******/\n  // mode & 2: merge all properties of value into the ns\n\n  /******/\n  // mode & 4: return value when already ns object\n\n  /******/\n  // mode & 8|1: behave like require\n\n  /******/\n\n\n  __webpack_require__.t = function (value, mode) {\n    /******/\n    if (mode & 1) value = __webpack_require__(value);\n    /******/\n\n    if (mode & 8) return value;\n    /******/\n\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n\n    var ns = Object.create(null);\n    /******/\n\n    __webpack_require__.r(ns);\n    /******/\n\n\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n\n    if (mode & 2 && typeof value != 'string') for (var key in value) {\n      __webpack_require__.d(ns, key, function (key) {\n        return value[key];\n      }.bind(null, key));\n    }\n    /******/\n\n    return ns;\n    /******/\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = 19);\n  /******/\n}\n/************************************************************************/\n\n/******/\n([\n/* 0 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"react\");\n  /***/\n},\n/* 1 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"papaparse\");\n  /***/\n},\n/* 2 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"react-dropzone\");\n  /***/\n},\n/* 3 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"react-use-gesture\");\n  /***/\n},\n/* 4 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"react-dom\");\n  /***/\n},\n/* 5 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 6 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 7 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 8 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 9 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 10 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 11 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 12 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 13 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 14 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 15 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 16 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 17 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 18 */\n\n/***/\nfunction (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n  /***/\n},\n/* 19 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\"; // ESM COMPAT FLAG\n\n  __webpack_require__.r(__webpack_exports__); // EXPORTS\n\n\n  __webpack_require__.d(__webpack_exports__, \"ImporterField\", function () {\n    return (\n      /* reexport */\n      ImporterField\n    );\n  });\n\n  __webpack_require__.d(__webpack_exports__, \"Importer\", function () {\n    return (\n      /* reexport */\n      Importer_Importer\n    );\n  });\n\n  __webpack_require__.d(__webpack_exports__, \"enUS\", function () {\n    return (\n      /* reexport */\n      enUS\n    );\n  });\n\n  __webpack_require__.d(__webpack_exports__, \"deDE\", function () {\n    return (\n      /* reexport */\n      deDE\n    );\n  }); // CONCATENATED MODULE: ./src/components/ImporterProps.ts\n  // EXTERNAL MODULE: external \"react\"\n\n\n  var external_react_ = __webpack_require__(0);\n\n  var external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_); // EXTERNAL MODULE: external \"papaparse\"\n\n\n  var external_papaparse_ = __webpack_require__(1);\n\n  var external_papaparse_default = /*#__PURE__*/__webpack_require__.n(external_papaparse_); // CONCATENATED MODULE: ./src/parser.ts\n\n\n  var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function (resolve) {\n        resolve(value);\n      });\n    }\n\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n\n  var PREVIEW_ROW_COUNT = 5; // polyfill as implemented in https://github.com/eligrey/Blob.js/blob/master/Blob.js#L653\n  // (this is for Safari pre v14.1)\n\n  function streamForBlob(blob) {\n    if (blob.stream) {\n      return blob.stream();\n    }\n\n    var res = new Response(blob);\n\n    if (res.body) {\n      return res.body;\n    }\n\n    throw new Error('This browser does not support client-side file reads');\n  } // incredibly cheap wrapper exposing a subset of stream.Readable interface just for PapaParse usage\n  // @todo chunk size\n\n\n  function nodeStreamWrapper(stream, encoding) {\n    var dataHandler = null;\n    var endHandler = null;\n    var errorHandler = null;\n    var isStopped = false;\n    var pausePromise = null;\n    var pauseResolver = null;\n\n    function runReaderPump() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var streamReader, decoder, _yield$streamReader$r, done, value, lastChunkString, chunkString;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return Promise.resolve();\n\n              case 2:\n                streamReader = stream.getReader();\n                decoder = new TextDecoder(encoding); // this also strips BOM by default\n\n                _context.prev = 4;\n\n              case 5:\n                if (isStopped) {\n                  _context.next = 25;\n                  break;\n                }\n\n                _context.next = 8;\n                return streamReader.read();\n\n              case 8:\n                _yield$streamReader$r = _context.sent;\n                done = _yield$streamReader$r.done;\n                value = _yield$streamReader$r.value;\n\n                if (!pausePromise) {\n                  _context.next = 14;\n                  break;\n                }\n\n                _context.next = 14;\n                return pausePromise;\n\n              case 14:\n                if (!(isStopped || !dataHandler || !endHandler)) {\n                  _context.next = 16;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 16:\n                if (!done) {\n                  _context.next = 21;\n                  break;\n                }\n\n                lastChunkString = decoder.decode(value); // value is empty but pass just in case\n\n                if (lastChunkString) {\n                  dataHandler(lastChunkString);\n                }\n\n                endHandler(undefined);\n                return _context.abrupt(\"return\");\n\n              case 21:\n                // otherwise, normal data event after stream-safe decoding\n                chunkString = decoder.decode(value, {\n                  stream: true\n                });\n                dataHandler(chunkString);\n                _context.next = 5;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                // always release the lock\n                streamReader.releaseLock();\n                return _context.finish(25);\n\n              case 28:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[4,, 25, 28]]);\n      }));\n    }\n\n    var self = {\n      // marker properties to make PapaParse think this is a Readable object\n      readable: true,\n      read: function read() {\n        throw new Error('only flowing mode is emulated');\n      },\n      on: function on(event, callback) {\n        switch (event) {\n          case 'data':\n            if (dataHandler) {\n              throw new Error('two data handlers not supported');\n            }\n\n            dataHandler = callback; // flowing state started, run the main pump loop\n\n            runReaderPump().catch(function (error) {\n              if (errorHandler) {\n                errorHandler(error);\n              } else {\n                // rethrow to show error in console\n                throw error;\n              }\n            });\n            return;\n\n          case 'end':\n            if (endHandler) {\n              throw new Error('two end handlers not supported');\n            }\n\n            endHandler = callback;\n            return;\n\n          case 'error':\n            if (errorHandler) {\n              throw new Error('two error handlers not supported');\n            }\n\n            errorHandler = callback;\n            return;\n        }\n\n        throw new Error('unknown stream shim event: ' + event);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      removeListener: function removeListener(event, callback) {\n        // stop and clear everything for simplicity\n        isStopped = true;\n        dataHandler = null;\n        endHandler = null;\n        errorHandler = null;\n      },\n      pause: function pause() {\n        if (!pausePromise) {\n          pausePromise = new Promise(function (resolve) {\n            pauseResolver = resolve;\n          });\n        }\n\n        return self;\n      },\n      resume: function resume() {\n        if (pauseResolver) {\n          pauseResolver(); // waiting code will proceed in next tick\n\n          pausePromise = null;\n          pauseResolver = null;\n        }\n\n        return self;\n      }\n    }; // pass ourselves off as a real Node stream\n\n    return self;\n  }\n\n  function parsePreview(file, customConfig) {\n    // wrap synchronous errors in promise\n    return new Promise(function (resolve) {\n      var firstChunk = null;\n      var firstWarning = undefined;\n      var rowAccumulator = [];\n\n      function reportSuccess() {\n        // PapaParse normally complains first anyway, but might as well flag it\n        if (rowAccumulator.length === 0) {\n          return {\n            parseError: new Error('File is empty'),\n            file: file\n          };\n        } // remember whether this file has only one line\n\n\n        var isSingleLine = rowAccumulator.length === 1; // fill preview with blanks if needed\n\n        while (rowAccumulator.length < PREVIEW_ROW_COUNT) {\n          rowAccumulator.push([]);\n        }\n\n        resolve({\n          file: file,\n          parseError: undefined,\n          parseWarning: firstWarning || undefined,\n          firstChunk: firstChunk || '',\n          firstRows: rowAccumulator,\n          isSingleLine: isSingleLine\n        });\n      } // use our own multibyte-safe streamer, bail after first chunk\n      // (this used to add skipEmptyLines but that was hiding possible parse errors)\n      // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\n\n\n      var nodeStream = nodeStreamWrapper(streamForBlob(file), customConfig.encoding || 'utf-8');\n      external_papaparse_default.a.parse(nodeStream, Object.assign(Object.assign({}, customConfig), {\n        chunkSize: 10000,\n        preview: PREVIEW_ROW_COUNT,\n        error: function error(_error) {\n          resolve({\n            parseError: _error,\n            file: file\n          });\n        },\n        beforeFirstChunk: function beforeFirstChunk(chunk) {\n          firstChunk = chunk;\n        },\n        chunk: function chunk(_ref, parser) {\n          var data = _ref.data,\n              errors = _ref.errors;\n          data.forEach(function (row) {\n            var stringRow = row.map(function (item) {\n              return typeof item === 'string' ? item : '';\n            });\n            rowAccumulator.push(stringRow);\n          });\n\n          if (errors.length > 0 && !firstWarning) {\n            firstWarning = errors[0];\n          } // finish parsing once we got enough data, otherwise try for more\n          // (in some cases PapaParse flushes out last line as separate chunk)\n\n\n          if (rowAccumulator.length >= PREVIEW_ROW_COUNT) {\n            nodeStream.pause(); // parser does not pause source stream, do it here explicitly\n\n            parser.abort();\n            reportSuccess();\n          }\n        },\n        complete: reportSuccess\n      }));\n    }).catch(function (error) {\n      return {\n        parseError: error,\n        file: file\n      };\n    });\n  }\n\n  function processFile(input, reportProgress, callback) {\n    var file = input.file,\n        hasHeaders = input.hasHeaders,\n        papaParseConfig = input.papaParseConfig,\n        fieldAssignments = input.fieldAssignments;\n    var fieldNames = Object.keys(fieldAssignments); // wrap synchronous errors in promise\n\n    return new Promise(function (resolve, reject) {\n      // skip first line if needed\n      var skipLine = hasHeaders;\n      var processedCount = 0; // use our own multibyte-safe decoding streamer\n      // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\n\n      var nodeStream = nodeStreamWrapper(streamForBlob(file), papaParseConfig.encoding || 'utf-8');\n      external_papaparse_default.a.parse(nodeStream, Object.assign(Object.assign({}, papaParseConfig), {\n        chunkSize: papaParseConfig.chunkSize || 10000,\n        error: function error(_error2) {\n          reject(_error2);\n        },\n        chunk: function chunk(_ref2, parser) {\n          var data = _ref2.data;\n          // pause to wait until the rows are consumed\n          nodeStream.pause(); // parser does not pause source stream, do it here explicitly\n\n          parser.pause();\n          var skipped = skipLine && data.length > 0;\n          var rows = (skipped ? data.slice(1) : data).map(function (row) {\n            var stringRow = row.map(function (item) {\n              return typeof item === 'string' ? item : '';\n            });\n            var record = {};\n            fieldNames.forEach(function (fieldName) {\n              var columnIndex = fieldAssignments[fieldName];\n\n              if (columnIndex !== undefined) {\n                record[fieldName] = stringRow[columnIndex];\n              }\n            });\n            return record; // @todo look into a more precise setup\n          }); // clear line skip flag if there was anything to skip\n\n          if (skipped) {\n            skipLine = false;\n          } // info snapshot for processing callback\n\n\n          var info = {\n            startIndex: processedCount\n          };\n          processedCount += rows.length; // @todo collect errors\n\n          reportProgress(rows.length); // wrap sync errors in promise\n          // (avoid invoking callback if there are no rows to consume)\n\n          var whenConsumed = new Promise(function (resolve) {\n            var result = rows.length ? callback(rows, info) : undefined; // introduce delay to allow a frame render\n\n            setTimeout(function () {\n              return resolve(result);\n            }, 0);\n          }); // unpause parsing when done\n\n          whenConsumed.then(function () {\n            nodeStream.resume();\n            parser.resume();\n          }, function () {\n            // @todo collect errors\n            nodeStream.resume();\n            parser.resume();\n          });\n        },\n        complete: function complete() {\n          resolve();\n        }\n      }));\n    });\n  } // EXTERNAL MODULE: ./src/components/TextButton.scss\n\n\n  var TextButton = __webpack_require__(5); // CONCATENATED MODULE: ./src/components/TextButton.tsx\n\n\n  var TextButton_TextButton = function TextButton_TextButton(_ref3) {\n    var disabled = _ref3.disabled,\n        onClick = _ref3.onClick,\n        children = _ref3.children;\n    return external_react_default.a.createElement(\"button\", {\n      className: \"CSVImporter_TextButton\",\n      disabled: disabled,\n      onClick: onClick\n    }, children);\n  }; // EXTERNAL MODULE: ./src/components/IconButton.scss\n\n\n  var IconButton = __webpack_require__(6); // CONCATENATED MODULE: ./src/components/IconButton.tsx\n\n\n  var IconButton_IconButton = function IconButton_IconButton(_ref4) {\n    var type = _ref4.type,\n        label = _ref4.label,\n        small = _ref4.small,\n        focusOnly = _ref4.focusOnly,\n        disabled = _ref4.disabled,\n        onClick = _ref4.onClick;\n    return external_react_default.a.createElement(\"button\", {\n      className: \"CSVImporter_IconButton\",\n      \"aria-label\": label,\n      disabled: disabled,\n      onClick: onClick,\n      \"data-small\": !!small,\n      \"data-focus-only\": !!focusOnly\n    }, external_react_default.a.createElement(\"span\", {\n      \"data-type\": type\n    }));\n  }; // EXTERNAL MODULE: ./src/components/ImporterFrame.scss\n\n\n  var ImporterFrame = __webpack_require__(7); // CONCATENATED MODULE: ./src/locale/index.ts\n\n  /* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\n\n\n  var enUS = {\n    general: {\n      goToPreviousStepTooltip: 'Go to previous step'\n    },\n    fileStep: {\n      initialDragDropPrompt: 'Drag-and-drop CSV file here, or click to select in folder',\n      activeDragDropPrompt: 'Drop CSV file here...',\n      getImportError: function getImportError(message) {\n        return \"Import error: \".concat(message);\n      },\n      getDataFormatError: function getDataFormatError(message) {\n        return \"Please check data formatting: \".concat(message);\n      },\n      goBackButton: 'Go Back',\n      nextButton: 'Choose columns',\n      rawFileContentsHeading: 'Raw File Contents',\n      previewImportHeading: 'Preview Import',\n      dataHasHeadersCheckbox: 'Data has headers',\n      previewLoadingStatus: 'Loading preview...'\n    },\n    fieldsStep: {\n      stepSubtitle: 'Select Columns',\n      requiredFieldsError: 'Please assign all required fields',\n      nextButton: 'Import',\n      dragSourceAreaCaption: 'Columns to import',\n      getDragSourcePageIndicator: function getDragSourcePageIndicator(currentPage, pageCount) {\n        return \"Page \".concat(currentPage, \" of \").concat(pageCount);\n      },\n      getDragSourceActiveStatus: function getDragSourceActiveStatus(columnCode) {\n        return \"Assigning column \".concat(columnCode);\n      },\n      nextColumnsTooltip: 'Show next columns',\n      previousColumnsTooltip: 'Show previous columns',\n      clearAssignmentTooltip: 'Clear column assignment',\n      selectColumnTooltip: 'Select column for assignment',\n      unselectColumnTooltip: 'Unselect column',\n      dragTargetAreaCaption: 'Target fields',\n      getDragTargetOptionalCaption: function getDragTargetOptionalCaption(field) {\n        return \"\".concat(field, \" (optional)\");\n      },\n      getDragTargetRequiredCaption: function getDragTargetRequiredCaption(field) {\n        return \"\".concat(field, \" (required)\");\n      },\n      dragTargetPlaceholder: 'Drag column here',\n      getDragTargetAssignTooltip: function getDragTargetAssignTooltip(columnCode) {\n        return \"Assign column \".concat(columnCode);\n      },\n      dragTargetClearTooltip: 'Clear column assignment',\n      columnCardDummyHeader: 'Unassigned field',\n      getColumnCardHeader: function getColumnCardHeader(code) {\n        return \"Column \".concat(code);\n      }\n    },\n    progressStep: {\n      stepSubtitle: 'Import',\n      uploadMoreButton: 'Upload More',\n      finishButton: 'Finish',\n      statusError: 'Could not import',\n      statusComplete: 'Complete',\n      statusPending: 'Importing...',\n      processedRowsLabel: 'Processed rows:'\n    }\n  };\n  var deDE = {\n    general: {\n      goToPreviousStepTooltip: 'Zum vorherigen Schritt'\n    },\n    fileStep: {\n      initialDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen, oder klicken um eine Datei auszuwählen',\n      activeDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen...',\n      nextButton: 'Spalten auswählen',\n      getImportError: function getImportError(message) {\n        return \"Fehler beim Import: \".concat(message);\n      },\n      getDataFormatError: function getDataFormatError(message) {\n        return \"Bitte Datenformat \\xFCberpr\\xFCfen: \".concat(message);\n      },\n      goBackButton: 'Zurück',\n      rawFileContentsHeading: 'Originaler Datei-Inhalt',\n      previewImportHeading: 'Import-Vorschau',\n      dataHasHeadersCheckbox: 'Mit Kopfzeile',\n      previewLoadingStatus: 'Vorschau wird geladen...'\n    },\n    fieldsStep: {\n      stepSubtitle: 'Spalten auswählen',\n      requiredFieldsError: 'Bitte weise allen nicht optionalen Spalten einen Wert zu',\n      nextButton: 'Importieren',\n      dragSourceAreaCaption: 'Zu importierende Spalte',\n      getDragSourcePageIndicator: function getDragSourcePageIndicator(currentPage, pageCount) {\n        return \"Seite \".concat(currentPage, \" von \").concat(pageCount);\n      },\n      getDragSourceActiveStatus: function getDragSourceActiveStatus(columnCode) {\n        return \"Spalte \".concat(columnCode, \" zuweisen\");\n      },\n      nextColumnsTooltip: 'Nächste Spalten anzeigen',\n      previousColumnsTooltip: 'Vorherige Spalten anzeigen',\n      clearAssignmentTooltip: 'Zugewiesene Spalte entfernen',\n      selectColumnTooltip: 'Spalte zum Zuweisen auswählen',\n      unselectColumnTooltip: 'Spalte abwählen',\n      dragTargetAreaCaption: 'Zielfelder',\n      getDragTargetOptionalCaption: function getDragTargetOptionalCaption(field) {\n        return \"\".concat(field, \" (optional)\");\n      },\n      getDragTargetRequiredCaption: function getDragTargetRequiredCaption(field) {\n        return \"\".concat(field, \" (erforderlich)\");\n      },\n      dragTargetPlaceholder: 'Spalte hierher ziehen',\n      getDragTargetAssignTooltip: function getDragTargetAssignTooltip(columnCode) {\n        return \"Spalte \".concat(columnCode, \" zuweisen\");\n      },\n      dragTargetClearTooltip: 'Zugewiesene Spalte entfernen',\n      columnCardDummyHeader: 'Nicht zugewiesenes Feld',\n      getColumnCardHeader: function getColumnCardHeader(code) {\n        return \"Spalte \".concat(code);\n      }\n    },\n    progressStep: {\n      stepSubtitle: 'Importieren',\n      uploadMoreButton: 'Weitere hochladen',\n      finishButton: 'Abschließen',\n      statusError: 'Konnte nicht importiert werden',\n      statusComplete: 'Fertig',\n      statusPending: 'Wird importiert...',\n      processedRowsLabel: 'Verarbeitete Zeilen:'\n    }\n  }; // CONCATENATED MODULE: ./src/locale/LocaleContext.tsx\n\n  var LocaleContext = external_react_default.a.createContext(enUS);\n\n  function useLocale(namespace) {\n    var locale = Object(external_react_[\"useContext\"])(LocaleContext);\n    return locale[namespace]; // not using memo for basic property getter\n  } // CONCATENATED MODULE: ./src/components/ImporterFrame.tsx\n\n\n  var ImporterFrame_ImporterFrame = function ImporterFrame_ImporterFrame(_ref5) {\n    var fileName = _ref5.fileName,\n        subtitle = _ref5.subtitle,\n        secondaryDisabled = _ref5.secondaryDisabled,\n        secondaryLabel = _ref5.secondaryLabel,\n        nextDisabled = _ref5.nextDisabled,\n        nextLabel = _ref5.nextLabel,\n        error = _ref5.error,\n        onSecondary = _ref5.onSecondary,\n        onNext = _ref5.onNext,\n        onCancel = _ref5.onCancel,\n        children = _ref5.children;\n    var titleRef = Object(external_react_[\"useRef\"])(null);\n    var subtitleRef = Object(external_react_[\"useRef\"])(null);\n    Object(external_react_[\"useEffect\"])(function () {\n      if (subtitleRef.current) {\n        subtitleRef.current.focus();\n      } else if (titleRef.current) {\n        titleRef.current.focus();\n      }\n    }, []);\n    var l10n = useLocale('general');\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__header\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.goToPreviousStepTooltip,\n      type: \"arrowBack\",\n      disabled: !onCancel,\n      onClick: onCancel\n    }), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__headerTitle\",\n      tabIndex: -1,\n      ref: titleRef\n    }, fileName), subtitle ? external_react_default.a.createElement(external_react_default.a.Fragment, null, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__headerCrumbSeparator\"\n    }, external_react_default.a.createElement(\"span\", null)), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__headerSubtitle\",\n      tabIndex: -1,\n      ref: subtitleRef\n    }, subtitle)) : null), children, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footer\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footerFill\"\n    }), error ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footerError\",\n      role: \"status\"\n    }, error) : null, secondaryLabel ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footerSecondary\"\n    }, external_react_default.a.createElement(TextButton_TextButton, {\n      disabled: !!secondaryDisabled,\n      onClick: onSecondary\n    }, secondaryLabel)) : null, nextLabel !== false ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ImporterFrame__footerNext\"\n    }, external_react_default.a.createElement(TextButton_TextButton, {\n      disabled: !!nextDisabled,\n      onClick: onNext\n    }, nextLabel)) : null));\n  }; // EXTERNAL MODULE: external \"react-dropzone\"\n\n\n  var external_react_dropzone_ = __webpack_require__(2); // EXTERNAL MODULE: ./src/components/file-step/FileSelector.scss\n\n\n  var FileSelector = __webpack_require__(8); // CONCATENATED MODULE: ./src/components/file-step/FileSelector.tsx\n\n\n  var FileSelector_FileSelector = function FileSelector_FileSelector(_ref6) {\n    var onSelected = _ref6.onSelected;\n    var onSelectedRef = Object(external_react_[\"useRef\"])(onSelected);\n    onSelectedRef.current = onSelected;\n    var dropHandler = Object(external_react_[\"useCallback\"])(function (acceptedFiles) {\n      // silently ignore if nothing to do\n      if (acceptedFiles.length < 1) {\n        return;\n      }\n\n      var file = acceptedFiles[0];\n      onSelectedRef.current(file);\n    }, []);\n\n    var _Object = Object(external_react_dropzone_[\"useDropzone\"])({\n      onDrop: dropHandler\n    }),\n        getRootProps = _Object.getRootProps,\n        getInputProps = _Object.getInputProps,\n        isDragActive = _Object.isDragActive;\n\n    var l10n = useLocale('fileStep');\n    return external_react_default.a.createElement(\"div\", Object.assign({\n      className: \"CSVImporter_FileSelector\",\n      \"data-active\": !!isDragActive\n    }, getRootProps()), external_react_default.a.createElement(\"input\", Object.assign({}, getInputProps())), isDragActive ? external_react_default.a.createElement(\"span\", null, l10n.activeDragDropPrompt) : external_react_default.a.createElement(\"span\", null, l10n.initialDragDropPrompt));\n  }; // EXTERNAL MODULE: ./src/components/file-step/FormatErrorMessage.scss\n\n\n  var FormatErrorMessage = __webpack_require__(9); // CONCATENATED MODULE: ./src/components/file-step/FormatErrorMessage.tsx\n\n\n  var FormatErrorMessage_FormatErrorMessage = external_react_default.a.memo(function (_ref7) {\n    var onCancelClick = _ref7.onCancelClick,\n        children = _ref7.children;\n    var l10n = useLocale('fileStep');\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FormatErrorMessage\"\n    }, external_react_default.a.createElement(\"span\", null, children), external_react_default.a.createElement(TextButton_TextButton, {\n      onClick: onCancelClick\n    }, l10n.goBackButton));\n  }); // EXTERNAL MODULE: ./src/components/file-step/FormatRawPreview.scss\n\n  var FormatRawPreview = __webpack_require__(10); // CONCATENATED MODULE: ./src/components/file-step/FormatRawPreview.tsx\n\n\n  var RAW_PREVIEW_SIZE = 500;\n  var FormatRawPreview_FormatRawPreview = external_react_default.a.memo(function (_ref8) {\n    var chunk = _ref8.chunk,\n        warning = _ref8.warning,\n        onCancelClick = _ref8.onCancelClick;\n    var chunkSlice = chunk.slice(0, RAW_PREVIEW_SIZE);\n    var chunkHasMore = chunk.length > RAW_PREVIEW_SIZE;\n    var l10n = useLocale('fileStep');\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FormatRawPreview\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FormatRawPreview__scroll\"\n    }, external_react_default.a.createElement(\"pre\", {\n      className: \"CSVImporter_FormatRawPreview__pre\"\n    }, chunkSlice, chunkHasMore && external_react_default.a.createElement(\"aside\", null, \"...\"))), warning ? external_react_default.a.createElement(FormatErrorMessage_FormatErrorMessage, {\n      onCancelClick: onCancelClick\n    }, l10n.getDataFormatError(warning.message || String(warning))) : null);\n  }); // EXTERNAL MODULE: ./src/components/file-step/FormatDataRowPreview.scss\n\n  var FormatDataRowPreview = __webpack_require__(11); // CONCATENATED MODULE: ./src/components/file-step/FormatDataRowPreview.tsx\n\n\n  var FormatDataRowPreview_FormatDataRowPreview = external_react_default.a.memo(function (_ref9) {\n    var hasHeaders = _ref9.hasHeaders,\n        rows = _ref9.rows;\n    var headerRow = hasHeaders ? rows[0] : null;\n    var bodyRows = hasHeaders ? rows.slice(1) : rows;\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FormatDataRowPreview\"\n    }, external_react_default.a.createElement(\"table\", {\n      className: \"CSVImporter_FormatDataRowPreview__table\"\n    }, headerRow && external_react_default.a.createElement(\"thead\", null, external_react_default.a.createElement(\"tr\", null, headerRow.map(function (item, itemIndex) {\n      return external_react_default.a.createElement(\"th\", {\n        key: itemIndex\n      }, item);\n    }))), external_react_default.a.createElement(\"tbody\", null, bodyRows.map(function (row, rowIndex) {\n      return external_react_default.a.createElement(\"tr\", {\n        key: rowIndex\n      }, row.map(function (item, itemIndex) {\n        return external_react_default.a.createElement(\"td\", {\n          key: itemIndex\n        }, item);\n      }));\n    }))));\n  }); // EXTERNAL MODULE: ./src/components/file-step/FileStep.scss\n\n  var FileStep = __webpack_require__(12); // CONCATENATED MODULE: ./src/components/file-step/FileStep.tsx\n\n\n  var FileStep_FileStep = function FileStep_FileStep(_ref10) {\n    var customConfig = _ref10.customConfig,\n        assumeNoHeaders = _ref10.assumeNoHeaders,\n        prevState = _ref10.prevState,\n        onChange = _ref10.onChange,\n        onAccept = _ref10.onAccept;\n\n    // seed from previous state as needed\n    var _Object2 = Object(external_react_[\"useState\"])(prevState ? prevState.file : null),\n        _Object3 = _slicedToArray(_Object2, 2),\n        selectedFile = _Object3[0],\n        setSelectedFile = _Object3[1];\n\n    var _Object4 = Object(external_react_[\"useState\"])(function () {\n      return prevState && Object.assign({\n        parseError: undefined\n      }, prevState);\n    }),\n        _Object5 = _slicedToArray(_Object4, 2),\n        preview = _Object5[0],\n        setPreview = _Object5[1];\n\n    var _Object6 = Object(external_react_[\"useState\"])(prevState ? prevState.papaParseConfig : customConfig),\n        _Object7 = _slicedToArray(_Object6, 2),\n        papaParseConfig = _Object7[0],\n        setPapaParseConfig = _Object7[1];\n\n    var _Object8 = Object(external_react_[\"useState\"])(prevState ? prevState.hasHeaders : false),\n        _Object9 = _slicedToArray(_Object8, 2),\n        hasHeaders = _Object9[0],\n        setHasHeaders = _Object9[1]; // wrap in ref to avoid triggering effect\n\n\n    var customConfigRef = Object(external_react_[\"useRef\"])(customConfig);\n    customConfigRef.current = customConfig;\n    var assumeNoHeadersRef = Object(external_react_[\"useRef\"])(assumeNoHeaders);\n    assumeNoHeadersRef.current = assumeNoHeaders;\n    var onChangeRef = Object(external_react_[\"useRef\"])(onChange);\n    onChangeRef.current = onChange; // notify of current state\n\n    Object(external_react_[\"useEffect\"])(function () {\n      onChangeRef.current(preview && !preview.parseError ? Object.assign(Object.assign({}, preview), {\n        papaParseConfig: papaParseConfig,\n        hasHeaders: hasHeaders\n      }) : null);\n    }, [preview, papaParseConfig, hasHeaders]); // perform async preview parse once for the given file\n\n    var asyncLockRef = Object(external_react_[\"useRef\"])(0);\n    Object(external_react_[\"useEffect\"])(function () {\n      // clear other state when file selector is reset\n      if (!selectedFile) {\n        setPreview(null);\n        return;\n      } // preserve existing state when parsing for this file is already complete\n\n\n      if (preview && preview.file === selectedFile) {\n        return;\n      }\n\n      var oplock = asyncLockRef.current; // lock in the current PapaParse config instance for use in multiple spots\n\n      var config = customConfigRef.current; // kick off the preview parse\n\n      parsePreview(selectedFile, config).then(function (results) {\n        // ignore if stale\n        if (oplock !== asyncLockRef.current) {\n          return;\n        } // save the results and the original config\n\n\n        setPreview(results);\n        setPapaParseConfig(config); // pre-fill headers flag (only possible with >1 lines)\n\n        setHasHeaders(results.parseError ? false : !assumeNoHeadersRef.current && !results.isSingleLine);\n      });\n      return function () {\n        // invalidate current oplock on change or unmount\n        asyncLockRef.current += 1;\n      };\n    }, [selectedFile, preview]);\n    var l10n = useLocale('fileStep'); // clear selected file\n    // preview result content to display\n\n    var reportBlock = Object(external_react_[\"useMemo\"])(function () {\n      if (!preview) {\n        return null;\n      }\n\n      if (preview.parseError) {\n        return external_react_default.a.createElement(\"div\", {\n          className: \"CSVImporter_FileStep__mainResultBlock\"\n        }, external_react_default.a.createElement(FormatErrorMessage_FormatErrorMessage, {\n          onCancelClick: function onCancelClick() {\n            return setSelectedFile(null);\n          }\n        }, l10n.getImportError(preview.parseError.message || String(preview.parseError))));\n      }\n\n      return external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_FileStep__mainResultBlock\"\n      }, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_FileStep__header\"\n      }, l10n.rawFileContentsHeading), external_react_default.a.createElement(FormatRawPreview_FormatRawPreview, {\n        chunk: preview.firstChunk,\n        warning: preview.parseWarning,\n        onCancelClick: function onCancelClick() {\n          return setSelectedFile(null);\n        }\n      }), preview.parseWarning ? null : external_react_default.a.createElement(external_react_default.a.Fragment, null, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_FileStep__header\"\n      }, l10n.previewImportHeading, !preview.isSingleLine && // hide setting if only one line anyway\n      external_react_default.a.createElement(\"label\", {\n        className: \"CSVImporter_FileStep__headerToggle\"\n      }, external_react_default.a.createElement(\"input\", {\n        type: \"checkbox\",\n        checked: hasHeaders,\n        onChange: function onChange() {\n          setHasHeaders(function (prev) {\n            return !prev;\n          });\n        }\n      }), external_react_default.a.createElement(\"span\", null, l10n.dataHasHeadersCheckbox))), external_react_default.a.createElement(FormatDataRowPreview_FormatDataRowPreview, {\n        hasHeaders: hasHeaders,\n        rows: preview.firstRows\n      })));\n    }, [preview, hasHeaders, l10n]);\n\n    if (!selectedFile) {\n      return external_react_default.a.createElement(FileSelector_FileSelector, {\n        onSelected: function onSelected(file) {\n          return setSelectedFile(file);\n        }\n      });\n    }\n\n    return external_react_default.a.createElement(ImporterFrame_ImporterFrame, {\n      fileName: selectedFile.name,\n      nextDisabled: !preview || !!preview.parseError || !!preview.parseWarning,\n      onNext: function onNext() {\n        if (!preview || preview.parseError) {\n          throw new Error('unexpected missing preview info');\n        }\n\n        onAccept();\n      },\n      onCancel: function onCancel() {\n        return setSelectedFile(null);\n      },\n      nextLabel: l10n.nextButton\n    }, reportBlock || external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_FileStep__mainPendingBlock\"\n    }, l10n.previewLoadingStatus));\n  }; // CONCATENATED MODULE: ./src/components/fields-step/ColumnPreview.tsx\n  // spreadsheet-style column code computation (A, B, ..., Z, AA, AB, ..., etc)\n\n\n  function generateColumnCode(value) {\n    // ignore dummy index\n    if (value < 0) {\n      return '';\n    } // first, determine how many base-26 letters there should be\n    // (because the notation is not purely positional)\n\n\n    var digitCount = 1;\n    var base = 0;\n    var next = 26;\n\n    while (next <= value) {\n      digitCount += 1;\n      base = next;\n      next = next * 26 + 26;\n    } // then, apply normal positional digit computation on remainder above base\n\n\n    var remainder = value - base;\n    var digits = [];\n\n    while (digits.length < digitCount) {\n      var lastDigit = remainder % 26;\n      remainder = Math.floor((remainder - lastDigit) / 26); // applying floor just in case\n      // store ASCII code, with A as 0\n\n      digits.unshift(65 + lastDigit);\n    }\n\n    return String.fromCharCode.apply(null, digits);\n  } // prepare spreadsheet-like column display information for given raw data preview\n\n\n  function generatePreviewColumns(firstRows, hasHeaders) {\n    var columnStubs = _toConsumableArray(new Array(firstRows[0].length));\n\n    return columnStubs.map(function (empty, index) {\n      var values = firstRows.map(function (row) {\n        return row[index] || '';\n      });\n      var headerValue = hasHeaders ? values.shift() : undefined;\n      return {\n        index: index,\n        header: headerValue,\n        values: values\n      };\n    });\n  } // EXTERNAL MODULE: external \"react-use-gesture\"\n\n\n  var external_react_use_gesture_ = __webpack_require__(3); // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragState.tsx\n\n\n  function useColumnDragState(fields, initialAssignments, onTouched) {\n    // wrap in ref to avoid re-triggering\n    var onTouchedRef = Object(external_react_[\"useRef\"])(onTouched);\n    onTouchedRef.current = onTouched;\n\n    var _Object10 = Object(external_react_[\"useState\"])(null),\n        _Object11 = _slicedToArray(_Object10, 2),\n        dragState = _Object11[0],\n        setDragState = _Object11[1];\n\n    var _Object12 = Object(external_react_[\"useState\"])(initialAssignments),\n        _Object13 = _slicedToArray(_Object12, 2),\n        fieldAssignments = _Object13[0],\n        setFieldAssignments = _Object13[1]; // make sure there are no extra fields\n\n\n    Object(external_react_[\"useEffect\"])(function () {\n      var removedFieldNames = Object.keys(fieldAssignments).filter(function (existingFieldName) {\n        return !fields.some(function (field) {\n          return field.name === existingFieldName;\n        });\n      });\n\n      if (removedFieldNames.length > 0) {\n        // @todo put everything inside this setter\n        setFieldAssignments(function (prev) {\n          var copy = Object.assign({}, prev);\n          removedFieldNames.forEach(function (fieldName) {\n            delete copy[fieldName];\n          });\n          return copy;\n        });\n      }\n    }, [fields, fieldAssignments]);\n    var internalAssignHandler = Object(external_react_[\"useCallback\"])(function (column, fieldName) {\n      setFieldAssignments(function (prevAssignments) {\n        var copy = Object.assign({}, prevAssignments); // ensure dropped column does not show up elsewhere\n\n        Object.keys(prevAssignments).forEach(function (name) {\n          if (copy[name] === column.index) {\n            delete copy[name];\n          }\n        }); // set new field column\n\n        if (fieldName !== null) {\n          copy[fieldName] = column.index;\n        }\n\n        return copy;\n      }); // mark for validation display\n\n      if (fieldName) {\n        onTouchedRef.current(fieldName);\n      }\n    }, []);\n    var bindDrag = Object(external_react_use_gesture_[\"useDrag\"])(function (_ref11) {\n      var first = _ref11.first,\n          last = _ref11.last,\n          event = _ref11.event,\n          xy = _ref11.xy,\n          args = _ref11.args;\n\n      if (first && event) {\n        // only prevent default inside first event\n        // (touchmove uses passive event handler and would trigger warning)\n        event.preventDefault();\n\n        var _args2 = _slicedToArray(args, 2),\n            column = _args2[0],\n            startFieldName = _args2[1];\n\n        setDragState({\n          pointerStartInfo: {\n            initialXY: xy,\n            initialWidth: event.currentTarget instanceof HTMLElement ? event.currentTarget.offsetWidth : 0\n          },\n          column: column,\n          dropFieldName: startFieldName !== undefined ? startFieldName : null,\n          updateListeners: {}\n        });\n      } else if (last) {\n        setDragState(null);\n\n        if (dragState) {\n          internalAssignHandler(dragState.column, dragState.dropFieldName);\n        }\n      } // @todo figure out a cleaner event stream solution\n\n\n      if (dragState) {\n        var listeners = dragState.updateListeners;\n\n        for (var _i = 0, _Object$keys = Object.keys(listeners); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          listeners[key](xy);\n        }\n      }\n    }, {}); // when dragging, set root-level user-select:none to prevent text selection, see Importer.scss\n    // (done via class toggle to avoid interfering with any other dynamic style changes)\n\n    Object(external_react_[\"useEffect\"])(function () {\n      if (dragState) {\n        document.body.classList.add('CSVImporter_dragging');\n      } else {\n        // remove text selection prevention after a delay (otherwise on iOS it still selects something)\n        var timeoutId = setTimeout(function () {\n          document.body.classList.remove('CSVImporter_dragging');\n        }, 200);\n        return function () {\n          // if another drag state comes along then cancel our delay and just clean up class right away\n          clearTimeout(timeoutId);\n          document.body.classList.remove('CSVImporter_dragging');\n        };\n      }\n    }, [dragState]);\n    var columnSelectHandler = Object(external_react_[\"useCallback\"])(function (column) {\n      setDragState(function (prev) {\n        // toggle off if needed\n        if (prev && prev.column === column) {\n          return null;\n        }\n\n        return {\n          pointerStartInfo: null,\n          column: column,\n          dropFieldName: null,\n          updateListeners: {}\n        };\n      });\n    }, []);\n    var dragHoverHandler = Object(external_react_[\"useCallback\"])(function (fieldName, isOn) {\n      setDragState(function (prev) {\n        if (!prev) {\n          return prev;\n        }\n\n        if (isOn) {\n          // set the new drop target\n          return Object.assign(Object.assign({}, prev), {\n            dropFieldName: fieldName\n          });\n        } else if (prev.dropFieldName === fieldName) {\n          // clear drop target if we are still the current one\n          return Object.assign(Object.assign({}, prev), {\n            dropFieldName: null\n          });\n        } // no changes by default\n\n\n        return prev;\n      });\n    }, []);\n    var assignHandler = Object(external_react_[\"useCallback\"])(function (fieldName) {\n      // clear active drag state\n      setDragState(null);\n\n      if (dragState) {\n        internalAssignHandler(dragState.column, fieldName);\n      }\n    }, [internalAssignHandler, dragState]);\n    var unassignHandler = Object(external_react_[\"useCallback\"])(function (column) {\n      setFieldAssignments(function (prev) {\n        var assignedFieldName = Object.keys(prev).find(function (fieldName) {\n          return prev[fieldName] === column.index;\n        });\n\n        if (assignedFieldName === undefined) {\n          return prev;\n        }\n\n        var copy = Object.assign({}, prev);\n        delete copy[assignedFieldName];\n        return copy;\n      });\n    }, []);\n    return {\n      fieldAssignments: fieldAssignments,\n      dragState: dragState,\n      dragEventBinder: bindDrag,\n      dragHoverHandler: dragHoverHandler,\n      columnSelectHandler: columnSelectHandler,\n      assignHandler: assignHandler,\n      unassignHandler: unassignHandler\n    };\n  } // EXTERNAL MODULE: external \"react-dom\"\n\n\n  var external_react_dom_ = __webpack_require__(4); // EXTERNAL MODULE: ./src/components/fields-step/ColumnDragCard.scss\n\n\n  var ColumnDragCard = __webpack_require__(13); // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragCard.tsx\n  // @todo sort out \"grabbing\" cursor state (does not work with pointer-events:none)\n\n\n  var ColumnDragCard_ColumnDragCard = function ColumnDragCard_ColumnDragCard(_ref12) {\n    var hasHeaders = _ref12.hasHeaders,\n        optionalColumn = _ref12.column,\n        _ref12$rowCount = _ref12.rowCount,\n        rowCount = _ref12$rowCount === void 0 ? PREVIEW_ROW_COUNT : _ref12$rowCount,\n        hasError = _ref12.hasError,\n        isAssigned = _ref12.isAssigned,\n        isShadow = _ref12.isShadow,\n        isDraggable = _ref12.isDraggable,\n        isDragged = _ref12.isDragged,\n        isDropIndicator = _ref12.isDropIndicator;\n    var isDummy = !optionalColumn;\n    var column = Object(external_react_[\"useMemo\"])(function () {\n      return optionalColumn || {\n        index: -1,\n        code: '',\n        header: hasHeaders ? '' : undefined,\n        values: _toConsumableArray(new Array(PREVIEW_ROW_COUNT)).map(function () {\n          return '';\n        })\n      };\n    }, [optionalColumn, hasHeaders]);\n    var headerValue = column.header;\n    var dataValues = column.values.slice(0, headerValue === undefined ? rowCount : rowCount - 1);\n    var l10n = useLocale('fieldsStep');\n    return (// not changing variant dynamically because it causes a height jump\n      external_react_default.a.createElement(\"div\", {\n        key: isDummy || isShadow ? 1 : isDropIndicator ? 2 : 0,\n        className: \"CSVImporter_ColumnDragCard\",\n        \"data-dummy\": !!isDummy,\n        \"data-error\": !!hasError,\n        \"data-shadow\": !!isShadow,\n        \"data-draggable\": !!isDraggable,\n        \"data-dragged\": !!isDragged,\n        \"data-drop-indicator\": !!isDropIndicator\n      }, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_ColumnDragCard__cardHeader\"\n      }, isDummy ? external_react_default.a.createElement(\"var\", {\n        role: \"text\"\n      }, l10n.columnCardDummyHeader) : external_react_default.a.createElement(\"var\", {\n        role: \"text\"\n      }, l10n.getColumnCardHeader(column.code)), isDummy || isAssigned ? \"\\xA0\" : external_react_default.a.createElement(\"b\", {\n        \"aria-hidden\": true\n      }, column.code)), headerValue !== undefined ? external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_ColumnDragCard__cardValue\",\n        \"data-header\": true\n      }, headerValue || \"\\xA0\") : null, external_react_default.a.createElement(\"div\", {\n        role: \"text\"\n      }, dataValues.map(function (value, valueIndex) {\n        return external_react_default.a.createElement(\"div\", {\n          key: valueIndex,\n          className: \"CSVImporter_ColumnDragCard__cardValue\"\n        }, value || \"\\xA0\");\n      })))\n    );\n  }; // EXTERNAL MODULE: ./src/components/fields-step/ColumnDragObject.scss\n\n\n  var ColumnDragObject = __webpack_require__(14); // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragObject.tsx\n\n\n  var ColumnDragObject_ColumnDragObject = function ColumnDragObject_ColumnDragObject(_ref13) {\n    var dragState = _ref13.dragState;\n    var referenceBoxRef = Object(external_react_[\"useRef\"])(null); // @todo wrap in a no-events overlay to clip against screen edges\n\n    var dragBoxRef = Object(external_react_[\"useRef\"])(null);\n    var dragObjectPortal = dragState && dragState.pointerStartInfo ? Object(external_react_dom_[\"createPortal\"])(external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragObject\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragObject__positioner\",\n      ref: dragBoxRef\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragObject__holder\"\n    }, external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n      column: dragState.column,\n      isDragged: true\n    })))), document.body) : null; // set up initial position\n\n    var pointerStartInfo = dragState && dragState.pointerStartInfo;\n    Object(external_react_[\"useLayoutEffect\"])(function () {\n      if (!pointerStartInfo || !dragBoxRef.current) {\n        return;\n      }\n\n      var initialXY = pointerStartInfo.initialXY,\n          initialWidth = pointerStartInfo.initialWidth;\n      dragBoxRef.current.style.left = \"\".concat(initialXY[0], \"px\");\n      dragBoxRef.current.style.top = \"\".concat(initialXY[1], \"px\");\n      dragBoxRef.current.style.width = \"\".concat(initialWidth, \"px\"); // copy known font style from main content\n      // @todo consider other text style properties?\n\n      if (referenceBoxRef.current) {\n        var computedStyle = window.getComputedStyle(referenceBoxRef.current);\n        dragBoxRef.current.style.fontFamily = computedStyle.fontFamily;\n        dragBoxRef.current.style.fontSize = computedStyle.fontSize;\n        dragBoxRef.current.style.fontWeight = computedStyle.fontWeight;\n        dragBoxRef.current.style.fontStyle = computedStyle.fontStyle;\n        dragBoxRef.current.style.letterSpacing = computedStyle.letterSpacing;\n      }\n    }, [pointerStartInfo]); // subscribe to live position updates without state changes\n\n    Object(external_react_[\"useLayoutEffect\"])(function () {\n      if (dragState) {\n        dragState.updateListeners['dragObj'] = function (xy) {\n          if (!dragBoxRef.current) {\n            return;\n          }\n\n          dragBoxRef.current.style.left = \"\".concat(xy[0], \"px\");\n          dragBoxRef.current.style.top = \"\".concat(xy[1], \"px\");\n        };\n      }\n    }, [dragState]);\n    return external_react_default.a.createElement(\"div\", {\n      ref: referenceBoxRef\n    }, dragObjectPortal);\n  }; // EXTERNAL MODULE: ./src/components/fields-step/ColumnDragSourceArea.scss\n\n\n  var ColumnDragSourceArea = __webpack_require__(15); // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragSourceArea.tsx\n\n\n  var SOURCES_PAGE_SIZE = 5; // fraction of 10 for easier counting\n  // @todo readable status text if not mouse-drag\n\n  var SourceBox = function SourceBox(_ref14) {\n    var column = _ref14.column,\n        fieldAssignments = _ref14.fieldAssignments,\n        dragState = _ref14.dragState,\n        eventBinder = _ref14.eventBinder,\n        onSelect = _ref14.onSelect,\n        onUnassign = _ref14.onUnassign;\n    var isDragged = dragState ? column === dragState.column : false;\n    var isAssigned = Object(external_react_[\"useMemo\"])(function () {\n      return Object.keys(fieldAssignments).some(function (fieldName) {\n        return fieldAssignments[fieldName] === column.index;\n      });\n    }, [fieldAssignments, column]);\n    var eventHandlers = Object(external_react_[\"useMemo\"])(function () {\n      return eventBinder(column);\n    }, [eventBinder, column]);\n    var l10n = useLocale('fieldsStep');\n    return external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__box\"\n    }, external_react_default.a.createElement(\"div\", Object.assign({}, isAssigned ? {} : eventHandlers), external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n      column: column,\n      isAssigned: isAssigned,\n      isShadow: isDragged || isAssigned,\n      isDraggable: !dragState && !isDragged && !isAssigned\n    })), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__boxAction\"\n    }, isAssigned ? external_react_default.a.createElement(IconButton_IconButton, {\n      key: \"clear\" // key-prop helps clear focus on click\n      ,\n      label: l10n.clearAssignmentTooltip,\n      small: true,\n      type: \"replay\",\n      onClick: function onClick() {\n        onUnassign(column);\n      }\n    }) : external_react_default.a.createElement(IconButton_IconButton, {\n      key: \"dragSelect\" // key-prop helps clear focus on click\n      ,\n      focusOnly: true,\n      label: dragState && dragState.column === column ? l10n.unselectColumnTooltip : l10n.selectColumnTooltip,\n      small: true,\n      type: \"back\",\n      onClick: function onClick() {\n        onSelect(column);\n      }\n    })));\n  }; // @todo current page indicator (dots)\n\n\n  var ColumnDragSourceArea_ColumnDragSourceArea = function ColumnDragSourceArea_ColumnDragSourceArea(_ref15) {\n    var columns = _ref15.columns,\n        fieldAssignments = _ref15.fieldAssignments,\n        dragState = _ref15.dragState,\n        eventBinder = _ref15.eventBinder,\n        onSelect = _ref15.onSelect,\n        onUnassign = _ref15.onUnassign;\n\n    var _Object14 = Object(external_react_[\"useState\"])(0),\n        _Object15 = _slicedToArray(_Object14, 2),\n        page = _Object15[0],\n        setPage = _Object15[1];\n\n    var _Object16 = Object(external_react_[\"useState\"])(false),\n        _Object17 = _slicedToArray(_Object16, 2),\n        pageChanged = _Object17[0],\n        setPageChanged = _Object17[1];\n\n    var pageCount = Math.ceil(columns.length / SOURCES_PAGE_SIZE);\n    var start = page * SOURCES_PAGE_SIZE;\n    var pageContents = columns.slice(start, start + SOURCES_PAGE_SIZE).map(function (column, columnIndex) {\n      return external_react_default.a.createElement(SourceBox, {\n        key: columnIndex,\n        column: column,\n        fieldAssignments: fieldAssignments,\n        dragState: dragState,\n        eventBinder: eventBinder,\n        onSelect: onSelect,\n        onUnassign: onUnassign\n      });\n    });\n\n    while (pageContents.length < SOURCES_PAGE_SIZE) {\n      pageContents.push(external_react_default.a.createElement(\"div\", {\n        key: pageContents.length,\n        className: \"CSVImporter_ColumnDragSourceArea__pageFiller\"\n      }));\n    }\n\n    var l10n = useLocale('fieldsStep');\n    return external_react_default.a.createElement(\"section\", {\n      className: \"CSVImporter_ColumnDragSourceArea\",\n      \"aria-label\": l10n.dragSourceAreaCaption\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__control\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.previousColumnsTooltip,\n      type: \"back\",\n      disabled: page === 0,\n      onClick: function onClick() {\n        setPage(function (prev) {\n          return Math.max(0, prev - 1);\n        });\n        setPageChanged(true);\n      }\n    })), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__page\"\n    }, dragState && !dragState.pointerStartInfo ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\",\n      role: \"status\"\n    }, l10n.getDragSourceActiveStatus(dragState.column.code)) : // show page number if needed (and treat as status role if it has changed)\n    // @todo changing role to status does not seem to work\n    pageCount > 1 && external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\",\n      role: pageChanged ? 'status' : 'text'\n    }, l10n.getDragSourcePageIndicator(page + 1, pageCount)), pageContents), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragSourceArea__control\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.nextColumnsTooltip,\n      type: \"forward\",\n      disabled: page === pageCount - 1,\n      onClick: function onClick() {\n        setPage(function (prev) {\n          return Math.min(pageCount - 1, prev + 1);\n        });\n      }\n    })));\n  }; // EXTERNAL MODULE: ./src/components/fields-step/ColumnDragTargetArea.scss\n\n\n  var ColumnDragTargetArea = __webpack_require__(16); // CONCATENATED MODULE: ./src/components/fields-step/ColumnDragTargetArea.tsx\n\n\n  var TargetBox = function TargetBox(_ref16) {\n    var hasHeaders = _ref16.hasHeaders,\n        field = _ref16.field,\n        touched = _ref16.touched,\n        assignedColumn = _ref16.assignedColumn,\n        dragState = _ref16.dragState,\n        eventBinder = _ref16.eventBinder,\n        onHover = _ref16.onHover,\n        onAssign = _ref16.onAssign,\n        onUnassign = _ref16.onUnassign;\n    // wrap in ref to avoid re-triggering effect\n    var onHoverRef = Object(external_react_[\"useRef\"])(onHover);\n    onHoverRef.current = onHover; // respond to hover events when there is active mouse drag happening\n    // (not keyboard-emulated one)\n\n    var containerRef = Object(external_react_[\"useRef\"])(null);\n    var isHoveredRef = Object(external_react_[\"useRef\"])(false); // simple tracking of current hover state to avoid spamming onHover (not for display)\n\n    Object(external_react_[\"useEffect\"])(function () {\n      var container = containerRef.current;\n\n      if (!dragState || !dragState.pointerStartInfo || !container) {\n        return;\n      } // measure the current scroll-independent position\n\n\n      var rect = container.getBoundingClientRect();\n      var minX = rect.x;\n      var maxX = rect.x + rect.width;\n      var minY = rect.y;\n      var maxY = rect.y + rect.height; // listen for pointer movement (mouse or touch) and detect hover\n\n      var listeners = dragState.updateListeners;\n      var listenerName = \"field:\".concat(field.name);\n\n      listeners[listenerName] = function (xy) {\n        var isInBounds = xy[0] >= minX && xy[0] < maxX && xy[1] >= minY && xy[1] < maxY;\n\n        if (isInBounds !== isHoveredRef.current) {\n          // cannot use local var for isHovered state because the effect re-triggers after this\n          isHoveredRef.current = isInBounds;\n          onHoverRef.current(field.name, isInBounds);\n        }\n      }; // cleanup\n\n\n      return function () {\n        delete listeners[listenerName];\n      };\n    }, [dragState, field.name]); // if this field is the current highlighted drop target,\n    // get the originating column data for display\n\n    var sourceColumn = dragState && dragState.dropFieldName === field.name ? dragState.column : null; // see if currently assigned column is being dragged again\n\n    var isReDragged = dragState ? dragState.column === assignedColumn : false; // drag start handlers for columns that can be re-dragged (i.e. are assigned)\n\n    var dragStartHandlers = Object(external_react_[\"useMemo\"])(function () {\n      return assignedColumn && !isReDragged ? eventBinder(assignedColumn, field.name) : {};\n    }, [eventBinder, assignedColumn, isReDragged, field.name]);\n    var valueContents = Object(external_react_[\"useMemo\"])(function () {\n      if (sourceColumn) {\n        return external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n          rowCount: 3,\n          column: sourceColumn,\n          isDropIndicator: true\n        });\n      }\n\n      if (assignedColumn) {\n        return external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n          rowCount: 3,\n          column: assignedColumn,\n          isShadow: isReDragged,\n          isDraggable: !isReDragged\n        });\n      }\n\n      var hasError = touched && !field.isOptional;\n      return external_react_default.a.createElement(ColumnDragCard_ColumnDragCard, {\n        rowCount: 3,\n        hasHeaders: hasHeaders,\n        hasError: hasError\n      });\n    }, [hasHeaders, field, touched, assignedColumn, sourceColumn, isReDragged]);\n    var l10n = useLocale('fieldsStep'); // @todo mouse cursor changes to reflect draggable state\n\n    return external_react_default.a.createElement(\"section\", {\n      className: \"CSVImporter_ColumnDragTargetArea__box\",\n      \"aria-label\": field.isOptional ? l10n.getDragTargetOptionalCaption(field.label) : l10n.getDragTargetRequiredCaption(field.label),\n      ref: containerRef\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxLabel\",\n      \"aria-hidden\": true\n    }, field.label, field.isOptional ? null : external_react_default.a.createElement(\"b\", null, \"*\")), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxValue\"\n    }, !sourceColumn && !assignedColumn && external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxPlaceholderHelp\",\n      \"aria-hidden\": true\n    }, l10n.dragTargetPlaceholder), external_react_default.a.createElement(\"div\", Object.assign({}, dragStartHandlers), valueContents), dragState && !dragState.pointerStartInfo ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.getDragTargetAssignTooltip(dragState.column.code),\n      small: true,\n      type: \"forward\",\n      onClick: function onClick() {\n        return onAssign(field.name);\n      }\n    })) : !sourceColumn && assignedColumn && external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\"\n    }, external_react_default.a.createElement(IconButton_IconButton, {\n      label: l10n.dragTargetClearTooltip,\n      small: true,\n      type: \"close\",\n      onClick: function onClick() {\n        return onUnassign(assignedColumn);\n      }\n    }))));\n  };\n\n  var ColumnDragTargetArea_ColumnDragTargetArea = function ColumnDragTargetArea_ColumnDragTargetArea(_ref17) {\n    var hasHeaders = _ref17.hasHeaders,\n        fields = _ref17.fields,\n        columns = _ref17.columns,\n        fieldTouched = _ref17.fieldTouched,\n        fieldAssignments = _ref17.fieldAssignments,\n        dragState = _ref17.dragState,\n        eventBinder = _ref17.eventBinder,\n        onHover = _ref17.onHover,\n        onAssign = _ref17.onAssign,\n        onUnassign = _ref17.onUnassign;\n    var l10n = useLocale('fieldsStep');\n    return external_react_default.a.createElement(\"section\", {\n      className: \"CSVImporter_ColumnDragTargetArea\",\n      \"aria-label\": l10n.dragTargetAreaCaption\n    }, fields.map(function (field) {\n      var assignedColumnIndex = fieldAssignments[field.name];\n      return external_react_default.a.createElement(TargetBox, {\n        key: field.name,\n        field: field,\n        touched: fieldTouched[field.name],\n        hasHeaders: hasHeaders,\n        assignedColumn: assignedColumnIndex !== undefined ? columns[assignedColumnIndex] : null,\n        dragState: dragState,\n        eventBinder: eventBinder,\n        onHover: onHover,\n        onAssign: onAssign,\n        onUnassign: onUnassign\n      });\n    }));\n  }; // CONCATENATED MODULE: ./src/components/fields-step/FieldsStep.tsx\n\n\n  var FieldsStep = function FieldsStep(_ref18) {\n    var fileState = _ref18.fileState,\n        fields = _ref18.fields,\n        prevState = _ref18.prevState,\n        onChange = _ref18.onChange,\n        onAccept = _ref18.onAccept,\n        onCancel = _ref18.onCancel;\n    var onChangeRef = Object(external_react_[\"useRef\"])(onChange);\n    onChangeRef.current = onChange;\n    var columns = Object(external_react_[\"useMemo\"])(function () {\n      return generatePreviewColumns(fileState.firstRows, fileState.hasHeaders).map(function (item) {\n        return Object.assign(Object.assign({}, item), {\n          code: generateColumnCode(item.index)\n        });\n      });\n    }, [fileState]);\n    var initialAssignments = Object(external_react_[\"useMemo\"])(function () {\n      // prep insensitive/fuzzy match stems for known columns\n      // (this is ignored if there is already previous state to seed from)\n      var columnStems = columns.map(function (column) {\n        var trimmed = column.header && column.header.trim();\n\n        if (!trimmed) {\n          return undefined;\n        }\n\n        return trimmed.toLowerCase();\n      }); // pre-assign corresponding fields\n\n      var result = {};\n      var assignedColumnIndexes = [];\n      fields.forEach(function (field) {\n        // find by field stem\n        var fieldLabelStem = field.label.trim().toLowerCase(); // @todo consider normalizing other whitespace/non-letters\n\n        var matchingColumnIndex = columnStems.findIndex(function (columnStem, columnIndex) {\n          // no headers or no meaningful stem value\n          if (columnStem === undefined) {\n            return false;\n          } // always check against assigning twice\n\n\n          if (assignedColumnIndexes[columnIndex]) {\n            return false;\n          }\n\n          return columnStem === fieldLabelStem;\n        }); // assign if found\n\n        if (matchingColumnIndex !== -1) {\n          assignedColumnIndexes[matchingColumnIndex] = true;\n          result[field.name] = matchingColumnIndex;\n        }\n      });\n      return result;\n    }, [fields, columns]); // track which fields need to show validation warning\n\n    var _Object18 = Object(external_react_[\"useState\"])({}),\n        _Object19 = _slicedToArray(_Object18, 2),\n        fieldTouched = _Object19[0],\n        setFieldTouched = _Object19[1];\n\n    var _Object20 = Object(external_react_[\"useState\"])(null),\n        _Object21 = _slicedToArray(_Object20, 2),\n        validationError = _Object21[0],\n        setValidationError = _Object21[1];\n\n    var _useColumnDragState = useColumnDragState(fields, prevState ? prevState.fieldAssignments : initialAssignments, function (fieldName) {\n      setFieldTouched(function (prev) {\n        if (prev[fieldName]) {\n          return prev;\n        }\n\n        var copy = Object.assign({}, prev);\n        copy[fieldName] = true;\n        return copy;\n      });\n    }),\n        fieldAssignments = _useColumnDragState.fieldAssignments,\n        dragState = _useColumnDragState.dragState,\n        dragEventBinder = _useColumnDragState.dragEventBinder,\n        dragHoverHandler = _useColumnDragState.dragHoverHandler,\n        columnSelectHandler = _useColumnDragState.columnSelectHandler,\n        assignHandler = _useColumnDragState.assignHandler,\n        unassignHandler = _useColumnDragState.unassignHandler; // notify of current state\n\n\n    Object(external_react_[\"useEffect\"])(function () {\n      onChangeRef.current({\n        fieldAssignments: Object.assign({}, fieldAssignments)\n      });\n    }, [fieldAssignments]);\n    var l10n = useLocale('fieldsStep');\n    return external_react_default.a.createElement(ImporterFrame_ImporterFrame, {\n      fileName: fileState.file.name,\n      subtitle: l10n.stepSubtitle,\n      error: validationError,\n      onCancel: onCancel,\n      onNext: function onNext() {\n        // mark all fields as touched\n        var fullTouchedMap = {};\n        fields.some(function (field) {\n          fullTouchedMap[field.name] = true;\n        });\n        setFieldTouched(fullTouchedMap); // submit if validation succeeds\n\n        var hasUnassignedRequired = fields.some(function (field) {\n          return !field.isOptional && fieldAssignments[field.name] === undefined;\n        });\n\n        if (!hasUnassignedRequired) {\n          onAccept();\n        } else {\n          setValidationError(l10n.requiredFieldsError);\n        }\n      },\n      nextLabel: l10n.nextButton\n    }, external_react_default.a.createElement(ColumnDragSourceArea_ColumnDragSourceArea, {\n      columns: columns,\n      fieldAssignments: fieldAssignments,\n      dragState: dragState,\n      eventBinder: dragEventBinder,\n      onSelect: columnSelectHandler,\n      onUnassign: unassignHandler\n    }), external_react_default.a.createElement(ColumnDragTargetArea_ColumnDragTargetArea, {\n      hasHeaders: fileState.hasHeaders,\n      fields: fields,\n      columns: columns,\n      fieldTouched: fieldTouched,\n      fieldAssignments: fieldAssignments,\n      dragState: dragState,\n      eventBinder: dragEventBinder,\n      onHover: dragHoverHandler,\n      onAssign: assignHandler,\n      onUnassign: unassignHandler\n    }), external_react_default.a.createElement(ColumnDragObject_ColumnDragObject, {\n      dragState: dragState\n    }));\n  }; // EXTERNAL MODULE: ./src/components/ProgressDisplay.scss\n\n\n  var ProgressDisplay = __webpack_require__(17); // CONCATENATED MODULE: ./src/components/ProgressDisplay.tsx\n  // compute actual UTF-8 bytes used by a string\n  // (inspired by https://stackoverflow.com/questions/10576905/how-to-convert-javascript-unicode-notation-code-to-utf-8)\n\n\n  function countUTF8Bytes(item) {\n    // re-encode into UTF-8\n    var escaped = encodeURIComponent(item); // convert byte escape sequences into single characters\n\n    var normalized = escaped.replace(/%\\d\\d/g, '_');\n    return normalized.length;\n  }\n\n  function ProgressDisplay_ProgressDisplay(_ref19) {\n    var fileState = _ref19.fileState,\n        fieldsState = _ref19.fieldsState,\n        externalPreview = _ref19.externalPreview,\n        processChunk = _ref19.processChunk,\n        onStart = _ref19.onStart,\n        onComplete = _ref19.onComplete,\n        onRestart = _ref19.onRestart,\n        onClose = _ref19.onClose;\n\n    var _Object22 = Object(external_react_[\"useState\"])(0),\n        _Object23 = _slicedToArray(_Object22, 2),\n        progressCount = _Object23[0],\n        setProgressCount = _Object23[1];\n\n    var _Object24 = Object(external_react_[\"useState\"])(false),\n        _Object25 = _slicedToArray(_Object24, 2),\n        isComplete = _Object25[0],\n        setIsComplete = _Object25[1];\n\n    var _Object26 = Object(external_react_[\"useState\"])(null),\n        _Object27 = _slicedToArray(_Object26, 2),\n        error = _Object27[0],\n        setError = _Object27[1];\n\n    var _Object28 = Object(external_react_[\"useState\"])(false),\n        _Object29 = _slicedToArray(_Object28, 2),\n        isDismissed = _Object29[0],\n        setIsDismissed = _Object29[1]; // prevents double-clicking finish\n    // info object exposed to the progress callbacks\n\n\n    var importInfo = Object(external_react_[\"useMemo\"])(function () {\n      var fieldList = Object.keys(fieldsState.fieldAssignments);\n      var columnSparseList = [];\n      fieldList.forEach(function (field) {\n        var col = fieldsState.fieldAssignments[field];\n\n        if (col !== undefined) {\n          columnSparseList[col] = field;\n        }\n      });\n      return {\n        file: fileState.file,\n        preview: externalPreview,\n        fields: fieldList,\n        columnFields: [].concat(columnSparseList)\n      };\n    }, [fileState, fieldsState, externalPreview]); // estimate number of rows\n\n    var estimatedRowCount = Object(external_react_[\"useMemo\"])(function () {\n      // sum up sizes of all the parsed preview rows and get estimated average\n      var totalPreviewRowBytes = fileState.firstRows.reduce(function (prevCount, row) {\n        var rowBytes = row.reduce(function (prev, item) {\n          return prev + countUTF8Bytes(item) + 1; // add a byte for separator or newline\n        }, 0);\n        return prevCount + rowBytes;\n      }, 0);\n      var averagePreviewRowSize = totalPreviewRowBytes / fileState.firstRows.length; // divide file size by estimated row size (or fall back to a sensible amount)\n\n      return averagePreviewRowSize > 1 ? fileState.file.size / averagePreviewRowSize : 100;\n    }, [fileState]); // notify on start of processing\n    // (separate effect in case of errors)\n\n    var onStartRef = Object(external_react_[\"useRef\"])(onStart); // wrap in ref to avoid re-triggering (only first instance is needed)\n\n    Object(external_react_[\"useEffect\"])(function () {\n      if (onStartRef.current) {\n        onStartRef.current(importInfo);\n      }\n    }, [importInfo]); // notify on end of processing\n    // (separate effect in case of errors)\n\n    var onCompleteRef = Object(external_react_[\"useRef\"])(onComplete); // wrap in ref to avoid re-triggering\n\n    onCompleteRef.current = onComplete;\n    Object(external_react_[\"useEffect\"])(function () {\n      if (isComplete && onCompleteRef.current) {\n        onCompleteRef.current(importInfo);\n      }\n    }, [importInfo, isComplete]); // ensure status gets focus when complete, in case status role is not read out\n\n    var statusRef = Object(external_react_[\"useRef\"])(null);\n    Object(external_react_[\"useEffect\"])(function () {\n      if ((isComplete || error) && statusRef.current) {\n        statusRef.current.focus();\n      }\n    }, [isComplete, error]); // perform main async parse\n\n    var processChunkRef = Object(external_react_[\"useRef\"])(processChunk); // wrap in ref to avoid re-triggering\n\n    var asyncLockRef = Object(external_react_[\"useRef\"])(0);\n    Object(external_react_[\"useEffect\"])(function () {\n      var oplock = asyncLockRef.current;\n      processFile(Object.assign(Object.assign({}, fileState), {\n        fieldAssignments: fieldsState.fieldAssignments\n      }), function (deltaCount) {\n        // ignore if stale\n        if (oplock !== asyncLockRef.current) {\n          return; // @todo signal abort\n        }\n\n        setProgressCount(function (prev) {\n          return prev + deltaCount;\n        });\n      }, processChunkRef.current).then(function () {\n        // ignore if stale\n        if (oplock !== asyncLockRef.current) {\n          return;\n        }\n\n        setIsComplete(true);\n      }, function (error) {\n        // ignore if stale\n        if (oplock !== asyncLockRef.current) {\n          return;\n        }\n\n        setError(error);\n      });\n      return function () {\n        // invalidate current oplock on change or unmount\n        asyncLockRef.current += 1;\n      };\n    }, [fileState, fieldsState]); // simulate asymptotic progress percentage\n\n    var progressPercentage = Object(external_react_[\"useMemo\"])(function () {\n      if (isComplete) {\n        return 100;\n      } // inputs hand-picked so that correctly estimated total is about 75% of the bar\n\n\n      var progressPower = 2.5 * (progressCount / estimatedRowCount);\n      var progressLeft = Math.pow(0.5, progressPower); // convert to .1 percent precision for smoother bar display\n\n      return Math.floor(1000 - 1000 * progressLeft) / 10;\n    }, [estimatedRowCount, progressCount, isComplete]);\n    var l10n = useLocale('progressStep');\n    return external_react_default.a.createElement(ImporterFrame_ImporterFrame, {\n      fileName: fileState.file.name,\n      subtitle: l10n.stepSubtitle,\n      error: error && (error.message || String(error)),\n      secondaryDisabled: !isComplete || isDismissed,\n      secondaryLabel: onRestart && onClose ? l10n.uploadMoreButton : undefined,\n      onSecondary: onRestart && onClose ? onRestart : undefined,\n      nextDisabled: !isComplete || isDismissed,\n      nextLabel: !!(onClose || onRestart) && (onRestart ? l10n.uploadMoreButton : l10n.finishButton),\n      onNext: function onNext() {\n        if (onClose) {\n          setIsDismissed(true);\n          onClose(importInfo);\n        } else if (onRestart) {\n          onRestart();\n        }\n      }\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay\"\n    }, isComplete || error ? external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__status\",\n      role: \"status\",\n      tabIndex: -1,\n      ref: statusRef\n    }, error ? l10n.statusError : l10n.statusComplete) : external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__status -pending\",\n      role: \"status\"\n    }, l10n.statusPending), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__count\",\n      role: \"text\"\n    }, external_react_default.a.createElement(\"var\", null, l10n.processedRowsLabel), \" \", progressCount), external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__progressBar\"\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_ProgressDisplay__progressBarIndicator\",\n      style: {\n        width: \"\".concat(progressPercentage, \"%\")\n      }\n    }))));\n  } // EXTERNAL MODULE: ./src/components/Importer.scss\n\n\n  var Importer = __webpack_require__(18); // CONCATENATED MODULE: ./src/components/Importer.tsx\n\n\n  var __rest = undefined && undefined.__rest || function (s, e) {\n    var t = {};\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    }\n\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n  };\n\n  var FieldDefinitionContext = external_react_default.a.createContext(null);\n  var fieldIdCount = 0; // defines a field to be filled from file column during import\n\n  var ImporterField = function ImporterField(_ref20) {\n    var name = _ref20.name,\n        label = _ref20.label,\n        optional = _ref20.optional;\n    // @todo this is not SSR-compatible\n    var fieldId = Object(external_react_[\"useMemo\"])(function () {\n      return fieldIdCount += 1;\n    }, []);\n    var fieldSetter = Object(external_react_[\"useContext\"])(FieldDefinitionContext); // update central list as needed\n\n    Object(external_react_[\"useEffect\"])(function () {\n      if (!fieldSetter) {\n        console.error('importer field must be a child of importer'); // @todo\n\n        return;\n      }\n\n      fieldSetter(function (prev) {\n        var newField = {\n          id: fieldId,\n          name: name,\n          label: label,\n          isOptional: !!optional\n        };\n\n        var copy = _toConsumableArray(prev);\n\n        var existingIndex = copy.findIndex(function (item) {\n          return item.name === name;\n        }); // preserve existing array position if possible\n        // @todo keep both copies in a map to deal with dynamic fields better\n\n        if (existingIndex === -1) {\n          copy.push(newField);\n        } else {\n          copy[existingIndex] = newField;\n        }\n\n        return copy;\n      });\n    }, [fieldId, fieldSetter, name, label, optional]); // on component unmount, remove this field from list by ID\n\n    Object(external_react_[\"useEffect\"])(function () {\n      if (!fieldSetter) {\n        console.error('importer field must be a child of importer'); // @todo\n\n        return;\n      }\n\n      return function () {\n        fieldSetter(function (prev) {\n          return prev.filter(function (field) {\n            return field.id !== fieldId;\n          });\n        });\n      };\n    }, [fieldId, fieldSetter]);\n    return null;\n  };\n\n  function Importer_Importer(_a) {\n    var assumeNoHeaders = _a.assumeNoHeaders,\n        restartable = _a.restartable,\n        processChunk = _a.processChunk,\n        onStart = _a.onStart,\n        onComplete = _a.onComplete,\n        onClose = _a.onClose,\n        content = _a.children,\n        locale = _a.locale,\n        customPapaParseConfig = __rest(_a, [\"assumeNoHeaders\", \"restartable\", \"processChunk\", \"onStart\", \"onComplete\", \"onClose\", \"children\", \"locale\"]); // helper to combine our displayed content and the user code that provides field definitions\n\n\n    var _Object30 = Object(external_react_[\"useState\"])([]),\n        _Object31 = _slicedToArray(_Object30, 2),\n        fields = _Object31[0],\n        setFields = _Object31[1];\n\n    var _Object32 = Object(external_react_[\"useState\"])(null),\n        _Object33 = _slicedToArray(_Object32, 2),\n        fileState = _Object33[0],\n        setFileState = _Object33[1];\n\n    var _Object34 = Object(external_react_[\"useState\"])(false),\n        _Object35 = _slicedToArray(_Object34, 2),\n        fileAccepted = _Object35[0],\n        setFileAccepted = _Object35[1];\n\n    var _Object36 = Object(external_react_[\"useState\"])(null),\n        _Object37 = _slicedToArray(_Object36, 2),\n        fieldsState = _Object37[0],\n        setFieldsState = _Object37[1];\n\n    var _Object38 = Object(external_react_[\"useState\"])(false),\n        _Object39 = _slicedToArray(_Object38, 2),\n        fieldsAccepted = _Object39[0],\n        setFieldsAccepted = _Object39[1]; // reset field assignments when file changes\n\n\n    var activeFile = fileState && fileState.file;\n    Object(external_react_[\"useEffect\"])(function () {\n      if (activeFile) {\n        setFieldsState(null);\n      }\n    }, [activeFile]);\n    var externalPreview = Object(external_react_[\"useMemo\"])(function () {\n      // generate stable externally-visible data objects\n      var externalColumns = fileState && generatePreviewColumns(fileState.firstRows, fileState.hasHeaders);\n      return fileState && externalColumns && {\n        rawData: fileState.firstChunk,\n        columns: externalColumns,\n        skipHeaders: !fileState.hasHeaders,\n        parseWarning: fileState.parseWarning\n      };\n    }, [fileState]); // render provided child content that defines the fields\n\n    var contentNodes = Object(external_react_[\"useMemo\"])(function () {\n      return typeof content === 'function' ? content({\n        file: fileState && fileState.file,\n        preview: externalPreview\n      }) : content;\n    }, [fileState, externalPreview, content]);\n    var contentWrap = external_react_default.a.createElement(FieldDefinitionContext.Provider, {\n      value: setFields\n    }, contentNodes); // fall back to enUS if no default locale provided\n\n    locale = locale !== null && locale !== void 0 ? locale : enUS;\n\n    if (!fileAccepted || fileState === null || externalPreview === null) {\n      return external_react_default.a.createElement(LocaleContext.Provider, {\n        value: locale\n      }, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_Importer\"\n      }, external_react_default.a.createElement(FileStep_FileStep, {\n        customConfig: customPapaParseConfig,\n        assumeNoHeaders: assumeNoHeaders,\n        prevState: fileState,\n        onChange: function onChange(parsedPreview) {\n          setFileState(parsedPreview);\n        },\n        onAccept: function onAccept() {\n          setFileAccepted(true);\n        }\n      }), contentWrap));\n    }\n\n    if (!fieldsAccepted || fieldsState === null) {\n      return external_react_default.a.createElement(LocaleContext.Provider, {\n        value: locale\n      }, external_react_default.a.createElement(\"div\", {\n        className: \"CSVImporter_Importer\"\n      }, external_react_default.a.createElement(FieldsStep, {\n        fileState: fileState,\n        fields: fields,\n        prevState: fieldsState,\n        onChange: function onChange(state) {\n          setFieldsState(state);\n        },\n        onAccept: function onAccept() {\n          setFieldsAccepted(true);\n        },\n        onCancel: function onCancel() {\n          // keep existing preview data and assignments\n          setFileAccepted(false);\n        }\n      }), contentWrap));\n    }\n\n    return external_react_default.a.createElement(LocaleContext.Provider, {\n      value: locale\n    }, external_react_default.a.createElement(\"div\", {\n      className: \"CSVImporter_Importer\"\n    }, external_react_default.a.createElement(ProgressDisplay_ProgressDisplay, {\n      fileState: fileState,\n      fieldsState: fieldsState,\n      externalPreview: externalPreview,\n      processChunk: processChunk,\n      onStart: onStart,\n      onRestart: restartable ? function () {\n        // reset all state\n        setFileState(null);\n        setFileAccepted(false);\n        setFieldsState(null);\n        setFieldsAccepted(false);\n      } : undefined,\n      onComplete: onComplete,\n      onClose: onClose\n    }), contentWrap));\n  } // CONCATENATED MODULE: ./src/index.ts\n\n  /***/\n\n}\n/******/\n]);","map":{"version":3,"mappings":"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A;MACA,CAtCA;MAuCA;MACAC,cAxCA,0BAwCAJ,KAxCA,EAwCAC,QAxCA,EAwCA;QACA;QACAX;QACAI;QACAC;QACAQ;MACA,CA9CA;MA+CAE,KA/CA,mBA+CA;QACA;UACAb;YACAc;UACA,CAFA;QAGA;;QACA;MACA,CAtDA;MAuDAC,MAvDA,oBAuDA;QACA;UACAD,gBADA,CACA;;UACAd;UACAc;QACA;;QACA;MACA;IA9DA,EA9CA,CA8GA;;IACA;EACA;;EACA;IACA;IACA;MACA;MACA;MACA;;MACA;QACA;QACA;UACA;YACAE,sCADA;YAEAC;UAFA;QAIA,CAPA,CAQA;;;QACA,+CATA,CAUA;;QACA;UACAC;QACA;;QACA3B;UACA0B,UADA;UAEAD,qBAFA;UAGAG,uCAHA;UAIAC,4BAJA;UAKAC,yBALA;UAMAC;QANA;MAQA,CA1BA,CA2BA;MACA;MACA;;;MACA;MACAC;QAAAC;QAAAC;QAAAC;UACAnC;YACAyB,kBADA;YAEAC;UAFA;QAIA,CALA;QAKAU;UACAP;QACA,CAPA;QAOAQ;UAAA;UAAA;UACAC;YACA;cAAA;YAAA;YACAX;UACA,CAHA;;UAIA;YACAY;UACA,CAPA,CAQA;UACA;;;UACA;YACAC,mBADA,CACA;;YACAC;YACAC;UACA;QACA,CAtBA;QAsBAC;MAtBA;IAuBA,CAtDA,EAsDAC,KAtDA,CAsDA;MACA;QACAnB,iBADA;QAEAC;MAFA;IAIA,CA3DA;EA4DA;;EACA;IACA;IAAA;IAAA;IAAA;IACA,+CAFA,CAGA;;IACA;MACA;MACA;MACA,uBAHA,CAIA;MACA;;MACA;MACAM;QAAAC;QAAAE;UACAjC;QACA,CAFA;QAEAmC;UAAA;UACA;UACAG,mBAFA,CAEA;;UACAC;UACA;UACA;YACA;cAAA;YAAA;YACA;YACAI;cACA;;cACA;gBACAC;cACA;YACA,CALA;YAMA,cATA,CASA;UACA,CAVA,EALA,CAgBA;;UACA;YACAC;UACA,CAnBA,CAoBA;;;UACA;YACAC;UADA;UAGAC,8BAxBA,CAyBA;;UACAC,4BA1BA,CA2BA;UACA;;UACA;YACA,4DADA,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AAgE;QAAAS;MAAA,EATA,CAHA;IAaA,CArBA,EAqBA,2BArBA;;IAsBA;MACA;QAAAC;UAAA;QAAA;MAAA;IACA;;IACA;MAAAC;MAAAC;MAAAC;QACA;UACA;QACA;;QACAC;MACA,CALA;MAKAC;QAAA;MAAA,CALA;MAKA7B;IALA,GAKA8B;MAAAnF;IAAA,6BALA;EAMA,CAtFA;ECTA;;;EACA;IACA;IACA;MACA;IACA,CAJA,CAKA;IACA;;;IACA;IACA;IACA;;IACA;MACAoF;MACAC;MACAC;IACA,CAdA,CAeA;;;IACA;IACA;;IACA;MACA;MACAC,qDAFA,CAEA;MACA;;MACAC;IACA;;IACA;EACA,EACA;;;EACA;IACA;;IACA;MACA;QAAA;MAAA;MACA;MACA;QACAC,YADA;QAEAC,mBAFA;QAGAC;MAHA;IAKA,CARA;EASA;;;;;;ECrCA;IACA;IACA;IACAC;;IACA;IAAA;IAAA;IAAA;;IACA;IAAA;IAAA;IAAA,uCALA,CAMA;;;IACArJ;MACA;QAAA;UAAA;QAAA;MAAA;;MACA;QACA;QACAsJ;UACA;UACAC;YACA;UACA,CAFA;UAGA;QACA,CANA;MAOA;IACA,CAZA,EAYA,0BAZA;IAaA;MACAD;QACA,8CADA,CAEA;;QACAtJ;UACA;YACA;UACA;QACA,CAJA,EAHA,CAQA;;QACA;UACAwJ;QACA;;QACA;MACA,CAbA,EADA,CAeA;;MACA;QACAH;MACA;IACA,CAnBA,EAmBA,EAnBA;IAoBA;MAAA;MAAA;MAAA;MAAA;MAAA;;MACA;QACA;QACA;QACAhI;;QACA;QAAA;QAAA;;QACAoI;UACAC;YACAC,aADA;YAEAC,2DACAvI,+BADA,GAEA;UAJA,CADA;UAOAwI,cAPA;UAQAC,mEARA;UASAC;QATA;MAWA,CAhBA,MAiBA;QACAN;;QACA;UACAO;QACA;MACA,CAvBA,CAwBA;;;MACA;QACA;;QACA;UAAA;UACAC;QACA;MACA;IACA,CA/BA,EA+BA,EA/BA,EAxCA,CAwEA;IACA;;IACAjK;MACA;QACAkK;MACA,CAFA,MAGA;QACA;QACA;UACAA;QACA,CAFA,EAE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","names":["i","l","exports","modules","module","__webpack_require__","Object","enumerable","get","value","resolve","step","reject","result","streamReader","stream","decoder","isStopped","done","pausePromise","lastChunkString","dataHandler","endHandler","chunkString","readable","read","on","event","callback","runReaderPump","errorHandler","removeListener","pause","pauseResolver","resume","parseError","file","rowAccumulator","parseWarning","firstChunk","firstRows","isSingleLine","external_papaparse_default","chunkSize","preview","error","beforeFirstChunk","chunk","data","firstWarning","nodeStream","parser","reportSuccess","complete","catch","fieldNames","record","skipLine","startIndex","processedCount","reportProgress","setTimeout","whenConsumed","className","disabled","onClick","external_react_default","general","goToPreviousStepTooltip","fileStep","initialDragDropPrompt","activeDragDropPrompt","getImportError","getDataFormatError","goBackButton","nextButton","rawFileContentsHeading","previewImportHeading","dataHasHeadersCheckbox","previewLoadingStatus","fieldsStep","stepSubtitle","requiredFieldsError","dragSourceAreaCaption","getDragSourcePageIndicator","getDragSourceActiveStatus","nextColumnsTooltip","previousColumnsTooltip","clearAssignmentTooltip","selectColumnTooltip","unselectColumnTooltip","dragTargetAreaCaption","getDragTargetOptionalCaption","getDragTargetRequiredCaption","dragTargetPlaceholder","getDragTargetAssignTooltip","dragTargetClearTooltip","columnCardDummyHeader","getColumnCardHeader","progressStep","uploadMoreButton","finishButton","statusError","statusComplete","statusPending","processedRowsLabel","subtitleRef","titleRef","label","type","tabIndex","ref","subtitle","children","role","secondaryLabel","nextLabel","onSelectedRef","onDrop","isDragActive","chunkSlice","chunkHasMore","warning","onCancelClick","headerRow","key","customConfigRef","assumeNoHeadersRef","onChangeRef","papaParseConfig","hasHeaders","setPreview","parsePreview","setPapaParseConfig","setHasHeaders","asyncLockRef","l10n","checked","onChange","rows","onSelected","fileName","nextDisabled","onNext","onAccept","onCancel","reportBlock","digitCount","base","next","remainder","digits","index","header","values","onTouchedRef","setFieldAssignments","removedFieldNames","copy","setDragState","pointerStartInfo","initialXY","initialWidth","column","dropFieldName","updateListeners","internalAssignHandler","listeners","document","clearTimeout","fieldAssignments","dragState","dragEventBinder","dragHoverHandler","columnSelectHandler","assignHandler","unassignHandler","code","isDummy","headerValue","isDragged","dragBoxRef","eventBinder","isAssigned","isShadow","isDraggable","small","onUnassign","focusOnly","onSelect","slice","start","map","pageContents","setPage","setPageChanged","pageCount","onHoverRef","isHoveredRef","rowCount","isDropIndicator","hasError","field","assignedColumn","touched","columns","onHover","onAssign","fields","assignedColumnIndexes","setFieldTouched","fullTouchedMap","setValidationError","fieldTouched","fieldList","columnSparseList","columnFields","fileState","onStartRef","onCompleteRef","statusRef","processFile","setProgressCount","processChunkRef","then","setIsComplete","setError","secondaryDisabled","onSecondary","onRestart","setIsDismissed","onClose","isComplete","progressCount","style","width","t","console","fieldSetter","id","name","isOptional","setFieldsState","generatePreviewColumns","externalColumns","rawData","skipHeaders","content","locale","customConfig","assumeNoHeaders","prevState","setFileState","setFileAccepted","contentWrap","setFieldsAccepted","fieldsState","externalPreview","processChunk","onStart","undefined","onComplete"],"sources":["webpack:///webpack/bootstrap","webpack:///src/components/TextButton.scss?9052","webpack:///src/components/IconButton.scss?8012","webpack:///src/components/ImporterFrame.scss?9c61","webpack:///src/components/file-step/FileSelector.scss?dd56","webpack:///src/components/file-step/FormatErrorMessage.scss?898f","webpack:///src/components/file-step/FormatRawPreview.scss?0237","webpack:///src/components/file-step/FormatDataRowPreview.scss?bb3a","webpack:///src/components/file-step/FileStep.scss?8c88","webpack:///src/components/fields-step/ColumnDragCard.scss?0c54","webpack:///src/components/fields-step/ColumnDragObject.scss?1da5","webpack:///src/components/fields-step/ColumnDragSourceArea.scss?fdb8","webpack:///src/components/fields-step/ColumnDragTargetArea.scss?aac4","webpack:///src/components/ProgressDisplay.scss?6ad0","webpack:///src/components/Importer.scss?f3ca","webpack:///src/parser.ts","webpack:///src/components/TextButton.tsx","webpack:///src/components/IconButton.tsx","webpack:///src/locale/index.ts","webpack:///src/locale/LocaleContext.tsx","webpack:///src/components/ImporterFrame.tsx","webpack:///src/components/file-step/FileSelector.tsx","webpack:///src/components/file-step/FormatErrorMessage.tsx","webpack:///src/components/file-step/FormatRawPreview.tsx","webpack:///src/components/file-step/FormatDataRowPreview.tsx","webpack:///src/components/file-step/FileStep.tsx","webpack:///src/components/fields-step/ColumnPreview.tsx","webpack:///src/components/fields-step/ColumnDragState.tsx","webpack:///src/components/fields-step/ColumnDragCard.tsx","webpack:///src/components/fields-step/ColumnDragObject.tsx","webpack:///src/components/fields-step/ColumnDragSourceArea.tsx","webpack:///src/components/fields-step/ColumnDragTargetArea.tsx","webpack:///src/components/fields-step/FieldsStep.tsx","webpack:///src/components/ProgressDisplay.tsx","webpack:///src/components/Importer.tsx"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 19);\n","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport Papa from 'papaparse';\r\nexport const PREVIEW_ROW_COUNT = 5;\r\n// polyfill as implemented in https://github.com/eligrey/Blob.js/blob/master/Blob.js#L653\r\n// (this is for Safari pre v14.1)\r\nfunction streamForBlob(blob) {\r\n    if (blob.stream) {\r\n        return blob.stream();\r\n    }\r\n    const res = new Response(blob);\r\n    if (res.body) {\r\n        return res.body;\r\n    }\r\n    throw new Error('This browser does not support client-side file reads');\r\n}\r\n// incredibly cheap wrapper exposing a subset of stream.Readable interface just for PapaParse usage\r\n// @todo chunk size\r\nfunction nodeStreamWrapper(stream, encoding) {\r\n    let dataHandler = null;\r\n    let endHandler = null;\r\n    let errorHandler = null;\r\n    let isStopped = false;\r\n    let pausePromise = null;\r\n    let pauseResolver = null;\r\n    function runReaderPump() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // ensure this is truly in the next tick after uncorking\r\n            yield Promise.resolve();\r\n            const streamReader = stream.getReader();\r\n            const decoder = new TextDecoder(encoding); // this also strips BOM by default\r\n            try {\r\n                // main reader pump loop\r\n                while (!isStopped) {\r\n                    // perform read from upstream\r\n                    const { done, value } = yield streamReader.read();\r\n                    // wait if we became paused since last data event\r\n                    if (pausePromise) {\r\n                        yield pausePromise;\r\n                    }\r\n                    // check again if stopped and unlistened\r\n                    if (isStopped || !dataHandler || !endHandler) {\r\n                        return;\r\n                    }\r\n                    // final data flush and end notification\r\n                    if (done) {\r\n                        const lastChunkString = decoder.decode(value); // value is empty but pass just in case\r\n                        if (lastChunkString) {\r\n                            dataHandler(lastChunkString);\r\n                        }\r\n                        endHandler(undefined);\r\n                        return;\r\n                    }\r\n                    // otherwise, normal data event after stream-safe decoding\r\n                    const chunkString = decoder.decode(value, { stream: true });\r\n                    dataHandler(chunkString);\r\n                }\r\n            }\r\n            finally {\r\n                // always release the lock\r\n                streamReader.releaseLock();\r\n            }\r\n        });\r\n    }\r\n    const self = {\r\n        // marker properties to make PapaParse think this is a Readable object\r\n        readable: true,\r\n        read() {\r\n            throw new Error('only flowing mode is emulated');\r\n        },\r\n        on(event, callback) {\r\n            switch (event) {\r\n                case 'data':\r\n                    if (dataHandler) {\r\n                        throw new Error('two data handlers not supported');\r\n                    }\r\n                    dataHandler = callback;\r\n                    // flowing state started, run the main pump loop\r\n                    runReaderPump().catch((error) => {\r\n                        if (errorHandler) {\r\n                            errorHandler(error);\r\n                        }\r\n                        else {\r\n                            // rethrow to show error in console\r\n                            throw error;\r\n                        }\r\n                    });\r\n                    return;\r\n                case 'end':\r\n                    if (endHandler) {\r\n                        throw new Error('two end handlers not supported');\r\n                    }\r\n                    endHandler = callback;\r\n                    return;\r\n                case 'error':\r\n                    if (errorHandler) {\r\n                        throw new Error('two error handlers not supported');\r\n                    }\r\n                    errorHandler = callback;\r\n                    return;\r\n            }\r\n            throw new Error('unknown stream shim event: ' + event);\r\n        },\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        removeListener(event, callback) {\r\n            // stop and clear everything for simplicity\r\n            isStopped = true;\r\n            dataHandler = null;\r\n            endHandler = null;\r\n            errorHandler = null;\r\n        },\r\n        pause() {\r\n            if (!pausePromise) {\r\n                pausePromise = new Promise((resolve) => {\r\n                    pauseResolver = resolve;\r\n                });\r\n            }\r\n            return self;\r\n        },\r\n        resume() {\r\n            if (pauseResolver) {\r\n                pauseResolver(); // waiting code will proceed in next tick\r\n                pausePromise = null;\r\n                pauseResolver = null;\r\n            }\r\n            return self;\r\n        }\r\n    };\r\n    // pass ourselves off as a real Node stream\r\n    return self;\r\n}\r\nexport function parsePreview(file, customConfig) {\r\n    // wrap synchronous errors in promise\r\n    return new Promise((resolve) => {\r\n        let firstChunk = null;\r\n        let firstWarning = undefined;\r\n        const rowAccumulator = [];\r\n        function reportSuccess() {\r\n            // PapaParse normally complains first anyway, but might as well flag it\r\n            if (rowAccumulator.length === 0) {\r\n                return {\r\n                    parseError: new Error('File is empty'),\r\n                    file\r\n                };\r\n            }\r\n            // remember whether this file has only one line\r\n            const isSingleLine = rowAccumulator.length === 1;\r\n            // fill preview with blanks if needed\r\n            while (rowAccumulator.length < PREVIEW_ROW_COUNT) {\r\n                rowAccumulator.push([]);\r\n            }\r\n            resolve({\r\n                file,\r\n                parseError: undefined,\r\n                parseWarning: firstWarning || undefined,\r\n                firstChunk: firstChunk || '',\r\n                firstRows: rowAccumulator,\r\n                isSingleLine\r\n            });\r\n        }\r\n        // use our own multibyte-safe streamer, bail after first chunk\r\n        // (this used to add skipEmptyLines but that was hiding possible parse errors)\r\n        // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\r\n        const nodeStream = nodeStreamWrapper(streamForBlob(file), customConfig.encoding || 'utf-8');\r\n        Papa.parse(nodeStream, Object.assign(Object.assign({}, customConfig), { chunkSize: 10000, preview: PREVIEW_ROW_COUNT, error: (error) => {\r\n                resolve({\r\n                    parseError: error,\r\n                    file\r\n                });\r\n            }, beforeFirstChunk: (chunk) => {\r\n                firstChunk = chunk;\r\n            }, chunk: ({ data, errors }, parser) => {\r\n                data.forEach((row) => {\r\n                    const stringRow = row.map((item) => typeof item === 'string' ? item : '');\r\n                    rowAccumulator.push(stringRow);\r\n                });\r\n                if (errors.length > 0 && !firstWarning) {\r\n                    firstWarning = errors[0];\r\n                }\r\n                // finish parsing once we got enough data, otherwise try for more\r\n                // (in some cases PapaParse flushes out last line as separate chunk)\r\n                if (rowAccumulator.length >= PREVIEW_ROW_COUNT) {\r\n                    nodeStream.pause(); // parser does not pause source stream, do it here explicitly\r\n                    parser.abort();\r\n                    reportSuccess();\r\n                }\r\n            }, complete: reportSuccess }));\r\n    }).catch((error) => {\r\n        return {\r\n            parseError: error,\r\n            file\r\n        };\r\n    });\r\n}\r\nexport function processFile(input, reportProgress, callback) {\r\n    const { file, hasHeaders, papaParseConfig, fieldAssignments } = input;\r\n    const fieldNames = Object.keys(fieldAssignments);\r\n    // wrap synchronous errors in promise\r\n    return new Promise((resolve, reject) => {\r\n        // skip first line if needed\r\n        let skipLine = hasHeaders;\r\n        let processedCount = 0;\r\n        // use our own multibyte-safe decoding streamer\r\n        // @todo wait for upstream multibyte fix in PapaParse: https://github.com/mholt/PapaParse/issues/908\r\n        const nodeStream = nodeStreamWrapper(streamForBlob(file), papaParseConfig.encoding || 'utf-8');\r\n        Papa.parse(nodeStream, Object.assign(Object.assign({}, papaParseConfig), { chunkSize: papaParseConfig.chunkSize || 10000, error: (error) => {\r\n                reject(error);\r\n            }, chunk: ({ data }, parser) => {\r\n                // pause to wait until the rows are consumed\r\n                nodeStream.pause(); // parser does not pause source stream, do it here explicitly\r\n                parser.pause();\r\n                const skipped = skipLine && data.length > 0;\r\n                const rows = (skipped ? data.slice(1) : data).map((row) => {\r\n                    const stringRow = row.map((item) => typeof item === 'string' ? item : '');\r\n                    const record = {};\r\n                    fieldNames.forEach((fieldName) => {\r\n                        const columnIndex = fieldAssignments[fieldName];\r\n                        if (columnIndex !== undefined) {\r\n                            record[fieldName] = stringRow[columnIndex];\r\n                        }\r\n                    });\r\n                    return record; // @todo look into a more precise setup\r\n                });\r\n                // clear line skip flag if there was anything to skip\r\n                if (skipped) {\r\n                    skipLine = false;\r\n                }\r\n                // info snapshot for processing callback\r\n                const info = {\r\n                    startIndex: processedCount\r\n                };\r\n                processedCount += rows.length;\r\n                // @todo collect errors\r\n                reportProgress(rows.length);\r\n                // wrap sync errors in promise\r\n                // (avoid invoking callback if there are no rows to consume)\r\n                const whenConsumed = new Promise((resolve) => {\r\n                    const result = rows.length ? callback(rows, info) : undefined;\r\n                    // introduce delay to allow a frame render\r\n                    setTimeout(() => resolve(result), 0);\r\n                });\r\n                // unpause parsing when done\r\n                whenConsumed.then(() => {\r\n                    nodeStream.resume();\r\n                    parser.resume();\r\n                }, () => {\r\n                    // @todo collect errors\r\n                    nodeStream.resume();\r\n                    parser.resume();\r\n                });\r\n            }, complete: () => {\r\n                resolve();\r\n            } }));\r\n    });\r\n}\r\n","import React from 'react';\r\nimport './TextButton.scss';\r\nexport const TextButton = ({ disabled, onClick, children }) => {\r\n    return (React.createElement(\"button\", { className: \"CSVImporter_TextButton\", disabled: disabled, onClick: onClick }, children));\r\n};\r\n","import React from 'react';\r\nimport './IconButton.scss';\r\nexport const IconButton = ({ type, label, small, focusOnly, disabled, onClick }) => {\r\n    return (React.createElement(\"button\", { className: \"CSVImporter_IconButton\", \"aria-label\": label, disabled: disabled, onClick: onClick, \"data-small\": !!small, \"data-focus-only\": !!focusOnly },\r\n        React.createElement(\"span\", { \"data-type\": type })));\r\n};\r\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types -- all exports are ImporterLocale which is already fully typed */\r\nexport const enUS = {\r\n    general: {\r\n        goToPreviousStepTooltip: 'Go to previous step'\r\n    },\r\n    fileStep: {\r\n        initialDragDropPrompt: 'Drag-and-drop CSV file here, or click to select in folder',\r\n        activeDragDropPrompt: 'Drop CSV file here...',\r\n        getImportError: (message) => `Import error: ${message}`,\r\n        getDataFormatError: (message) => `Please check data formatting: ${message}`,\r\n        goBackButton: 'Go Back',\r\n        nextButton: 'Choose columns',\r\n        rawFileContentsHeading: 'Raw File Contents',\r\n        previewImportHeading: 'Preview Import',\r\n        dataHasHeadersCheckbox: 'Data has headers',\r\n        previewLoadingStatus: 'Loading preview...'\r\n    },\r\n    fieldsStep: {\r\n        stepSubtitle: 'Select Columns',\r\n        requiredFieldsError: 'Please assign all required fields',\r\n        nextButton: 'Import',\r\n        dragSourceAreaCaption: 'Columns to import',\r\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Page ${currentPage} of ${pageCount}`,\r\n        getDragSourceActiveStatus: (columnCode) => `Assigning column ${columnCode}`,\r\n        nextColumnsTooltip: 'Show next columns',\r\n        previousColumnsTooltip: 'Show previous columns',\r\n        clearAssignmentTooltip: 'Clear column assignment',\r\n        selectColumnTooltip: 'Select column for assignment',\r\n        unselectColumnTooltip: 'Unselect column',\r\n        dragTargetAreaCaption: 'Target fields',\r\n        getDragTargetOptionalCaption: (field) => `${field} (optional)`,\r\n        getDragTargetRequiredCaption: (field) => `${field} (required)`,\r\n        dragTargetPlaceholder: 'Drag column here',\r\n        getDragTargetAssignTooltip: (columnCode) => `Assign column ${columnCode}`,\r\n        dragTargetClearTooltip: 'Clear column assignment',\r\n        columnCardDummyHeader: 'Unassigned field',\r\n        getColumnCardHeader: (code) => `Column ${code}`\r\n    },\r\n    progressStep: {\r\n        stepSubtitle: 'Import',\r\n        uploadMoreButton: 'Upload More',\r\n        finishButton: 'Finish',\r\n        statusError: 'Could not import',\r\n        statusComplete: 'Complete',\r\n        statusPending: 'Importing...',\r\n        processedRowsLabel: 'Processed rows:'\r\n    }\r\n};\r\nexport const deDE = {\r\n    general: {\r\n        goToPreviousStepTooltip: 'Zum vorherigen Schritt'\r\n    },\r\n    fileStep: {\r\n        initialDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen, oder klicken um eine Datei auszuwählen',\r\n        activeDragDropPrompt: 'CSV-Datei auf dieses Feld ziehen...',\r\n        nextButton: 'Spalten auswählen',\r\n        getImportError: (message) => `Fehler beim Import: ${message}`,\r\n        getDataFormatError: (message) => `Bitte Datenformat überprüfen: ${message}`,\r\n        goBackButton: 'Zurück',\r\n        rawFileContentsHeading: 'Originaler Datei-Inhalt',\r\n        previewImportHeading: 'Import-Vorschau',\r\n        dataHasHeadersCheckbox: 'Mit Kopfzeile',\r\n        previewLoadingStatus: 'Vorschau wird geladen...'\r\n    },\r\n    fieldsStep: {\r\n        stepSubtitle: 'Spalten auswählen',\r\n        requiredFieldsError: 'Bitte weise allen nicht optionalen Spalten einen Wert zu',\r\n        nextButton: 'Importieren',\r\n        dragSourceAreaCaption: 'Zu importierende Spalte',\r\n        getDragSourcePageIndicator: (currentPage, pageCount) => `Seite ${currentPage} von ${pageCount}`,\r\n        getDragSourceActiveStatus: (columnCode) => `Spalte ${columnCode} zuweisen`,\r\n        nextColumnsTooltip: 'Nächste Spalten anzeigen',\r\n        previousColumnsTooltip: 'Vorherige Spalten anzeigen',\r\n        clearAssignmentTooltip: 'Zugewiesene Spalte entfernen',\r\n        selectColumnTooltip: 'Spalte zum Zuweisen auswählen',\r\n        unselectColumnTooltip: 'Spalte abwählen',\r\n        dragTargetAreaCaption: 'Zielfelder',\r\n        getDragTargetOptionalCaption: (field) => `${field} (optional)`,\r\n        getDragTargetRequiredCaption: (field) => `${field} (erforderlich)`,\r\n        dragTargetPlaceholder: 'Spalte hierher ziehen',\r\n        getDragTargetAssignTooltip: (columnCode) => `Spalte ${columnCode} zuweisen`,\r\n        dragTargetClearTooltip: 'Zugewiesene Spalte entfernen',\r\n        columnCardDummyHeader: 'Nicht zugewiesenes Feld',\r\n        getColumnCardHeader: (code) => `Spalte ${code}`\r\n    },\r\n    progressStep: {\r\n        stepSubtitle: 'Importieren',\r\n        uploadMoreButton: 'Weitere hochladen',\r\n        finishButton: 'Abschließen',\r\n        statusError: 'Konnte nicht importiert werden',\r\n        statusComplete: 'Fertig',\r\n        statusPending: 'Wird importiert...',\r\n        processedRowsLabel: 'Verarbeitete Zeilen:'\r\n    }\r\n};\r\n","import React from 'react';\r\nimport { enUS } from '.';\r\nimport { useContext } from 'react';\r\nexport const LocaleContext = React.createContext(enUS);\r\nexport function useLocale(namespace) {\r\n    const locale = useContext(LocaleContext);\r\n    return locale[namespace]; // not using memo for basic property getter\r\n}\r\n","import React, { useRef, useEffect } from 'react';\r\nimport { TextButton } from './TextButton';\r\nimport { IconButton } from './IconButton';\r\nimport './ImporterFrame.scss';\r\nimport { useLocale } from '../locale/LocaleContext';\r\nexport const ImporterFrame = ({ fileName, subtitle, secondaryDisabled, secondaryLabel, nextDisabled, nextLabel, error, onSecondary, onNext, onCancel, children }) => {\r\n    const titleRef = useRef(null);\r\n    const subtitleRef = useRef(null);\r\n    useEffect(() => {\r\n        if (subtitleRef.current) {\r\n            subtitleRef.current.focus();\r\n        }\r\n        else if (titleRef.current) {\r\n            titleRef.current.focus();\r\n        }\r\n    }, []);\r\n    const l10n = useLocale('general');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame\" },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__header\" },\r\n            React.createElement(IconButton, { label: l10n.goToPreviousStepTooltip, type: \"arrowBack\", disabled: !onCancel, onClick: onCancel }),\r\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerTitle\", tabIndex: -1, ref: titleRef }, fileName),\r\n            subtitle ? (React.createElement(React.Fragment, null,\r\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerCrumbSeparator\" },\r\n                    React.createElement(\"span\", null)),\r\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerSubtitle\", tabIndex: -1, ref: subtitleRef }, subtitle))) : null),\r\n        children,\r\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footer\" },\r\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerFill\" }),\r\n            error ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerError\", role: \"status\" }, error)) : null,\r\n            secondaryLabel ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerSecondary\" },\r\n                React.createElement(TextButton, { disabled: !!secondaryDisabled, onClick: onSecondary }, secondaryLabel))) : null,\r\n            nextLabel !== false ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerNext\" },\r\n                React.createElement(TextButton, { disabled: !!nextDisabled, onClick: onNext }, nextLabel))) : null)));\r\n};\r\n","import React, { useCallback, useRef } from 'react';\r\nimport { useDropzone } from 'react-dropzone';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nimport './FileSelector.scss';\r\nexport const FileSelector = ({ onSelected }) => {\r\n    const onSelectedRef = useRef(onSelected);\r\n    onSelectedRef.current = onSelected;\r\n    const dropHandler = useCallback((acceptedFiles) => {\r\n        // silently ignore if nothing to do\r\n        if (acceptedFiles.length < 1) {\r\n            return;\r\n        }\r\n        const file = acceptedFiles[0];\r\n        onSelectedRef.current(file);\r\n    }, []);\r\n    const { getRootProps, getInputProps, isDragActive } = useDropzone({\r\n        onDrop: dropHandler\r\n    });\r\n    const l10n = useLocale('fileStep');\r\n    return (React.createElement(\"div\", Object.assign({ className: \"CSVImporter_FileSelector\", \"data-active\": !!isDragActive }, getRootProps()),\r\n        React.createElement(\"input\", Object.assign({}, getInputProps())),\r\n        isDragActive ? (React.createElement(\"span\", null, l10n.activeDragDropPrompt)) : (React.createElement(\"span\", null, l10n.initialDragDropPrompt))));\r\n};\r\n","import React from 'react';\r\nimport { TextButton } from '../TextButton';\r\nimport './FormatErrorMessage.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nexport const FormatErrorMessage = React.memo(({ onCancelClick, children }) => {\r\n    const l10n = useLocale('fileStep');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatErrorMessage\" },\r\n        React.createElement(\"span\", null, children),\r\n        React.createElement(TextButton, { onClick: onCancelClick }, l10n.goBackButton)));\r\n});\r\n","import React from 'react';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nimport { FormatErrorMessage } from './FormatErrorMessage';\r\nimport './FormatRawPreview.scss';\r\nconst RAW_PREVIEW_SIZE = 500;\r\nexport const FormatRawPreview = React.memo(({ chunk, warning, onCancelClick }) => {\r\n    const chunkSlice = chunk.slice(0, RAW_PREVIEW_SIZE);\r\n    const chunkHasMore = chunk.length > RAW_PREVIEW_SIZE;\r\n    const l10n = useLocale('fileStep');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview\" },\r\n        React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview__scroll\" },\r\n            React.createElement(\"pre\", { className: \"CSVImporter_FormatRawPreview__pre\" },\r\n                chunkSlice,\r\n                chunkHasMore && React.createElement(\"aside\", null, \"...\"))),\r\n        warning ? (React.createElement(FormatErrorMessage, { onCancelClick: onCancelClick }, l10n.getDataFormatError(warning.message || String(warning)))) : null));\r\n});\r\n","import React from 'react';\r\nimport './FormatDataRowPreview.scss';\r\nexport const FormatDataRowPreview = React.memo(({ hasHeaders, rows }) => {\r\n    const headerRow = hasHeaders ? rows[0] : null;\r\n    const bodyRows = hasHeaders ? rows.slice(1) : rows;\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatDataRowPreview\" },\r\n        React.createElement(\"table\", { className: \"CSVImporter_FormatDataRowPreview__table\" },\r\n            headerRow && (React.createElement(\"thead\", null,\r\n                React.createElement(\"tr\", null, headerRow.map((item, itemIndex) => (React.createElement(\"th\", { key: itemIndex }, item)))))),\r\n            React.createElement(\"tbody\", null, bodyRows.map((row, rowIndex) => (React.createElement(\"tr\", { key: rowIndex }, row.map((item, itemIndex) => (React.createElement(\"td\", { key: itemIndex }, item))))))))));\r\n});\r\n","import React, { useMemo, useRef, useEffect, useState } from 'react';\r\nimport { parsePreview } from '../../parser';\r\nimport { ImporterFrame } from '../ImporterFrame';\r\nimport { FileSelector } from './FileSelector';\r\nimport { FormatRawPreview } from './FormatRawPreview';\r\nimport { FormatDataRowPreview } from './FormatDataRowPreview';\r\nimport { FormatErrorMessage } from './FormatErrorMessage';\r\nimport './FileStep.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nexport const FileStep = ({ customConfig, assumeNoHeaders, prevState, onChange, onAccept }) => {\r\n    // seed from previous state as needed\r\n    const [selectedFile, setSelectedFile] = useState(prevState ? prevState.file : null);\r\n    const [preview, setPreview] = useState(() => prevState && Object.assign({ parseError: undefined }, prevState));\r\n    const [papaParseConfig, setPapaParseConfig] = useState(prevState ? prevState.papaParseConfig : customConfig);\r\n    const [hasHeaders, setHasHeaders] = useState(prevState ? prevState.hasHeaders : false);\r\n    // wrap in ref to avoid triggering effect\r\n    const customConfigRef = useRef(customConfig);\r\n    customConfigRef.current = customConfig;\r\n    const assumeNoHeadersRef = useRef(assumeNoHeaders);\r\n    assumeNoHeadersRef.current = assumeNoHeaders;\r\n    const onChangeRef = useRef(onChange);\r\n    onChangeRef.current = onChange;\r\n    // notify of current state\r\n    useEffect(() => {\r\n        onChangeRef.current(preview && !preview.parseError\r\n            ? Object.assign(Object.assign({}, preview), { papaParseConfig, hasHeaders }) : null);\r\n    }, [preview, papaParseConfig, hasHeaders]);\r\n    // perform async preview parse once for the given file\r\n    const asyncLockRef = useRef(0);\r\n    useEffect(() => {\r\n        // clear other state when file selector is reset\r\n        if (!selectedFile) {\r\n            setPreview(null);\r\n            return;\r\n        }\r\n        // preserve existing state when parsing for this file is already complete\r\n        if (preview && preview.file === selectedFile) {\r\n            return;\r\n        }\r\n        const oplock = asyncLockRef.current;\r\n        // lock in the current PapaParse config instance for use in multiple spots\r\n        const config = customConfigRef.current;\r\n        // kick off the preview parse\r\n        parsePreview(selectedFile, config).then((results) => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return;\r\n            }\r\n            // save the results and the original config\r\n            setPreview(results);\r\n            setPapaParseConfig(config);\r\n            // pre-fill headers flag (only possible with >1 lines)\r\n            setHasHeaders(results.parseError\r\n                ? false\r\n                : !assumeNoHeadersRef.current && !results.isSingleLine);\r\n        });\r\n        return () => {\r\n            // invalidate current oplock on change or unmount\r\n            asyncLockRef.current += 1;\r\n        };\r\n    }, [selectedFile, preview]);\r\n    const l10n = useLocale('fileStep');\r\n    // clear selected file\r\n    // preview result content to display\r\n    const reportBlock = useMemo(() => {\r\n        if (!preview) {\r\n            return null;\r\n        }\r\n        if (preview.parseError) {\r\n            return (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainResultBlock\" },\r\n                React.createElement(FormatErrorMessage, { onCancelClick: () => setSelectedFile(null) }, l10n.getImportError(preview.parseError.message || String(preview.parseError)))));\r\n        }\r\n        return (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainResultBlock\" },\r\n            React.createElement(\"div\", { className: \"CSVImporter_FileStep__header\" }, l10n.rawFileContentsHeading),\r\n            React.createElement(FormatRawPreview, { chunk: preview.firstChunk, warning: preview.parseWarning, onCancelClick: () => setSelectedFile(null) }),\r\n            preview.parseWarning ? null : (React.createElement(React.Fragment, null,\r\n                React.createElement(\"div\", { className: \"CSVImporter_FileStep__header\" },\r\n                    l10n.previewImportHeading,\r\n                    !preview.isSingleLine && ( // hide setting if only one line anyway\r\n                    React.createElement(\"label\", { className: \"CSVImporter_FileStep__headerToggle\" },\r\n                        React.createElement(\"input\", { type: \"checkbox\", checked: hasHeaders, onChange: () => {\r\n                                setHasHeaders((prev) => !prev);\r\n                            } }),\r\n                        React.createElement(\"span\", null, l10n.dataHasHeadersCheckbox)))),\r\n                React.createElement(FormatDataRowPreview, { hasHeaders: hasHeaders, rows: preview.firstRows })))));\r\n    }, [preview, hasHeaders, l10n]);\r\n    if (!selectedFile) {\r\n        return React.createElement(FileSelector, { onSelected: (file) => setSelectedFile(file) });\r\n    }\r\n    return (React.createElement(ImporterFrame, { fileName: selectedFile.name, nextDisabled: !preview || !!preview.parseError || !!preview.parseWarning, onNext: () => {\r\n            if (!preview || preview.parseError) {\r\n                throw new Error('unexpected missing preview info');\r\n            }\r\n            onAccept();\r\n        }, onCancel: () => setSelectedFile(null), nextLabel: l10n.nextButton }, reportBlock || (React.createElement(\"div\", { className: \"CSVImporter_FileStep__mainPendingBlock\" }, l10n.previewLoadingStatus))));\r\n};\r\n","// spreadsheet-style column code computation (A, B, ..., Z, AA, AB, ..., etc)\r\nexport function generateColumnCode(value) {\r\n    // ignore dummy index\r\n    if (value < 0) {\r\n        return '';\r\n    }\r\n    // first, determine how many base-26 letters there should be\r\n    // (because the notation is not purely positional)\r\n    let digitCount = 1;\r\n    let base = 0;\r\n    let next = 26;\r\n    while (next <= value) {\r\n        digitCount += 1;\r\n        base = next;\r\n        next = next * 26 + 26;\r\n    }\r\n    // then, apply normal positional digit computation on remainder above base\r\n    let remainder = value - base;\r\n    const digits = [];\r\n    while (digits.length < digitCount) {\r\n        const lastDigit = remainder % 26;\r\n        remainder = Math.floor((remainder - lastDigit) / 26); // applying floor just in case\r\n        // store ASCII code, with A as 0\r\n        digits.unshift(65 + lastDigit);\r\n    }\r\n    return String.fromCharCode.apply(null, digits);\r\n}\r\n// prepare spreadsheet-like column display information for given raw data preview\r\nexport function generatePreviewColumns(firstRows, hasHeaders) {\r\n    const columnStubs = [...new Array(firstRows[0].length)];\r\n    return columnStubs.map((empty, index) => {\r\n        const values = firstRows.map((row) => row[index] || '');\r\n        const headerValue = hasHeaders ? values.shift() : undefined;\r\n        return {\r\n            index,\r\n            header: headerValue,\r\n            values\r\n        };\r\n    });\r\n}\r\n","import { useState, useCallback, useEffect, useRef } from 'react';\r\nimport { useDrag } from 'react-use-gesture';\r\nexport function useColumnDragState(fields, initialAssignments, onTouched) {\r\n    // wrap in ref to avoid re-triggering\r\n    const onTouchedRef = useRef(onTouched);\r\n    onTouchedRef.current = onTouched;\r\n    const [dragState, setDragState] = useState(null);\r\n    const [fieldAssignments, setFieldAssignments] = useState(initialAssignments);\r\n    // make sure there are no extra fields\r\n    useEffect(() => {\r\n        const removedFieldNames = Object.keys(fieldAssignments).filter((existingFieldName) => !fields.some((field) => field.name === existingFieldName));\r\n        if (removedFieldNames.length > 0) {\r\n            // @todo put everything inside this setter\r\n            setFieldAssignments((prev) => {\r\n                const copy = Object.assign({}, prev);\r\n                removedFieldNames.forEach((fieldName) => {\r\n                    delete copy[fieldName];\r\n                });\r\n                return copy;\r\n            });\r\n        }\r\n    }, [fields, fieldAssignments]);\r\n    const internalAssignHandler = useCallback((column, fieldName) => {\r\n        setFieldAssignments((prevAssignments) => {\r\n            const copy = Object.assign({}, prevAssignments);\r\n            // ensure dropped column does not show up elsewhere\r\n            Object.keys(prevAssignments).forEach((name) => {\r\n                if (copy[name] === column.index) {\r\n                    delete copy[name];\r\n                }\r\n            });\r\n            // set new field column\r\n            if (fieldName !== null) {\r\n                copy[fieldName] = column.index;\r\n            }\r\n            return copy;\r\n        });\r\n        // mark for validation display\r\n        if (fieldName) {\r\n            onTouchedRef.current(fieldName);\r\n        }\r\n    }, []);\r\n    const bindDrag = useDrag(({ first, last, event, xy, args }) => {\r\n        if (first && event) {\r\n            // only prevent default inside first event\r\n            // (touchmove uses passive event handler and would trigger warning)\r\n            event.preventDefault();\r\n            const [column, startFieldName] = args;\r\n            setDragState({\r\n                pointerStartInfo: {\r\n                    initialXY: xy,\r\n                    initialWidth: event.currentTarget instanceof HTMLElement\r\n                        ? event.currentTarget.offsetWidth\r\n                        : 0\r\n                },\r\n                column,\r\n                dropFieldName: startFieldName !== undefined ? startFieldName : null,\r\n                updateListeners: {}\r\n            });\r\n        }\r\n        else if (last) {\r\n            setDragState(null);\r\n            if (dragState) {\r\n                internalAssignHandler(dragState.column, dragState.dropFieldName);\r\n            }\r\n        }\r\n        // @todo figure out a cleaner event stream solution\r\n        if (dragState) {\r\n            const listeners = dragState.updateListeners;\r\n            for (const key of Object.keys(listeners)) {\r\n                listeners[key](xy);\r\n            }\r\n        }\r\n    }, {});\r\n    // when dragging, set root-level user-select:none to prevent text selection, see Importer.scss\r\n    // (done via class toggle to avoid interfering with any other dynamic style changes)\r\n    useEffect(() => {\r\n        if (dragState) {\r\n            document.body.classList.add('CSVImporter_dragging');\r\n        }\r\n        else {\r\n            // remove text selection prevention after a delay (otherwise on iOS it still selects something)\r\n            const timeoutId = setTimeout(() => {\r\n                document.body.classList.remove('CSVImporter_dragging');\r\n            }, 200);\r\n            return () => {\r\n                // if another drag state comes along then cancel our delay and just clean up class right away\r\n                clearTimeout(timeoutId);\r\n                document.body.classList.remove('CSVImporter_dragging');\r\n            };\r\n        }\r\n    }, [dragState]);\r\n    const columnSelectHandler = useCallback((column) => {\r\n        setDragState((prev) => {\r\n            // toggle off if needed\r\n            if (prev && prev.column === column) {\r\n                return null;\r\n            }\r\n            return {\r\n                pointerStartInfo: null,\r\n                column,\r\n                dropFieldName: null,\r\n                updateListeners: {}\r\n            };\r\n        });\r\n    }, []);\r\n    const dragHoverHandler = useCallback((fieldName, isOn) => {\r\n        setDragState((prev) => {\r\n            if (!prev) {\r\n                return prev;\r\n            }\r\n            if (isOn) {\r\n                // set the new drop target\r\n                return Object.assign(Object.assign({}, prev), { dropFieldName: fieldName });\r\n            }\r\n            else if (prev.dropFieldName === fieldName) {\r\n                // clear drop target if we are still the current one\r\n                return Object.assign(Object.assign({}, prev), { dropFieldName: null });\r\n            }\r\n            // no changes by default\r\n            return prev;\r\n        });\r\n    }, []);\r\n    const assignHandler = useCallback((fieldName) => {\r\n        // clear active drag state\r\n        setDragState(null);\r\n        if (dragState) {\r\n            internalAssignHandler(dragState.column, fieldName);\r\n        }\r\n    }, [internalAssignHandler, dragState]);\r\n    const unassignHandler = useCallback((column) => {\r\n        setFieldAssignments((prev) => {\r\n            const assignedFieldName = Object.keys(prev).find((fieldName) => prev[fieldName] === column.index);\r\n            if (assignedFieldName === undefined) {\r\n                return prev;\r\n            }\r\n            const copy = Object.assign({}, prev);\r\n            delete copy[assignedFieldName];\r\n            return copy;\r\n        });\r\n    }, []);\r\n    return {\r\n        fieldAssignments,\r\n        dragState,\r\n        dragEventBinder: bindDrag,\r\n        dragHoverHandler,\r\n        columnSelectHandler,\r\n        assignHandler,\r\n        unassignHandler\r\n    };\r\n}\r\n","import React, { useMemo } from 'react';\r\nimport { PREVIEW_ROW_COUNT } from '../../parser';\r\nimport './ColumnDragCard.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\n// @todo sort out \"grabbing\" cursor state (does not work with pointer-events:none)\r\nexport const ColumnDragCard = ({ hasHeaders, column: optionalColumn, rowCount = PREVIEW_ROW_COUNT, hasError, isAssigned, isShadow, isDraggable, isDragged, isDropIndicator }) => {\r\n    const isDummy = !optionalColumn;\r\n    const column = useMemo(() => optionalColumn || {\r\n        index: -1,\r\n        code: '',\r\n        header: hasHeaders ? '' : undefined,\r\n        values: [...new Array(PREVIEW_ROW_COUNT)].map(() => '')\r\n    }, [optionalColumn, hasHeaders]);\r\n    const headerValue = column.header;\r\n    const dataValues = column.values.slice(0, headerValue === undefined ? rowCount : rowCount - 1);\r\n    const l10n = useLocale('fieldsStep');\r\n    return (\r\n    // not changing variant dynamically because it causes a height jump\r\n    React.createElement(\"div\", { key: isDummy || isShadow ? 1 : isDropIndicator ? 2 : 0, className: \"CSVImporter_ColumnDragCard\", \"data-dummy\": !!isDummy, \"data-error\": !!hasError, \"data-shadow\": !!isShadow, \"data-draggable\": !!isDraggable, \"data-dragged\": !!isDragged, \"data-drop-indicator\": !!isDropIndicator },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardHeader\" },\r\n            isDummy ? (React.createElement(\"var\", { role: \"text\" }, l10n.columnCardDummyHeader)) : (React.createElement(\"var\", { role: \"text\" }, l10n.getColumnCardHeader(column.code))),\r\n            isDummy || isAssigned ? '\\u00a0' : React.createElement(\"b\", { \"aria-hidden\": true }, column.code)),\r\n        headerValue !== undefined ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardValue\", \"data-header\": true }, headerValue || '\\u00a0')) : null,\r\n        React.createElement(\"div\", { role: \"text\" }, dataValues.map((value, valueIndex) => (React.createElement(\"div\", { key: valueIndex, className: \"CSVImporter_ColumnDragCard__cardValue\" }, value || '\\u00a0'))))));\r\n};\r\n","import React, { useRef, useLayoutEffect } from 'react';\r\nimport { createPortal } from 'react-dom';\r\nimport { ColumnDragCard } from './ColumnDragCard';\r\nimport './ColumnDragObject.scss';\r\nexport const ColumnDragObject = ({ dragState }) => {\r\n    const referenceBoxRef = useRef(null);\r\n    // @todo wrap in a no-events overlay to clip against screen edges\r\n    const dragBoxRef = useRef(null);\r\n    const dragObjectPortal = dragState && dragState.pointerStartInfo\r\n        ? createPortal(React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject\" },\r\n            React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__positioner\", ref: dragBoxRef },\r\n                React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__holder\" },\r\n                    React.createElement(ColumnDragCard, { column: dragState.column, isDragged: true })))), document.body)\r\n        : null;\r\n    // set up initial position\r\n    const pointerStartInfo = dragState && dragState.pointerStartInfo;\r\n    useLayoutEffect(() => {\r\n        if (!pointerStartInfo || !dragBoxRef.current) {\r\n            return;\r\n        }\r\n        const { initialXY, initialWidth } = pointerStartInfo;\r\n        dragBoxRef.current.style.left = `${initialXY[0]}px`;\r\n        dragBoxRef.current.style.top = `${initialXY[1]}px`;\r\n        dragBoxRef.current.style.width = `${initialWidth}px`;\r\n        // copy known font style from main content\r\n        // @todo consider other text style properties?\r\n        if (referenceBoxRef.current) {\r\n            const computedStyle = window.getComputedStyle(referenceBoxRef.current);\r\n            dragBoxRef.current.style.fontFamily = computedStyle.fontFamily;\r\n            dragBoxRef.current.style.fontSize = computedStyle.fontSize;\r\n            dragBoxRef.current.style.fontWeight = computedStyle.fontWeight;\r\n            dragBoxRef.current.style.fontStyle = computedStyle.fontStyle;\r\n            dragBoxRef.current.style.letterSpacing = computedStyle.letterSpacing;\r\n        }\r\n    }, [pointerStartInfo]);\r\n    // subscribe to live position updates without state changes\r\n    useLayoutEffect(() => {\r\n        if (dragState) {\r\n            dragState.updateListeners['dragObj'] = (xy) => {\r\n                if (!dragBoxRef.current) {\r\n                    return;\r\n                }\r\n                dragBoxRef.current.style.left = `${xy[0]}px`;\r\n                dragBoxRef.current.style.top = `${xy[1]}px`;\r\n            };\r\n        }\r\n    }, [dragState]);\r\n    return React.createElement(\"div\", { ref: referenceBoxRef }, dragObjectPortal);\r\n};\r\n","import React, { useState, useMemo } from 'react';\r\nimport { ColumnDragCard } from './ColumnDragCard';\r\nimport { IconButton } from '../IconButton';\r\nimport './ColumnDragSourceArea.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nconst SOURCES_PAGE_SIZE = 5; // fraction of 10 for easier counting\r\n// @todo readable status text if not mouse-drag\r\nconst SourceBox = ({ column, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\r\n    const isDragged = dragState ? column === dragState.column : false;\r\n    const isAssigned = useMemo(() => Object.keys(fieldAssignments).some((fieldName) => fieldAssignments[fieldName] === column.index), [fieldAssignments, column]);\r\n    const eventHandlers = useMemo(() => eventBinder(column), [\r\n        eventBinder,\r\n        column\r\n    ]);\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__box\" },\r\n        React.createElement(\"div\", Object.assign({}, (isAssigned ? {} : eventHandlers)),\r\n            React.createElement(ColumnDragCard, { column: column, isAssigned: isAssigned, isShadow: isDragged || isAssigned, isDraggable: !dragState && !isDragged && !isAssigned })),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__boxAction\" }, isAssigned ? (React.createElement(IconButton, { key: \"clear\" // key-prop helps clear focus on click\r\n            , label: l10n.clearAssignmentTooltip, small: true, type: \"replay\", onClick: () => {\r\n                onUnassign(column);\r\n            } })) : (React.createElement(IconButton, { key: \"dragSelect\" // key-prop helps clear focus on click\r\n            , focusOnly: true, label: dragState && dragState.column === column\r\n                ? l10n.unselectColumnTooltip\r\n                : l10n.selectColumnTooltip, small: true, type: \"back\", onClick: () => {\r\n                onSelect(column);\r\n            } })))));\r\n};\r\n// @todo current page indicator (dots)\r\nexport const ColumnDragSourceArea = ({ columns, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\r\n    const [page, setPage] = useState(0);\r\n    const [pageChanged, setPageChanged] = useState(false);\r\n    const pageCount = Math.ceil(columns.length / SOURCES_PAGE_SIZE);\r\n    const start = page * SOURCES_PAGE_SIZE;\r\n    const pageContents = columns\r\n        .slice(start, start + SOURCES_PAGE_SIZE)\r\n        .map((column, columnIndex) => (React.createElement(SourceBox, { key: columnIndex, column: column, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: eventBinder, onSelect: onSelect, onUnassign: onUnassign })));\r\n    while (pageContents.length < SOURCES_PAGE_SIZE) {\r\n        pageContents.push(React.createElement(\"div\", { key: pageContents.length, className: \"CSVImporter_ColumnDragSourceArea__pageFiller\" }));\r\n    }\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragSourceArea\", \"aria-label\": l10n.dragSourceAreaCaption },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\r\n            React.createElement(IconButton, { label: l10n.previousColumnsTooltip, type: \"back\", disabled: page === 0, onClick: () => {\r\n                    setPage((prev) => Math.max(0, prev - 1));\r\n                    setPageChanged(true);\r\n                } })),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__page\" },\r\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: \"status\" }, l10n.getDragSourceActiveStatus(dragState.column.code))) : (\r\n            // show page number if needed (and treat as status role if it has changed)\r\n            // @todo changing role to status does not seem to work\r\n            pageCount > 1 && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: pageChanged ? 'status' : 'text' }, l10n.getDragSourcePageIndicator(page + 1, pageCount)))),\r\n            pageContents),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\r\n            React.createElement(IconButton, { label: l10n.nextColumnsTooltip, type: \"forward\", disabled: page === pageCount - 1, onClick: () => {\r\n                    setPage((prev) => Math.min(pageCount - 1, prev + 1));\r\n                } }))));\r\n};\r\n","import React, { useMemo, useEffect, useRef } from 'react';\r\nimport { ColumnDragCard } from './ColumnDragCard';\r\nimport { IconButton } from '../IconButton';\r\nimport './ColumnDragTargetArea.scss';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nconst TargetBox = ({ hasHeaders, field, touched, assignedColumn, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\r\n    // wrap in ref to avoid re-triggering effect\r\n    const onHoverRef = useRef(onHover);\r\n    onHoverRef.current = onHover;\r\n    // respond to hover events when there is active mouse drag happening\r\n    // (not keyboard-emulated one)\r\n    const containerRef = useRef(null);\r\n    const isHoveredRef = useRef(false); // simple tracking of current hover state to avoid spamming onHover (not for display)\r\n    useEffect(() => {\r\n        const container = containerRef.current;\r\n        if (!dragState || !dragState.pointerStartInfo || !container) {\r\n            return;\r\n        }\r\n        // measure the current scroll-independent position\r\n        const rect = container.getBoundingClientRect();\r\n        const minX = rect.x;\r\n        const maxX = rect.x + rect.width;\r\n        const minY = rect.y;\r\n        const maxY = rect.y + rect.height;\r\n        // listen for pointer movement (mouse or touch) and detect hover\r\n        const listeners = dragState.updateListeners;\r\n        const listenerName = `field:${field.name}`;\r\n        listeners[listenerName] = (xy) => {\r\n            const isInBounds = xy[0] >= minX && xy[0] < maxX && xy[1] >= minY && xy[1] < maxY;\r\n            if (isInBounds !== isHoveredRef.current) {\r\n                // cannot use local var for isHovered state because the effect re-triggers after this\r\n                isHoveredRef.current = isInBounds;\r\n                onHoverRef.current(field.name, isInBounds);\r\n            }\r\n        };\r\n        // cleanup\r\n        return () => {\r\n            delete listeners[listenerName];\r\n        };\r\n    }, [dragState, field.name]);\r\n    // if this field is the current highlighted drop target,\r\n    // get the originating column data for display\r\n    const sourceColumn = dragState && dragState.dropFieldName === field.name\r\n        ? dragState.column\r\n        : null;\r\n    // see if currently assigned column is being dragged again\r\n    const isReDragged = dragState ? dragState.column === assignedColumn : false;\r\n    // drag start handlers for columns that can be re-dragged (i.e. are assigned)\r\n    const dragStartHandlers = useMemo(() => assignedColumn && !isReDragged\r\n        ? eventBinder(assignedColumn, field.name)\r\n        : {}, [eventBinder, assignedColumn, isReDragged, field.name]);\r\n    const valueContents = useMemo(() => {\r\n        if (sourceColumn) {\r\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: sourceColumn, isDropIndicator: true }));\r\n        }\r\n        if (assignedColumn) {\r\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: assignedColumn, isShadow: isReDragged, isDraggable: !isReDragged }));\r\n        }\r\n        const hasError = touched && !field.isOptional;\r\n        return (React.createElement(ColumnDragCard, { rowCount: 3, hasHeaders: hasHeaders, hasError: hasError }));\r\n    }, [hasHeaders, field, touched, assignedColumn, sourceColumn, isReDragged]);\r\n    const l10n = useLocale('fieldsStep');\r\n    // @todo mouse cursor changes to reflect draggable state\r\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragTargetArea__box\", \"aria-label\": field.isOptional\r\n            ? l10n.getDragTargetOptionalCaption(field.label)\r\n            : l10n.getDragTargetRequiredCaption(field.label), ref: containerRef },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxLabel\", \"aria-hidden\": true },\r\n            field.label,\r\n            field.isOptional ? null : React.createElement(\"b\", null, \"*\")),\r\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValue\" },\r\n            !sourceColumn && !assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxPlaceholderHelp\", \"aria-hidden\": true }, l10n.dragTargetPlaceholder)),\r\n            React.createElement(\"div\", Object.assign({}, dragStartHandlers), valueContents),\r\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\r\n                React.createElement(IconButton, { label: l10n.getDragTargetAssignTooltip(dragState.column.code), small: true, type: \"forward\", onClick: () => onAssign(field.name) }))) : (!sourceColumn &&\r\n                assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\r\n                React.createElement(IconButton, { label: l10n.dragTargetClearTooltip, small: true, type: \"close\", onClick: () => onUnassign(assignedColumn) })))))));\r\n};\r\nexport const ColumnDragTargetArea = ({ hasHeaders, fields, columns, fieldTouched, fieldAssignments, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragTargetArea\", \"aria-label\": l10n.dragTargetAreaCaption }, fields.map((field) => {\r\n        const assignedColumnIndex = fieldAssignments[field.name];\r\n        return (React.createElement(TargetBox, { key: field.name, field: field, touched: fieldTouched[field.name], hasHeaders: hasHeaders, assignedColumn: assignedColumnIndex !== undefined\r\n                ? columns[assignedColumnIndex]\r\n                : null, dragState: dragState, eventBinder: eventBinder, onHover: onHover, onAssign: onAssign, onUnassign: onUnassign }));\r\n    })));\r\n};\r\n","import React, { useState, useMemo, useEffect, useRef } from 'react';\r\nimport { ImporterFrame } from '../ImporterFrame';\r\nimport { generatePreviewColumns, generateColumnCode } from './ColumnPreview';\r\nimport { useColumnDragState } from './ColumnDragState';\r\nimport { ColumnDragObject } from './ColumnDragObject';\r\nimport { ColumnDragSourceArea } from './ColumnDragSourceArea';\r\nimport { ColumnDragTargetArea } from './ColumnDragTargetArea';\r\nimport { useLocale } from '../../locale/LocaleContext';\r\nexport const FieldsStep = ({ fileState, fields, prevState, onChange, onAccept, onCancel }) => {\r\n    const onChangeRef = useRef(onChange);\r\n    onChangeRef.current = onChange;\r\n    const columns = useMemo(() => generatePreviewColumns(fileState.firstRows, fileState.hasHeaders).map((item) => (Object.assign(Object.assign({}, item), { code: generateColumnCode(item.index) }))), [fileState]);\r\n    const initialAssignments = useMemo(() => {\r\n        // prep insensitive/fuzzy match stems for known columns\r\n        // (this is ignored if there is already previous state to seed from)\r\n        const columnStems = columns.map((column) => {\r\n            const trimmed = column.header && column.header.trim();\r\n            if (!trimmed) {\r\n                return undefined;\r\n            }\r\n            return trimmed.toLowerCase();\r\n        });\r\n        // pre-assign corresponding fields\r\n        const result = {};\r\n        const assignedColumnIndexes = [];\r\n        fields.forEach((field) => {\r\n            // find by field stem\r\n            const fieldLabelStem = field.label.trim().toLowerCase(); // @todo consider normalizing other whitespace/non-letters\r\n            const matchingColumnIndex = columnStems.findIndex((columnStem, columnIndex) => {\r\n                // no headers or no meaningful stem value\r\n                if (columnStem === undefined) {\r\n                    return false;\r\n                }\r\n                // always check against assigning twice\r\n                if (assignedColumnIndexes[columnIndex]) {\r\n                    return false;\r\n                }\r\n                return columnStem === fieldLabelStem;\r\n            });\r\n            // assign if found\r\n            if (matchingColumnIndex !== -1) {\r\n                assignedColumnIndexes[matchingColumnIndex] = true;\r\n                result[field.name] = matchingColumnIndex;\r\n            }\r\n        });\r\n        return result;\r\n    }, [fields, columns]);\r\n    // track which fields need to show validation warning\r\n    const [fieldTouched, setFieldTouched] = useState({});\r\n    const [validationError, setValidationError] = useState(null);\r\n    const { fieldAssignments, dragState, dragEventBinder, dragHoverHandler, columnSelectHandler, assignHandler, unassignHandler } = useColumnDragState(fields, prevState ? prevState.fieldAssignments : initialAssignments, (fieldName) => {\r\n        setFieldTouched((prev) => {\r\n            if (prev[fieldName]) {\r\n                return prev;\r\n            }\r\n            const copy = Object.assign({}, prev);\r\n            copy[fieldName] = true;\r\n            return copy;\r\n        });\r\n    });\r\n    // notify of current state\r\n    useEffect(() => {\r\n        onChangeRef.current({ fieldAssignments: Object.assign({}, fieldAssignments) });\r\n    }, [fieldAssignments]);\r\n    const l10n = useLocale('fieldsStep');\r\n    return (React.createElement(ImporterFrame, { fileName: fileState.file.name, subtitle: l10n.stepSubtitle, error: validationError, onCancel: onCancel, onNext: () => {\r\n            // mark all fields as touched\r\n            const fullTouchedMap = {};\r\n            fields.some((field) => {\r\n                fullTouchedMap[field.name] = true;\r\n            });\r\n            setFieldTouched(fullTouchedMap);\r\n            // submit if validation succeeds\r\n            const hasUnassignedRequired = fields.some((field) => !field.isOptional && fieldAssignments[field.name] === undefined);\r\n            if (!hasUnassignedRequired) {\r\n                onAccept();\r\n            }\r\n            else {\r\n                setValidationError(l10n.requiredFieldsError);\r\n            }\r\n        }, nextLabel: l10n.nextButton },\r\n        React.createElement(ColumnDragSourceArea, { columns: columns, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: dragEventBinder, onSelect: columnSelectHandler, onUnassign: unassignHandler }),\r\n        React.createElement(ColumnDragTargetArea, { hasHeaders: fileState.hasHeaders, fields: fields, columns: columns, fieldTouched: fieldTouched, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: dragEventBinder, onHover: dragHoverHandler, onAssign: assignHandler, onUnassign: unassignHandler }),\r\n        React.createElement(ColumnDragObject, { dragState: dragState })));\r\n};\r\n","import React, { useState, useEffect, useMemo, useRef } from 'react';\r\nimport { processFile } from '../parser';\r\nimport { ImporterFrame } from './ImporterFrame';\r\nimport './ProgressDisplay.scss';\r\nimport { useLocale } from '../locale/LocaleContext';\r\n// compute actual UTF-8 bytes used by a string\r\n// (inspired by https://stackoverflow.com/questions/10576905/how-to-convert-javascript-unicode-notation-code-to-utf-8)\r\nfunction countUTF8Bytes(item) {\r\n    // re-encode into UTF-8\r\n    const escaped = encodeURIComponent(item);\r\n    // convert byte escape sequences into single characters\r\n    const normalized = escaped.replace(/%\\d\\d/g, '_');\r\n    return normalized.length;\r\n}\r\nexport function ProgressDisplay({ fileState, fieldsState, externalPreview, processChunk, onStart, onComplete, onRestart, onClose }) {\r\n    const [progressCount, setProgressCount] = useState(0);\r\n    const [isComplete, setIsComplete] = useState(false);\r\n    const [error, setError] = useState(null);\r\n    const [isDismissed, setIsDismissed] = useState(false); // prevents double-clicking finish\r\n    // info object exposed to the progress callbacks\r\n    const importInfo = useMemo(() => {\r\n        const fieldList = Object.keys(fieldsState.fieldAssignments);\r\n        const columnSparseList = [];\r\n        fieldList.forEach((field) => {\r\n            const col = fieldsState.fieldAssignments[field];\r\n            if (col !== undefined) {\r\n                columnSparseList[col] = field;\r\n            }\r\n        });\r\n        return {\r\n            file: fileState.file,\r\n            preview: externalPreview,\r\n            fields: fieldList,\r\n            columnFields: [...columnSparseList]\r\n        };\r\n    }, [fileState, fieldsState, externalPreview]);\r\n    // estimate number of rows\r\n    const estimatedRowCount = useMemo(() => {\r\n        // sum up sizes of all the parsed preview rows and get estimated average\r\n        const totalPreviewRowBytes = fileState.firstRows.reduce((prevCount, row) => {\r\n            const rowBytes = row.reduce((prev, item) => {\r\n                return prev + countUTF8Bytes(item) + 1; // add a byte for separator or newline\r\n            }, 0);\r\n            return prevCount + rowBytes;\r\n        }, 0);\r\n        const averagePreviewRowSize = totalPreviewRowBytes / fileState.firstRows.length;\r\n        // divide file size by estimated row size (or fall back to a sensible amount)\r\n        return averagePreviewRowSize > 1\r\n            ? fileState.file.size / averagePreviewRowSize\r\n            : 100;\r\n    }, [fileState]);\r\n    // notify on start of processing\r\n    // (separate effect in case of errors)\r\n    const onStartRef = useRef(onStart); // wrap in ref to avoid re-triggering (only first instance is needed)\r\n    useEffect(() => {\r\n        if (onStartRef.current) {\r\n            onStartRef.current(importInfo);\r\n        }\r\n    }, [importInfo]);\r\n    // notify on end of processing\r\n    // (separate effect in case of errors)\r\n    const onCompleteRef = useRef(onComplete); // wrap in ref to avoid re-triggering\r\n    onCompleteRef.current = onComplete;\r\n    useEffect(() => {\r\n        if (isComplete && onCompleteRef.current) {\r\n            onCompleteRef.current(importInfo);\r\n        }\r\n    }, [importInfo, isComplete]);\r\n    // ensure status gets focus when complete, in case status role is not read out\r\n    const statusRef = useRef(null);\r\n    useEffect(() => {\r\n        if ((isComplete || error) && statusRef.current) {\r\n            statusRef.current.focus();\r\n        }\r\n    }, [isComplete, error]);\r\n    // perform main async parse\r\n    const processChunkRef = useRef(processChunk); // wrap in ref to avoid re-triggering\r\n    const asyncLockRef = useRef(0);\r\n    useEffect(() => {\r\n        const oplock = asyncLockRef.current;\r\n        processFile(Object.assign(Object.assign({}, fileState), { fieldAssignments: fieldsState.fieldAssignments }), (deltaCount) => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return; // @todo signal abort\r\n            }\r\n            setProgressCount((prev) => prev + deltaCount);\r\n        }, processChunkRef.current).then(() => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return;\r\n            }\r\n            setIsComplete(true);\r\n        }, (error) => {\r\n            // ignore if stale\r\n            if (oplock !== asyncLockRef.current) {\r\n                return;\r\n            }\r\n            setError(error);\r\n        });\r\n        return () => {\r\n            // invalidate current oplock on change or unmount\r\n            asyncLockRef.current += 1;\r\n        };\r\n    }, [fileState, fieldsState]);\r\n    // simulate asymptotic progress percentage\r\n    const progressPercentage = useMemo(() => {\r\n        if (isComplete) {\r\n            return 100;\r\n        }\r\n        // inputs hand-picked so that correctly estimated total is about 75% of the bar\r\n        const progressPower = 2.5 * (progressCount / estimatedRowCount);\r\n        const progressLeft = Math.pow(0.5, progressPower);\r\n        // convert to .1 percent precision for smoother bar display\r\n        return Math.floor(1000 - 1000 * progressLeft) / 10;\r\n    }, [estimatedRowCount, progressCount, isComplete]);\r\n    const l10n = useLocale('progressStep');\r\n    return (React.createElement(ImporterFrame, { fileName: fileState.file.name, subtitle: l10n.stepSubtitle, error: error && (error.message || String(error)), secondaryDisabled: !isComplete || isDismissed, secondaryLabel: onRestart && onClose ? l10n.uploadMoreButton : undefined, onSecondary: onRestart && onClose ? onRestart : undefined, nextDisabled: !isComplete || isDismissed, nextLabel: !!(onClose || onRestart) &&\r\n            (onRestart ? l10n.uploadMoreButton : l10n.finishButton), onNext: () => {\r\n            if (onClose) {\r\n                setIsDismissed(true);\r\n                onClose(importInfo);\r\n            }\r\n            else if (onRestart) {\r\n                onRestart();\r\n            }\r\n        } },\r\n        React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay\" },\r\n            isComplete || error ? (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status\", role: \"status\", tabIndex: -1, ref: statusRef }, error ? l10n.statusError : l10n.statusComplete)) : (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status -pending\", role: \"status\" }, l10n.statusPending)),\r\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__count\", role: \"text\" },\r\n                React.createElement(\"var\", null, l10n.processedRowsLabel),\r\n                \" \",\r\n                progressCount),\r\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBar\" },\r\n                React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBarIndicator\", style: { width: `${progressPercentage}%` } })))));\r\n}\r\n","var __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport React, { useMemo, useState, useEffect, useContext } from 'react';\r\nimport { FileStep } from './file-step/FileStep';\r\nimport { generatePreviewColumns } from './fields-step/ColumnPreview';\r\nimport { FieldsStep } from './fields-step/FieldsStep';\r\nimport { ProgressDisplay } from './ProgressDisplay';\r\nimport './Importer.scss';\r\nimport { LocaleContext } from '../locale/LocaleContext';\r\nimport { enUS } from '../locale';\r\nconst FieldDefinitionContext = React.createContext(null);\r\nlet fieldIdCount = 0;\r\n// defines a field to be filled from file column during import\r\nexport const ImporterField = ({ name, label, optional }) => {\r\n    // @todo this is not SSR-compatible\r\n    const fieldId = useMemo(() => (fieldIdCount += 1), []);\r\n    const fieldSetter = useContext(FieldDefinitionContext);\r\n    // update central list as needed\r\n    useEffect(() => {\r\n        if (!fieldSetter) {\r\n            console.error('importer field must be a child of importer'); // @todo\r\n            return;\r\n        }\r\n        fieldSetter((prev) => {\r\n            const newField = { id: fieldId, name, label, isOptional: !!optional };\r\n            const copy = [...prev];\r\n            const existingIndex = copy.findIndex((item) => item.name === name);\r\n            // preserve existing array position if possible\r\n            // @todo keep both copies in a map to deal with dynamic fields better\r\n            if (existingIndex === -1) {\r\n                copy.push(newField);\r\n            }\r\n            else {\r\n                copy[existingIndex] = newField;\r\n            }\r\n            return copy;\r\n        });\r\n    }, [fieldId, fieldSetter, name, label, optional]);\r\n    // on component unmount, remove this field from list by ID\r\n    useEffect(() => {\r\n        if (!fieldSetter) {\r\n            console.error('importer field must be a child of importer'); // @todo\r\n            return;\r\n        }\r\n        return () => {\r\n            fieldSetter((prev) => {\r\n                return prev.filter((field) => field.id !== fieldId);\r\n            });\r\n        };\r\n    }, [fieldId, fieldSetter]);\r\n    return null;\r\n};\r\nexport function Importer(_a) {\r\n    var { assumeNoHeaders, restartable, processChunk, onStart, onComplete, onClose, children: content, locale } = _a, customPapaParseConfig = __rest(_a, [\"assumeNoHeaders\", \"restartable\", \"processChunk\", \"onStart\", \"onComplete\", \"onClose\", \"children\", \"locale\"]);\r\n    // helper to combine our displayed content and the user code that provides field definitions\r\n    const [fields, setFields] = useState([]);\r\n    const [fileState, setFileState] = useState(null);\r\n    const [fileAccepted, setFileAccepted] = useState(false);\r\n    const [fieldsState, setFieldsState] = useState(null);\r\n    const [fieldsAccepted, setFieldsAccepted] = useState(false);\r\n    // reset field assignments when file changes\r\n    const activeFile = fileState && fileState.file;\r\n    useEffect(() => {\r\n        if (activeFile) {\r\n            setFieldsState(null);\r\n        }\r\n    }, [activeFile]);\r\n    const externalPreview = useMemo(() => {\r\n        // generate stable externally-visible data objects\r\n        const externalColumns = fileState &&\r\n            generatePreviewColumns(fileState.firstRows, fileState.hasHeaders);\r\n        return (fileState &&\r\n            externalColumns && {\r\n            rawData: fileState.firstChunk,\r\n            columns: externalColumns,\r\n            skipHeaders: !fileState.hasHeaders,\r\n            parseWarning: fileState.parseWarning\r\n        });\r\n    }, [fileState]);\r\n    // render provided child content that defines the fields\r\n    const contentNodes = useMemo(() => {\r\n        return typeof content === 'function'\r\n            ? content({\r\n                file: fileState && fileState.file,\r\n                preview: externalPreview\r\n            })\r\n            : content;\r\n    }, [fileState, externalPreview, content]);\r\n    const contentWrap = (React.createElement(FieldDefinitionContext.Provider, { value: setFields }, contentNodes));\r\n    // fall back to enUS if no default locale provided\r\n    locale = locale !== null && locale !== void 0 ? locale : enUS;\r\n    if (!fileAccepted || fileState === null || externalPreview === null) {\r\n        return (React.createElement(LocaleContext.Provider, { value: locale },\r\n            React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\r\n                React.createElement(FileStep, { customConfig: customPapaParseConfig, assumeNoHeaders: assumeNoHeaders, prevState: fileState, onChange: (parsedPreview) => {\r\n                        setFileState(parsedPreview);\r\n                    }, onAccept: () => {\r\n                        setFileAccepted(true);\r\n                    } }),\r\n                contentWrap)));\r\n    }\r\n    if (!fieldsAccepted || fieldsState === null) {\r\n        return (React.createElement(LocaleContext.Provider, { value: locale },\r\n            React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\r\n                React.createElement(FieldsStep, { fileState: fileState, fields: fields, prevState: fieldsState, onChange: (state) => {\r\n                        setFieldsState(state);\r\n                    }, onAccept: () => {\r\n                        setFieldsAccepted(true);\r\n                    }, onCancel: () => {\r\n                        // keep existing preview data and assignments\r\n                        setFileAccepted(false);\r\n                    } }),\r\n                contentWrap)));\r\n    }\r\n    return (React.createElement(LocaleContext.Provider, { value: locale },\r\n        React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\r\n            React.createElement(ProgressDisplay, { fileState: fileState, fieldsState: fieldsState, externalPreview: externalPreview, processChunk: processChunk, onStart: onStart, onRestart: restartable\r\n                    ? () => {\r\n                        // reset all state\r\n                        setFileState(null);\r\n                        setFileAccepted(false);\r\n                        setFieldsState(null);\r\n                        setFieldsAccepted(false);\r\n                    }\r\n                    : undefined, onComplete: onComplete, onClose: onClose }),\r\n            contentWrap)));\r\n}\r\n"]},"metadata":{},"sourceType":"script"}